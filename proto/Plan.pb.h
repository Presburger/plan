// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Plan.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_Plan_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_Plan_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "schema.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_Plan_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_Plan_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_Plan_2eproto;
namespace milvus {
namespace proto {
namespace plan {
class AlwaysTrueExpr;
struct AlwaysTrueExprDefaultTypeInternal;
extern AlwaysTrueExprDefaultTypeInternal _AlwaysTrueExpr_default_instance_;
class Array;
struct ArrayDefaultTypeInternal;
extern ArrayDefaultTypeInternal _Array_default_instance_;
class BinaryArithExpr;
struct BinaryArithExprDefaultTypeInternal;
extern BinaryArithExprDefaultTypeInternal _BinaryArithExpr_default_instance_;
class BinaryArithOp;
struct BinaryArithOpDefaultTypeInternal;
extern BinaryArithOpDefaultTypeInternal _BinaryArithOp_default_instance_;
class BinaryArithOpEvalRangeExpr;
struct BinaryArithOpEvalRangeExprDefaultTypeInternal;
extern BinaryArithOpEvalRangeExprDefaultTypeInternal _BinaryArithOpEvalRangeExpr_default_instance_;
class BinaryExpr;
struct BinaryExprDefaultTypeInternal;
extern BinaryExprDefaultTypeInternal _BinaryExpr_default_instance_;
class BinaryRangeExpr;
struct BinaryRangeExprDefaultTypeInternal;
extern BinaryRangeExprDefaultTypeInternal _BinaryRangeExpr_default_instance_;
class ColumnExpr;
struct ColumnExprDefaultTypeInternal;
extern ColumnExprDefaultTypeInternal _ColumnExpr_default_instance_;
class ColumnInfo;
struct ColumnInfoDefaultTypeInternal;
extern ColumnInfoDefaultTypeInternal _ColumnInfo_default_instance_;
class CompareExpr;
struct CompareExprDefaultTypeInternal;
extern CompareExprDefaultTypeInternal _CompareExpr_default_instance_;
class ExistsExpr;
struct ExistsExprDefaultTypeInternal;
extern ExistsExprDefaultTypeInternal _ExistsExpr_default_instance_;
class Expr;
struct ExprDefaultTypeInternal;
extern ExprDefaultTypeInternal _Expr_default_instance_;
class GenericValue;
struct GenericValueDefaultTypeInternal;
extern GenericValueDefaultTypeInternal _GenericValue_default_instance_;
class JSONContainsExpr;
struct JSONContainsExprDefaultTypeInternal;
extern JSONContainsExprDefaultTypeInternal _JSONContainsExpr_default_instance_;
class PlanNode;
struct PlanNodeDefaultTypeInternal;
extern PlanNodeDefaultTypeInternal _PlanNode_default_instance_;
class QueryInfo;
struct QueryInfoDefaultTypeInternal;
extern QueryInfoDefaultTypeInternal _QueryInfo_default_instance_;
class QueryPlanNode;
struct QueryPlanNodeDefaultTypeInternal;
extern QueryPlanNodeDefaultTypeInternal _QueryPlanNode_default_instance_;
class TermExpr;
struct TermExprDefaultTypeInternal;
extern TermExprDefaultTypeInternal _TermExpr_default_instance_;
class UnaryExpr;
struct UnaryExprDefaultTypeInternal;
extern UnaryExprDefaultTypeInternal _UnaryExpr_default_instance_;
class UnaryRangeExpr;
struct UnaryRangeExprDefaultTypeInternal;
extern UnaryRangeExprDefaultTypeInternal _UnaryRangeExpr_default_instance_;
class ValueExpr;
struct ValueExprDefaultTypeInternal;
extern ValueExprDefaultTypeInternal _ValueExpr_default_instance_;
class VectorANNS;
struct VectorANNSDefaultTypeInternal;
extern VectorANNSDefaultTypeInternal _VectorANNS_default_instance_;
}  // namespace plan
}  // namespace proto
}  // namespace milvus
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace milvus {
namespace proto {
namespace plan {
enum JSONContainsExpr_JSONOp : int {
  JSONContainsExpr_JSONOp_Invalid = 0,
  JSONContainsExpr_JSONOp_Contains = 1,
  JSONContainsExpr_JSONOp_ContainsAll = 2,
  JSONContainsExpr_JSONOp_ContainsAny = 3,
  JSONContainsExpr_JSONOp_JSONContainsExpr_JSONOp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  JSONContainsExpr_JSONOp_JSONContainsExpr_JSONOp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool JSONContainsExpr_JSONOp_IsValid(int value);
extern const uint32_t JSONContainsExpr_JSONOp_internal_data_[];
constexpr JSONContainsExpr_JSONOp JSONContainsExpr_JSONOp_JSONOp_MIN = static_cast<JSONContainsExpr_JSONOp>(0);
constexpr JSONContainsExpr_JSONOp JSONContainsExpr_JSONOp_JSONOp_MAX = static_cast<JSONContainsExpr_JSONOp>(3);
constexpr int JSONContainsExpr_JSONOp_JSONOp_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
JSONContainsExpr_JSONOp_descriptor();
template <typename T>
const std::string& JSONContainsExpr_JSONOp_Name(T value) {
  static_assert(std::is_same<T, JSONContainsExpr_JSONOp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to JSONOp_Name().");
  return JSONContainsExpr_JSONOp_Name(static_cast<JSONContainsExpr_JSONOp>(value));
}
template <>
inline const std::string& JSONContainsExpr_JSONOp_Name(JSONContainsExpr_JSONOp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<JSONContainsExpr_JSONOp_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool JSONContainsExpr_JSONOp_Parse(absl::string_view name, JSONContainsExpr_JSONOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JSONContainsExpr_JSONOp>(
      JSONContainsExpr_JSONOp_descriptor(), name, value);
}
enum UnaryExpr_UnaryOp : int {
  UnaryExpr_UnaryOp_Invalid = 0,
  UnaryExpr_UnaryOp_Not = 1,
  UnaryExpr_UnaryOp_UnaryExpr_UnaryOp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UnaryExpr_UnaryOp_UnaryExpr_UnaryOp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UnaryExpr_UnaryOp_IsValid(int value);
extern const uint32_t UnaryExpr_UnaryOp_internal_data_[];
constexpr UnaryExpr_UnaryOp UnaryExpr_UnaryOp_UnaryOp_MIN = static_cast<UnaryExpr_UnaryOp>(0);
constexpr UnaryExpr_UnaryOp UnaryExpr_UnaryOp_UnaryOp_MAX = static_cast<UnaryExpr_UnaryOp>(1);
constexpr int UnaryExpr_UnaryOp_UnaryOp_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
UnaryExpr_UnaryOp_descriptor();
template <typename T>
const std::string& UnaryExpr_UnaryOp_Name(T value) {
  static_assert(std::is_same<T, UnaryExpr_UnaryOp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UnaryOp_Name().");
  return UnaryExpr_UnaryOp_Name(static_cast<UnaryExpr_UnaryOp>(value));
}
template <>
inline const std::string& UnaryExpr_UnaryOp_Name(UnaryExpr_UnaryOp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UnaryExpr_UnaryOp_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool UnaryExpr_UnaryOp_Parse(absl::string_view name, UnaryExpr_UnaryOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnaryExpr_UnaryOp>(
      UnaryExpr_UnaryOp_descriptor(), name, value);
}
enum BinaryExpr_BinaryOp : int {
  BinaryExpr_BinaryOp_Invalid = 0,
  BinaryExpr_BinaryOp_LogicalAnd = 1,
  BinaryExpr_BinaryOp_LogicalOr = 2,
  BinaryExpr_BinaryOp_BinaryExpr_BinaryOp_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BinaryExpr_BinaryOp_BinaryExpr_BinaryOp_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BinaryExpr_BinaryOp_IsValid(int value);
extern const uint32_t BinaryExpr_BinaryOp_internal_data_[];
constexpr BinaryExpr_BinaryOp BinaryExpr_BinaryOp_BinaryOp_MIN = static_cast<BinaryExpr_BinaryOp>(0);
constexpr BinaryExpr_BinaryOp BinaryExpr_BinaryOp_BinaryOp_MAX = static_cast<BinaryExpr_BinaryOp>(2);
constexpr int BinaryExpr_BinaryOp_BinaryOp_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
BinaryExpr_BinaryOp_descriptor();
template <typename T>
const std::string& BinaryExpr_BinaryOp_Name(T value) {
  static_assert(std::is_same<T, BinaryExpr_BinaryOp>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BinaryOp_Name().");
  return BinaryExpr_BinaryOp_Name(static_cast<BinaryExpr_BinaryOp>(value));
}
template <>
inline const std::string& BinaryExpr_BinaryOp_Name(BinaryExpr_BinaryOp value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BinaryExpr_BinaryOp_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool BinaryExpr_BinaryOp_Parse(absl::string_view name, BinaryExpr_BinaryOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BinaryExpr_BinaryOp>(
      BinaryExpr_BinaryOp_descriptor(), name, value);
}
enum OpType : int {
  Invalid = 0,
  GreaterThan = 1,
  GreaterEqual = 2,
  LessThan = 3,
  LessEqual = 4,
  Equal = 5,
  NotEqual = 6,
  PrefixMatch = 7,
  PostfixMatch = 8,
  Match = 9,
  Range = 10,
  In = 11,
  NotIn = 12,
  OpType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OpType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OpType_IsValid(int value);
extern const uint32_t OpType_internal_data_[];
constexpr OpType OpType_MIN = static_cast<OpType>(0);
constexpr OpType OpType_MAX = static_cast<OpType>(12);
constexpr int OpType_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor*
OpType_descriptor();
template <typename T>
const std::string& OpType_Name(T value) {
  static_assert(std::is_same<T, OpType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OpType_Name().");
  return OpType_Name(static_cast<OpType>(value));
}
template <>
inline const std::string& OpType_Name(OpType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<OpType_descriptor,
                                                 0, 12>(
      static_cast<int>(value));
}
inline bool OpType_Parse(absl::string_view name, OpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OpType>(
      OpType_descriptor(), name, value);
}
enum ArithOpType : int {
  Unknown = 0,
  Add = 1,
  Sub = 2,
  Mul = 3,
  Div = 4,
  Mod = 5,
  ArrayLength = 6,
  ArithOpType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ArithOpType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ArithOpType_IsValid(int value);
extern const uint32_t ArithOpType_internal_data_[];
constexpr ArithOpType ArithOpType_MIN = static_cast<ArithOpType>(0);
constexpr ArithOpType ArithOpType_MAX = static_cast<ArithOpType>(6);
constexpr int ArithOpType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
ArithOpType_descriptor();
template <typename T>
const std::string& ArithOpType_Name(T value) {
  static_assert(std::is_same<T, ArithOpType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ArithOpType_Name().");
  return ArithOpType_Name(static_cast<ArithOpType>(value));
}
template <>
inline const std::string& ArithOpType_Name(ArithOpType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ArithOpType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool ArithOpType_Parse(absl::string_view name, ArithOpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ArithOpType>(
      ArithOpType_descriptor(), name, value);
}
enum VectorType : int {
  BinaryVector = 0,
  FloatVector = 1,
  Float16Vector = 2,
  VectorType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VectorType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VectorType_IsValid(int value);
extern const uint32_t VectorType_internal_data_[];
constexpr VectorType VectorType_MIN = static_cast<VectorType>(0);
constexpr VectorType VectorType_MAX = static_cast<VectorType>(2);
constexpr int VectorType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
VectorType_descriptor();
template <typename T>
const std::string& VectorType_Name(T value) {
  static_assert(std::is_same<T, VectorType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VectorType_Name().");
  return VectorType_Name(static_cast<VectorType>(value));
}
template <>
inline const std::string& VectorType_Name(VectorType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VectorType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool VectorType_Parse(absl::string_view name, VectorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VectorType>(
      VectorType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class QueryInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.QueryInfo) */ {
 public:
  inline QueryInfo() : QueryInfo(nullptr) {}
  ~QueryInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryInfo(::google::protobuf::internal::ConstantInitialized);

  inline QueryInfo(const QueryInfo& from)
      : QueryInfo(nullptr, from) {}
  QueryInfo(QueryInfo&& from) noexcept
    : QueryInfo() {
    *this = ::std::move(from);
  }

  inline QueryInfo& operator=(const QueryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryInfo& operator=(QueryInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryInfo* internal_default_instance() {
    return reinterpret_cast<const QueryInfo*>(
               &_QueryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(QueryInfo& a, QueryInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const QueryInfo& from) {
    QueryInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.QueryInfo";
  }
  protected:
  explicit QueryInfo(::google::protobuf::Arena* arena);
  QueryInfo(::google::protobuf::Arena* arena, const QueryInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricTypeFieldNumber = 3,
    kSearchParamsFieldNumber = 4,
    kTopkFieldNumber = 1,
    kRoundDecimalFieldNumber = 5,
  };
  // string metric_type = 3;
  void clear_metric_type() ;
  const std::string& metric_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_metric_type(Arg_&& arg, Args_... args);
  std::string* mutable_metric_type();
  PROTOBUF_NODISCARD std::string* release_metric_type();
  void set_allocated_metric_type(std::string* value);

  private:
  const std::string& _internal_metric_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metric_type(
      const std::string& value);
  std::string* _internal_mutable_metric_type();

  public:
  // string search_params = 4;
  void clear_search_params() ;
  const std::string& search_params() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_search_params(Arg_&& arg, Args_... args);
  std::string* mutable_search_params();
  PROTOBUF_NODISCARD std::string* release_search_params();
  void set_allocated_search_params(std::string* value);

  private:
  const std::string& _internal_search_params() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_search_params(
      const std::string& value);
  std::string* _internal_mutable_search_params();

  public:
  // int64 topk = 1;
  void clear_topk() ;
  ::int64_t topk() const;
  void set_topk(::int64_t value);

  private:
  ::int64_t _internal_topk() const;
  void _internal_set_topk(::int64_t value);

  public:
  // int64 round_decimal = 5;
  void clear_round_decimal() ;
  ::int64_t round_decimal() const;
  void set_round_decimal(::int64_t value);

  private:
  ::int64_t _internal_round_decimal() const;
  void _internal_set_round_decimal(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.QueryInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 0,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr metric_type_;
    ::google::protobuf::internal::ArenaStringPtr search_params_;
    ::int64_t topk_;
    ::int64_t round_decimal_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class ColumnInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.ColumnInfo) */ {
 public:
  inline ColumnInfo() : ColumnInfo(nullptr) {}
  ~ColumnInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ColumnInfo(::google::protobuf::internal::ConstantInitialized);

  inline ColumnInfo(const ColumnInfo& from)
      : ColumnInfo(nullptr, from) {}
  ColumnInfo(ColumnInfo&& from) noexcept
    : ColumnInfo() {
    *this = ::std::move(from);
  }

  inline ColumnInfo& operator=(const ColumnInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnInfo& operator=(ColumnInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnInfo* internal_default_instance() {
    return reinterpret_cast<const ColumnInfo*>(
               &_ColumnInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ColumnInfo& a, ColumnInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ColumnInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ColumnInfo& from) {
    ColumnInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ColumnInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.ColumnInfo";
  }
  protected:
  explicit ColumnInfo(::google::protobuf::Arena* arena);
  ColumnInfo(::google::protobuf::Arena* arena, const ColumnInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNestedPathFieldNumber = 5,
    kFieldIdFieldNumber = 1,
    kDataTypeFieldNumber = 2,
    kIsPrimaryKeyFieldNumber = 3,
    kIsAutoIDFieldNumber = 4,
    kIsPartitionKeyFieldNumber = 6,
    kElementTypeFieldNumber = 7,
  };
  // repeated string nested_path = 5;
  int nested_path_size() const;
  private:
  int _internal_nested_path_size() const;

  public:
  void clear_nested_path() ;
  const std::string& nested_path(int index) const;
  std::string* mutable_nested_path(int index);
  void set_nested_path(int index, const std::string& value);
  void set_nested_path(int index, std::string&& value);
  void set_nested_path(int index, const char* value);
  void set_nested_path(int index, const char* value, std::size_t size);
  void set_nested_path(int index, absl::string_view value);
  std::string* add_nested_path();
  void add_nested_path(const std::string& value);
  void add_nested_path(std::string&& value);
  void add_nested_path(const char* value);
  void add_nested_path(const char* value, std::size_t size);
  void add_nested_path(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& nested_path() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_nested_path();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_nested_path() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_nested_path();

  public:
  // int64 field_id = 1;
  void clear_field_id() ;
  ::int64_t field_id() const;
  void set_field_id(::int64_t value);

  private:
  ::int64_t _internal_field_id() const;
  void _internal_set_field_id(::int64_t value);

  public:
  // .milvus.proto.schema.DataType data_type = 2;
  void clear_data_type() ;
  ::milvus::proto::schema::DataType data_type() const;
  void set_data_type(::milvus::proto::schema::DataType value);

  private:
  ::milvus::proto::schema::DataType _internal_data_type() const;
  void _internal_set_data_type(::milvus::proto::schema::DataType value);

  public:
  // bool is_primary_key = 3;
  void clear_is_primary_key() ;
  bool is_primary_key() const;
  void set_is_primary_key(bool value);

  private:
  bool _internal_is_primary_key() const;
  void _internal_set_is_primary_key(bool value);

  public:
  // bool is_autoID = 4;
  void clear_is_autoid() ;
  bool is_autoid() const;
  void set_is_autoid(bool value);

  private:
  bool _internal_is_autoid() const;
  void _internal_set_is_autoid(bool value);

  public:
  // bool is_partition_key = 6;
  void clear_is_partition_key() ;
  bool is_partition_key() const;
  void set_is_partition_key(bool value);

  private:
  bool _internal_is_partition_key() const;
  void _internal_set_is_partition_key(bool value);

  public:
  // .milvus.proto.schema.DataType element_type = 7;
  void clear_element_type() ;
  ::milvus::proto::schema::DataType element_type() const;
  void set_element_type(::milvus::proto::schema::DataType value);

  private:
  ::milvus::proto::schema::DataType _internal_element_type() const;
  void _internal_set_element_type(::milvus::proto::schema::DataType value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.ColumnInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> nested_path_;
    ::int64_t field_id_;
    int data_type_;
    bool is_primary_key_;
    bool is_autoid_;
    bool is_partition_key_;
    int element_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class Array final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.Array) */ {
 public:
  inline Array() : Array(nullptr) {}
  ~Array() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Array(::google::protobuf::internal::ConstantInitialized);

  inline Array(const Array& from)
      : Array(nullptr, from) {}
  Array(Array&& from) noexcept
    : Array() {
    *this = ::std::move(from);
  }

  inline Array& operator=(const Array& from) {
    CopyFrom(from);
    return *this;
  }
  inline Array& operator=(Array&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Array& default_instance() {
    return *internal_default_instance();
  }
  static inline const Array* internal_default_instance() {
    return reinterpret_cast<const Array*>(
               &_Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Array& a, Array& b) {
    a.Swap(&b);
  }
  inline void Swap(Array* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Array* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Array* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Array>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Array& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Array& from) {
    Array::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Array* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.Array";
  }
  protected:
  explicit Array(::google::protobuf::Arena* arena);
  Array(::google::protobuf::Arena* arena, const Array& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArrayFieldNumber = 1,
    kSameTypeFieldNumber = 2,
    kElementTypeFieldNumber = 3,
  };
  // repeated .milvus.proto.plan.GenericValue array = 1;
  int array_size() const;
  private:
  int _internal_array_size() const;

  public:
  void clear_array() ;
  ::milvus::proto::plan::GenericValue* mutable_array(int index);
  ::google::protobuf::RepeatedPtrField< ::milvus::proto::plan::GenericValue >*
      mutable_array();
  private:
  const ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>& _internal_array() const;
  ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>* _internal_mutable_array();
  public:
  const ::milvus::proto::plan::GenericValue& array(int index) const;
  ::milvus::proto::plan::GenericValue* add_array();
  const ::google::protobuf::RepeatedPtrField< ::milvus::proto::plan::GenericValue >&
      array() const;
  // bool same_type = 2;
  void clear_same_type() ;
  bool same_type() const;
  void set_same_type(bool value);

  private:
  bool _internal_same_type() const;
  void _internal_set_same_type(bool value);

  public:
  // .milvus.proto.schema.DataType element_type = 3;
  void clear_element_type() ;
  ::milvus::proto::schema::DataType element_type() const;
  void set_element_type(::milvus::proto::schema::DataType value);

  private:
  ::milvus::proto::schema::DataType _internal_element_type() const;
  void _internal_set_element_type(::milvus::proto::schema::DataType value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.Array)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::milvus::proto::plan::GenericValue > array_;
    bool same_type_;
    int element_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class GenericValue final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.GenericValue) */ {
 public:
  inline GenericValue() : GenericValue(nullptr) {}
  ~GenericValue() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GenericValue(::google::protobuf::internal::ConstantInitialized);

  inline GenericValue(const GenericValue& from)
      : GenericValue(nullptr, from) {}
  GenericValue(GenericValue&& from) noexcept
    : GenericValue() {
    *this = ::std::move(from);
  }

  inline GenericValue& operator=(const GenericValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericValue& operator=(GenericValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericValue& default_instance() {
    return *internal_default_instance();
  }
  enum ValCase {
    kBoolVal = 1,
    kInt64Val = 2,
    kFloatVal = 3,
    kStringVal = 4,
    kArrayVal = 5,
    VAL_NOT_SET = 0,
  };

  static inline const GenericValue* internal_default_instance() {
    return reinterpret_cast<const GenericValue*>(
               &_GenericValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GenericValue& a, GenericValue& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericValue* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenericValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GenericValue& from) {
    GenericValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenericValue* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.GenericValue";
  }
  protected:
  explicit GenericValue(::google::protobuf::Arena* arena);
  GenericValue(::google::protobuf::Arena* arena, const GenericValue& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoolValFieldNumber = 1,
    kInt64ValFieldNumber = 2,
    kFloatValFieldNumber = 3,
    kStringValFieldNumber = 4,
    kArrayValFieldNumber = 5,
  };
  // bool bool_val = 1;
  bool has_bool_val() const;
  void clear_bool_val() ;
  bool bool_val() const;
  void set_bool_val(bool value);

  private:
  bool _internal_bool_val() const;
  void _internal_set_bool_val(bool value);

  public:
  // int64 int64_val = 2;
  bool has_int64_val() const;
  void clear_int64_val() ;
  ::int64_t int64_val() const;
  void set_int64_val(::int64_t value);

  private:
  ::int64_t _internal_int64_val() const;
  void _internal_set_int64_val(::int64_t value);

  public:
  // double float_val = 3;
  bool has_float_val() const;
  void clear_float_val() ;
  double float_val() const;
  void set_float_val(double value);

  private:
  double _internal_float_val() const;
  void _internal_set_float_val(double value);

  public:
  // string string_val = 4;
  bool has_string_val() const;
  void clear_string_val() ;
  const std::string& string_val() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_string_val(Arg_&& arg, Args_... args);
  std::string* mutable_string_val();
  PROTOBUF_NODISCARD std::string* release_string_val();
  void set_allocated_string_val(std::string* value);

  private:
  const std::string& _internal_string_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_val(
      const std::string& value);
  std::string* _internal_mutable_string_val();

  public:
  // .milvus.proto.plan.Array array_val = 5;
  bool has_array_val() const;
  private:
  bool _internal_has_array_val() const;

  public:
  void clear_array_val() ;
  const ::milvus::proto::plan::Array& array_val() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::Array* release_array_val();
  ::milvus::proto::plan::Array* mutable_array_val();
  void set_allocated_array_val(::milvus::proto::plan::Array* value);
  void unsafe_arena_set_allocated_array_val(::milvus::proto::plan::Array* value);
  ::milvus::proto::plan::Array* unsafe_arena_release_array_val();

  private:
  const ::milvus::proto::plan::Array& _internal_array_val() const;
  ::milvus::proto::plan::Array* _internal_mutable_array_val();

  public:
  void clear_val();
  ValCase val_case() const;
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.GenericValue)
 private:
  class _Internal;
  void set_has_bool_val();
  void set_has_int64_val();
  void set_has_float_val();
  void set_has_string_val();
  void set_has_array_val();

  inline bool has_val() const;
  inline void clear_has_val();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 1,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union ValUnion {
      constexpr ValUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool bool_val_;
      ::int64_t int64_val_;
      double float_val_;
      ::google::protobuf::internal::ArenaStringPtr string_val_;
      ::milvus::proto::plan::Array* array_val_;
    } val_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class AlwaysTrueExpr final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:milvus.proto.plan.AlwaysTrueExpr) */ {
 public:
  inline AlwaysTrueExpr() : AlwaysTrueExpr(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AlwaysTrueExpr(::google::protobuf::internal::ConstantInitialized);

  inline AlwaysTrueExpr(const AlwaysTrueExpr& from)
      : AlwaysTrueExpr(nullptr, from) {}
  AlwaysTrueExpr(AlwaysTrueExpr&& from) noexcept
    : AlwaysTrueExpr() {
    *this = ::std::move(from);
  }

  inline AlwaysTrueExpr& operator=(const AlwaysTrueExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlwaysTrueExpr& operator=(AlwaysTrueExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlwaysTrueExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlwaysTrueExpr* internal_default_instance() {
    return reinterpret_cast<const AlwaysTrueExpr*>(
               &_AlwaysTrueExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AlwaysTrueExpr& a, AlwaysTrueExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(AlwaysTrueExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlwaysTrueExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlwaysTrueExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlwaysTrueExpr>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AlwaysTrueExpr& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AlwaysTrueExpr& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.AlwaysTrueExpr";
  }
  protected:
  explicit AlwaysTrueExpr(::google::protobuf::Arena* arena);
  AlwaysTrueExpr(::google::protobuf::Arena* arena, const AlwaysTrueExpr& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.AlwaysTrueExpr)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class ValueExpr final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.ValueExpr) */ {
 public:
  inline ValueExpr() : ValueExpr(nullptr) {}
  ~ValueExpr() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValueExpr(::google::protobuf::internal::ConstantInitialized);

  inline ValueExpr(const ValueExpr& from)
      : ValueExpr(nullptr, from) {}
  ValueExpr(ValueExpr&& from) noexcept
    : ValueExpr() {
    *this = ::std::move(from);
  }

  inline ValueExpr& operator=(const ValueExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueExpr& operator=(ValueExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValueExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValueExpr* internal_default_instance() {
    return reinterpret_cast<const ValueExpr*>(
               &_ValueExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ValueExpr& a, ValueExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(ValueExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValueExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValueExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ValueExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ValueExpr& from) {
    ValueExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ValueExpr* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.ValueExpr";
  }
  protected:
  explicit ValueExpr(::google::protobuf::Arena* arena);
  ValueExpr(::google::protobuf::Arena* arena, const ValueExpr& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .milvus.proto.plan.GenericValue value = 1;
  bool has_value() const;
  void clear_value() ;
  const ::milvus::proto::plan::GenericValue& value() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::GenericValue* release_value();
  ::milvus::proto::plan::GenericValue* mutable_value();
  void set_allocated_value(::milvus::proto::plan::GenericValue* value);
  void unsafe_arena_set_allocated_value(::milvus::proto::plan::GenericValue* value);
  ::milvus::proto::plan::GenericValue* unsafe_arena_release_value();

  private:
  const ::milvus::proto::plan::GenericValue& _internal_value() const;
  ::milvus::proto::plan::GenericValue* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.ValueExpr)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::milvus::proto::plan::GenericValue* value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class UnaryRangeExpr final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.UnaryRangeExpr) */ {
 public:
  inline UnaryRangeExpr() : UnaryRangeExpr(nullptr) {}
  ~UnaryRangeExpr() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UnaryRangeExpr(::google::protobuf::internal::ConstantInitialized);

  inline UnaryRangeExpr(const UnaryRangeExpr& from)
      : UnaryRangeExpr(nullptr, from) {}
  UnaryRangeExpr(UnaryRangeExpr&& from) noexcept
    : UnaryRangeExpr() {
    *this = ::std::move(from);
  }

  inline UnaryRangeExpr& operator=(const UnaryRangeExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnaryRangeExpr& operator=(UnaryRangeExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnaryRangeExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnaryRangeExpr* internal_default_instance() {
    return reinterpret_cast<const UnaryRangeExpr*>(
               &_UnaryRangeExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UnaryRangeExpr& a, UnaryRangeExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(UnaryRangeExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnaryRangeExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnaryRangeExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnaryRangeExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UnaryRangeExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UnaryRangeExpr& from) {
    UnaryRangeExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UnaryRangeExpr* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.UnaryRangeExpr";
  }
  protected:
  explicit UnaryRangeExpr(::google::protobuf::Arena* arena);
  UnaryRangeExpr(::google::protobuf::Arena* arena, const UnaryRangeExpr& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnInfoFieldNumber = 1,
    kValueFieldNumber = 3,
    kOpFieldNumber = 2,
  };
  // .milvus.proto.plan.ColumnInfo column_info = 1;
  bool has_column_info() const;
  void clear_column_info() ;
  const ::milvus::proto::plan::ColumnInfo& column_info() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::ColumnInfo* release_column_info();
  ::milvus::proto::plan::ColumnInfo* mutable_column_info();
  void set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value);
  void unsafe_arena_set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value);
  ::milvus::proto::plan::ColumnInfo* unsafe_arena_release_column_info();

  private:
  const ::milvus::proto::plan::ColumnInfo& _internal_column_info() const;
  ::milvus::proto::plan::ColumnInfo* _internal_mutable_column_info();

  public:
  // .milvus.proto.plan.GenericValue value = 3;
  bool has_value() const;
  void clear_value() ;
  const ::milvus::proto::plan::GenericValue& value() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::GenericValue* release_value();
  ::milvus::proto::plan::GenericValue* mutable_value();
  void set_allocated_value(::milvus::proto::plan::GenericValue* value);
  void unsafe_arena_set_allocated_value(::milvus::proto::plan::GenericValue* value);
  ::milvus::proto::plan::GenericValue* unsafe_arena_release_value();

  private:
  const ::milvus::proto::plan::GenericValue& _internal_value() const;
  ::milvus::proto::plan::GenericValue* _internal_mutable_value();

  public:
  // .milvus.proto.plan.OpType op = 2;
  void clear_op() ;
  ::milvus::proto::plan::OpType op() const;
  void set_op(::milvus::proto::plan::OpType value);

  private:
  ::milvus::proto::plan::OpType _internal_op() const;
  void _internal_set_op(::milvus::proto::plan::OpType value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.UnaryRangeExpr)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::milvus::proto::plan::ColumnInfo* column_info_;
    ::milvus::proto::plan::GenericValue* value_;
    int op_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class TermExpr final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.TermExpr) */ {
 public:
  inline TermExpr() : TermExpr(nullptr) {}
  ~TermExpr() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TermExpr(::google::protobuf::internal::ConstantInitialized);

  inline TermExpr(const TermExpr& from)
      : TermExpr(nullptr, from) {}
  TermExpr(TermExpr&& from) noexcept
    : TermExpr() {
    *this = ::std::move(from);
  }

  inline TermExpr& operator=(const TermExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline TermExpr& operator=(TermExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TermExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const TermExpr* internal_default_instance() {
    return reinterpret_cast<const TermExpr*>(
               &_TermExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TermExpr& a, TermExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(TermExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TermExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TermExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TermExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TermExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TermExpr& from) {
    TermExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TermExpr* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.TermExpr";
  }
  protected:
  explicit TermExpr(::google::protobuf::Arena* arena);
  TermExpr(::google::protobuf::Arena* arena, const TermExpr& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kColumnInfoFieldNumber = 1,
    kIsInFieldFieldNumber = 3,
  };
  // repeated .milvus.proto.plan.GenericValue values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::milvus::proto::plan::GenericValue* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField< ::milvus::proto::plan::GenericValue >*
      mutable_values();
  private:
  const ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>& _internal_values() const;
  ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>* _internal_mutable_values();
  public:
  const ::milvus::proto::plan::GenericValue& values(int index) const;
  ::milvus::proto::plan::GenericValue* add_values();
  const ::google::protobuf::RepeatedPtrField< ::milvus::proto::plan::GenericValue >&
      values() const;
  // .milvus.proto.plan.ColumnInfo column_info = 1;
  bool has_column_info() const;
  void clear_column_info() ;
  const ::milvus::proto::plan::ColumnInfo& column_info() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::ColumnInfo* release_column_info();
  ::milvus::proto::plan::ColumnInfo* mutable_column_info();
  void set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value);
  void unsafe_arena_set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value);
  ::milvus::proto::plan::ColumnInfo* unsafe_arena_release_column_info();

  private:
  const ::milvus::proto::plan::ColumnInfo& _internal_column_info() const;
  ::milvus::proto::plan::ColumnInfo* _internal_mutable_column_info();

  public:
  // bool is_in_field = 3;
  void clear_is_in_field() ;
  bool is_in_field() const;
  void set_is_in_field(bool value);

  private:
  bool _internal_is_in_field() const;
  void _internal_set_is_in_field(bool value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.TermExpr)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::milvus::proto::plan::GenericValue > values_;
    ::milvus::proto::plan::ColumnInfo* column_info_;
    bool is_in_field_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class JSONContainsExpr final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.JSONContainsExpr) */ {
 public:
  inline JSONContainsExpr() : JSONContainsExpr(nullptr) {}
  ~JSONContainsExpr() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR JSONContainsExpr(::google::protobuf::internal::ConstantInitialized);

  inline JSONContainsExpr(const JSONContainsExpr& from)
      : JSONContainsExpr(nullptr, from) {}
  JSONContainsExpr(JSONContainsExpr&& from) noexcept
    : JSONContainsExpr() {
    *this = ::std::move(from);
  }

  inline JSONContainsExpr& operator=(const JSONContainsExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline JSONContainsExpr& operator=(JSONContainsExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JSONContainsExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const JSONContainsExpr* internal_default_instance() {
    return reinterpret_cast<const JSONContainsExpr*>(
               &_JSONContainsExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(JSONContainsExpr& a, JSONContainsExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(JSONContainsExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JSONContainsExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JSONContainsExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JSONContainsExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JSONContainsExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const JSONContainsExpr& from) {
    JSONContainsExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(JSONContainsExpr* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.JSONContainsExpr";
  }
  protected:
  explicit JSONContainsExpr(::google::protobuf::Arena* arena);
  JSONContainsExpr(::google::protobuf::Arena* arena, const JSONContainsExpr& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using JSONOp = JSONContainsExpr_JSONOp;
  static constexpr JSONOp Invalid = JSONContainsExpr_JSONOp_Invalid;
  static constexpr JSONOp Contains = JSONContainsExpr_JSONOp_Contains;
  static constexpr JSONOp ContainsAll = JSONContainsExpr_JSONOp_ContainsAll;
  static constexpr JSONOp ContainsAny = JSONContainsExpr_JSONOp_ContainsAny;
  static inline bool JSONOp_IsValid(int value) {
    return JSONContainsExpr_JSONOp_IsValid(value);
  }
  static constexpr JSONOp JSONOp_MIN = JSONContainsExpr_JSONOp_JSONOp_MIN;
  static constexpr JSONOp JSONOp_MAX = JSONContainsExpr_JSONOp_JSONOp_MAX;
  static constexpr int JSONOp_ARRAYSIZE = JSONContainsExpr_JSONOp_JSONOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* JSONOp_descriptor() {
    return JSONContainsExpr_JSONOp_descriptor();
  }
  template <typename T>
  static inline const std::string& JSONOp_Name(T value) {
    return JSONContainsExpr_JSONOp_Name(value);
  }
  static inline bool JSONOp_Parse(absl::string_view name, JSONOp* value) {
    return JSONContainsExpr_JSONOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kElementsFieldNumber = 2,
    kColumnInfoFieldNumber = 1,
    kOpFieldNumber = 3,
    kElementsSameTypeFieldNumber = 4,
  };
  // repeated .milvus.proto.plan.GenericValue elements = 2;
  int elements_size() const;
  private:
  int _internal_elements_size() const;

  public:
  void clear_elements() ;
  ::milvus::proto::plan::GenericValue* mutable_elements(int index);
  ::google::protobuf::RepeatedPtrField< ::milvus::proto::plan::GenericValue >*
      mutable_elements();
  private:
  const ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>& _internal_elements() const;
  ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>* _internal_mutable_elements();
  public:
  const ::milvus::proto::plan::GenericValue& elements(int index) const;
  ::milvus::proto::plan::GenericValue* add_elements();
  const ::google::protobuf::RepeatedPtrField< ::milvus::proto::plan::GenericValue >&
      elements() const;
  // .milvus.proto.plan.ColumnInfo column_info = 1;
  bool has_column_info() const;
  void clear_column_info() ;
  const ::milvus::proto::plan::ColumnInfo& column_info() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::ColumnInfo* release_column_info();
  ::milvus::proto::plan::ColumnInfo* mutable_column_info();
  void set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value);
  void unsafe_arena_set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value);
  ::milvus::proto::plan::ColumnInfo* unsafe_arena_release_column_info();

  private:
  const ::milvus::proto::plan::ColumnInfo& _internal_column_info() const;
  ::milvus::proto::plan::ColumnInfo* _internal_mutable_column_info();

  public:
  // .milvus.proto.plan.JSONContainsExpr.JSONOp op = 3;
  void clear_op() ;
  ::milvus::proto::plan::JSONContainsExpr_JSONOp op() const;
  void set_op(::milvus::proto::plan::JSONContainsExpr_JSONOp value);

  private:
  ::milvus::proto::plan::JSONContainsExpr_JSONOp _internal_op() const;
  void _internal_set_op(::milvus::proto::plan::JSONContainsExpr_JSONOp value);

  public:
  // bool elements_same_type = 4;
  void clear_elements_same_type() ;
  bool elements_same_type() const;
  void set_elements_same_type(bool value);

  private:
  bool _internal_elements_same_type() const;
  void _internal_set_elements_same_type(bool value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.JSONContainsExpr)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::milvus::proto::plan::GenericValue > elements_;
    ::milvus::proto::plan::ColumnInfo* column_info_;
    int op_;
    bool elements_same_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class ExistsExpr final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.ExistsExpr) */ {
 public:
  inline ExistsExpr() : ExistsExpr(nullptr) {}
  ~ExistsExpr() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExistsExpr(::google::protobuf::internal::ConstantInitialized);

  inline ExistsExpr(const ExistsExpr& from)
      : ExistsExpr(nullptr, from) {}
  ExistsExpr(ExistsExpr&& from) noexcept
    : ExistsExpr() {
    *this = ::std::move(from);
  }

  inline ExistsExpr& operator=(const ExistsExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExistsExpr& operator=(ExistsExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExistsExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExistsExpr* internal_default_instance() {
    return reinterpret_cast<const ExistsExpr*>(
               &_ExistsExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ExistsExpr& a, ExistsExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(ExistsExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExistsExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExistsExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExistsExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExistsExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ExistsExpr& from) {
    ExistsExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExistsExpr* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.ExistsExpr";
  }
  protected:
  explicit ExistsExpr(::google::protobuf::Arena* arena);
  ExistsExpr(::google::protobuf::Arena* arena, const ExistsExpr& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .milvus.proto.plan.ColumnInfo info = 1;
  bool has_info() const;
  void clear_info() ;
  const ::milvus::proto::plan::ColumnInfo& info() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::ColumnInfo* release_info();
  ::milvus::proto::plan::ColumnInfo* mutable_info();
  void set_allocated_info(::milvus::proto::plan::ColumnInfo* value);
  void unsafe_arena_set_allocated_info(::milvus::proto::plan::ColumnInfo* value);
  ::milvus::proto::plan::ColumnInfo* unsafe_arena_release_info();

  private:
  const ::milvus::proto::plan::ColumnInfo& _internal_info() const;
  ::milvus::proto::plan::ColumnInfo* _internal_mutable_info();

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.ExistsExpr)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::milvus::proto::plan::ColumnInfo* info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class CompareExpr final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.CompareExpr) */ {
 public:
  inline CompareExpr() : CompareExpr(nullptr) {}
  ~CompareExpr() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CompareExpr(::google::protobuf::internal::ConstantInitialized);

  inline CompareExpr(const CompareExpr& from)
      : CompareExpr(nullptr, from) {}
  CompareExpr(CompareExpr&& from) noexcept
    : CompareExpr() {
    *this = ::std::move(from);
  }

  inline CompareExpr& operator=(const CompareExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompareExpr& operator=(CompareExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompareExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompareExpr* internal_default_instance() {
    return reinterpret_cast<const CompareExpr*>(
               &_CompareExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CompareExpr& a, CompareExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(CompareExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompareExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompareExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompareExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CompareExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CompareExpr& from) {
    CompareExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CompareExpr* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.CompareExpr";
  }
  protected:
  explicit CompareExpr(::google::protobuf::Arena* arena);
  CompareExpr(::google::protobuf::Arena* arena, const CompareExpr& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftColumnInfoFieldNumber = 1,
    kRightColumnInfoFieldNumber = 2,
    kOpFieldNumber = 3,
  };
  // .milvus.proto.plan.ColumnInfo left_column_info = 1;
  bool has_left_column_info() const;
  void clear_left_column_info() ;
  const ::milvus::proto::plan::ColumnInfo& left_column_info() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::ColumnInfo* release_left_column_info();
  ::milvus::proto::plan::ColumnInfo* mutable_left_column_info();
  void set_allocated_left_column_info(::milvus::proto::plan::ColumnInfo* value);
  void unsafe_arena_set_allocated_left_column_info(::milvus::proto::plan::ColumnInfo* value);
  ::milvus::proto::plan::ColumnInfo* unsafe_arena_release_left_column_info();

  private:
  const ::milvus::proto::plan::ColumnInfo& _internal_left_column_info() const;
  ::milvus::proto::plan::ColumnInfo* _internal_mutable_left_column_info();

  public:
  // .milvus.proto.plan.ColumnInfo right_column_info = 2;
  bool has_right_column_info() const;
  void clear_right_column_info() ;
  const ::milvus::proto::plan::ColumnInfo& right_column_info() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::ColumnInfo* release_right_column_info();
  ::milvus::proto::plan::ColumnInfo* mutable_right_column_info();
  void set_allocated_right_column_info(::milvus::proto::plan::ColumnInfo* value);
  void unsafe_arena_set_allocated_right_column_info(::milvus::proto::plan::ColumnInfo* value);
  ::milvus::proto::plan::ColumnInfo* unsafe_arena_release_right_column_info();

  private:
  const ::milvus::proto::plan::ColumnInfo& _internal_right_column_info() const;
  ::milvus::proto::plan::ColumnInfo* _internal_mutable_right_column_info();

  public:
  // .milvus.proto.plan.OpType op = 3;
  void clear_op() ;
  ::milvus::proto::plan::OpType op() const;
  void set_op(::milvus::proto::plan::OpType value);

  private:
  ::milvus::proto::plan::OpType _internal_op() const;
  void _internal_set_op(::milvus::proto::plan::OpType value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.CompareExpr)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::milvus::proto::plan::ColumnInfo* left_column_info_;
    ::milvus::proto::plan::ColumnInfo* right_column_info_;
    int op_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class ColumnExpr final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.ColumnExpr) */ {
 public:
  inline ColumnExpr() : ColumnExpr(nullptr) {}
  ~ColumnExpr() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ColumnExpr(::google::protobuf::internal::ConstantInitialized);

  inline ColumnExpr(const ColumnExpr& from)
      : ColumnExpr(nullptr, from) {}
  ColumnExpr(ColumnExpr&& from) noexcept
    : ColumnExpr() {
    *this = ::std::move(from);
  }

  inline ColumnExpr& operator=(const ColumnExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnExpr& operator=(ColumnExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnExpr* internal_default_instance() {
    return reinterpret_cast<const ColumnExpr*>(
               &_ColumnExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ColumnExpr& a, ColumnExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ColumnExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ColumnExpr& from) {
    ColumnExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ColumnExpr* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.ColumnExpr";
  }
  protected:
  explicit ColumnExpr(::google::protobuf::Arena* arena);
  ColumnExpr(::google::protobuf::Arena* arena, const ColumnExpr& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .milvus.proto.plan.ColumnInfo info = 1;
  bool has_info() const;
  void clear_info() ;
  const ::milvus::proto::plan::ColumnInfo& info() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::ColumnInfo* release_info();
  ::milvus::proto::plan::ColumnInfo* mutable_info();
  void set_allocated_info(::milvus::proto::plan::ColumnInfo* value);
  void unsafe_arena_set_allocated_info(::milvus::proto::plan::ColumnInfo* value);
  ::milvus::proto::plan::ColumnInfo* unsafe_arena_release_info();

  private:
  const ::milvus::proto::plan::ColumnInfo& _internal_info() const;
  ::milvus::proto::plan::ColumnInfo* _internal_mutable_info();

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.ColumnExpr)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::milvus::proto::plan::ColumnInfo* info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class BinaryRangeExpr final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.BinaryRangeExpr) */ {
 public:
  inline BinaryRangeExpr() : BinaryRangeExpr(nullptr) {}
  ~BinaryRangeExpr() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BinaryRangeExpr(::google::protobuf::internal::ConstantInitialized);

  inline BinaryRangeExpr(const BinaryRangeExpr& from)
      : BinaryRangeExpr(nullptr, from) {}
  BinaryRangeExpr(BinaryRangeExpr&& from) noexcept
    : BinaryRangeExpr() {
    *this = ::std::move(from);
  }

  inline BinaryRangeExpr& operator=(const BinaryRangeExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryRangeExpr& operator=(BinaryRangeExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryRangeExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryRangeExpr* internal_default_instance() {
    return reinterpret_cast<const BinaryRangeExpr*>(
               &_BinaryRangeExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BinaryRangeExpr& a, BinaryRangeExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryRangeExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryRangeExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryRangeExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryRangeExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BinaryRangeExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BinaryRangeExpr& from) {
    BinaryRangeExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BinaryRangeExpr* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.BinaryRangeExpr";
  }
  protected:
  explicit BinaryRangeExpr(::google::protobuf::Arena* arena);
  BinaryRangeExpr(::google::protobuf::Arena* arena, const BinaryRangeExpr& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnInfoFieldNumber = 1,
    kLowerValueFieldNumber = 4,
    kUpperValueFieldNumber = 5,
    kLowerInclusiveFieldNumber = 2,
    kUpperInclusiveFieldNumber = 3,
  };
  // .milvus.proto.plan.ColumnInfo column_info = 1;
  bool has_column_info() const;
  void clear_column_info() ;
  const ::milvus::proto::plan::ColumnInfo& column_info() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::ColumnInfo* release_column_info();
  ::milvus::proto::plan::ColumnInfo* mutable_column_info();
  void set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value);
  void unsafe_arena_set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value);
  ::milvus::proto::plan::ColumnInfo* unsafe_arena_release_column_info();

  private:
  const ::milvus::proto::plan::ColumnInfo& _internal_column_info() const;
  ::milvus::proto::plan::ColumnInfo* _internal_mutable_column_info();

  public:
  // .milvus.proto.plan.GenericValue lower_value = 4;
  bool has_lower_value() const;
  void clear_lower_value() ;
  const ::milvus::proto::plan::GenericValue& lower_value() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::GenericValue* release_lower_value();
  ::milvus::proto::plan::GenericValue* mutable_lower_value();
  void set_allocated_lower_value(::milvus::proto::plan::GenericValue* value);
  void unsafe_arena_set_allocated_lower_value(::milvus::proto::plan::GenericValue* value);
  ::milvus::proto::plan::GenericValue* unsafe_arena_release_lower_value();

  private:
  const ::milvus::proto::plan::GenericValue& _internal_lower_value() const;
  ::milvus::proto::plan::GenericValue* _internal_mutable_lower_value();

  public:
  // .milvus.proto.plan.GenericValue upper_value = 5;
  bool has_upper_value() const;
  void clear_upper_value() ;
  const ::milvus::proto::plan::GenericValue& upper_value() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::GenericValue* release_upper_value();
  ::milvus::proto::plan::GenericValue* mutable_upper_value();
  void set_allocated_upper_value(::milvus::proto::plan::GenericValue* value);
  void unsafe_arena_set_allocated_upper_value(::milvus::proto::plan::GenericValue* value);
  ::milvus::proto::plan::GenericValue* unsafe_arena_release_upper_value();

  private:
  const ::milvus::proto::plan::GenericValue& _internal_upper_value() const;
  ::milvus::proto::plan::GenericValue* _internal_mutable_upper_value();

  public:
  // bool lower_inclusive = 2;
  void clear_lower_inclusive() ;
  bool lower_inclusive() const;
  void set_lower_inclusive(bool value);

  private:
  bool _internal_lower_inclusive() const;
  void _internal_set_lower_inclusive(bool value);

  public:
  // bool upper_inclusive = 3;
  void clear_upper_inclusive() ;
  bool upper_inclusive() const;
  void set_upper_inclusive(bool value);

  private:
  bool _internal_upper_inclusive() const;
  void _internal_set_upper_inclusive(bool value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.BinaryRangeExpr)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::milvus::proto::plan::ColumnInfo* column_info_;
    ::milvus::proto::plan::GenericValue* lower_value_;
    ::milvus::proto::plan::GenericValue* upper_value_;
    bool lower_inclusive_;
    bool upper_inclusive_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class BinaryArithOpEvalRangeExpr final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.BinaryArithOpEvalRangeExpr) */ {
 public:
  inline BinaryArithOpEvalRangeExpr() : BinaryArithOpEvalRangeExpr(nullptr) {}
  ~BinaryArithOpEvalRangeExpr() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BinaryArithOpEvalRangeExpr(::google::protobuf::internal::ConstantInitialized);

  inline BinaryArithOpEvalRangeExpr(const BinaryArithOpEvalRangeExpr& from)
      : BinaryArithOpEvalRangeExpr(nullptr, from) {}
  BinaryArithOpEvalRangeExpr(BinaryArithOpEvalRangeExpr&& from) noexcept
    : BinaryArithOpEvalRangeExpr() {
    *this = ::std::move(from);
  }

  inline BinaryArithOpEvalRangeExpr& operator=(const BinaryArithOpEvalRangeExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryArithOpEvalRangeExpr& operator=(BinaryArithOpEvalRangeExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryArithOpEvalRangeExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryArithOpEvalRangeExpr* internal_default_instance() {
    return reinterpret_cast<const BinaryArithOpEvalRangeExpr*>(
               &_BinaryArithOpEvalRangeExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(BinaryArithOpEvalRangeExpr& a, BinaryArithOpEvalRangeExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryArithOpEvalRangeExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryArithOpEvalRangeExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryArithOpEvalRangeExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryArithOpEvalRangeExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BinaryArithOpEvalRangeExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BinaryArithOpEvalRangeExpr& from) {
    BinaryArithOpEvalRangeExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BinaryArithOpEvalRangeExpr* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.BinaryArithOpEvalRangeExpr";
  }
  protected:
  explicit BinaryArithOpEvalRangeExpr(::google::protobuf::Arena* arena);
  BinaryArithOpEvalRangeExpr(::google::protobuf::Arena* arena, const BinaryArithOpEvalRangeExpr& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnInfoFieldNumber = 1,
    kRightOperandFieldNumber = 3,
    kValueFieldNumber = 5,
    kArithOpFieldNumber = 2,
    kOpFieldNumber = 4,
  };
  // .milvus.proto.plan.ColumnInfo column_info = 1;
  bool has_column_info() const;
  void clear_column_info() ;
  const ::milvus::proto::plan::ColumnInfo& column_info() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::ColumnInfo* release_column_info();
  ::milvus::proto::plan::ColumnInfo* mutable_column_info();
  void set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value);
  void unsafe_arena_set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value);
  ::milvus::proto::plan::ColumnInfo* unsafe_arena_release_column_info();

  private:
  const ::milvus::proto::plan::ColumnInfo& _internal_column_info() const;
  ::milvus::proto::plan::ColumnInfo* _internal_mutable_column_info();

  public:
  // .milvus.proto.plan.GenericValue right_operand = 3;
  bool has_right_operand() const;
  void clear_right_operand() ;
  const ::milvus::proto::plan::GenericValue& right_operand() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::GenericValue* release_right_operand();
  ::milvus::proto::plan::GenericValue* mutable_right_operand();
  void set_allocated_right_operand(::milvus::proto::plan::GenericValue* value);
  void unsafe_arena_set_allocated_right_operand(::milvus::proto::plan::GenericValue* value);
  ::milvus::proto::plan::GenericValue* unsafe_arena_release_right_operand();

  private:
  const ::milvus::proto::plan::GenericValue& _internal_right_operand() const;
  ::milvus::proto::plan::GenericValue* _internal_mutable_right_operand();

  public:
  // .milvus.proto.plan.GenericValue value = 5;
  bool has_value() const;
  void clear_value() ;
  const ::milvus::proto::plan::GenericValue& value() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::GenericValue* release_value();
  ::milvus::proto::plan::GenericValue* mutable_value();
  void set_allocated_value(::milvus::proto::plan::GenericValue* value);
  void unsafe_arena_set_allocated_value(::milvus::proto::plan::GenericValue* value);
  ::milvus::proto::plan::GenericValue* unsafe_arena_release_value();

  private:
  const ::milvus::proto::plan::GenericValue& _internal_value() const;
  ::milvus::proto::plan::GenericValue* _internal_mutable_value();

  public:
  // .milvus.proto.plan.ArithOpType arith_op = 2;
  void clear_arith_op() ;
  ::milvus::proto::plan::ArithOpType arith_op() const;
  void set_arith_op(::milvus::proto::plan::ArithOpType value);

  private:
  ::milvus::proto::plan::ArithOpType _internal_arith_op() const;
  void _internal_set_arith_op(::milvus::proto::plan::ArithOpType value);

  public:
  // .milvus.proto.plan.OpType op = 4;
  void clear_op() ;
  ::milvus::proto::plan::OpType op() const;
  void set_op(::milvus::proto::plan::OpType value);

  private:
  ::milvus::proto::plan::OpType _internal_op() const;
  void _internal_set_op(::milvus::proto::plan::OpType value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.BinaryArithOpEvalRangeExpr)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::milvus::proto::plan::ColumnInfo* column_info_;
    ::milvus::proto::plan::GenericValue* right_operand_;
    ::milvus::proto::plan::GenericValue* value_;
    int arith_op_;
    int op_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class BinaryArithOp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.BinaryArithOp) */ {
 public:
  inline BinaryArithOp() : BinaryArithOp(nullptr) {}
  ~BinaryArithOp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BinaryArithOp(::google::protobuf::internal::ConstantInitialized);

  inline BinaryArithOp(const BinaryArithOp& from)
      : BinaryArithOp(nullptr, from) {}
  BinaryArithOp(BinaryArithOp&& from) noexcept
    : BinaryArithOp() {
    *this = ::std::move(from);
  }

  inline BinaryArithOp& operator=(const BinaryArithOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryArithOp& operator=(BinaryArithOp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryArithOp& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryArithOp* internal_default_instance() {
    return reinterpret_cast<const BinaryArithOp*>(
               &_BinaryArithOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BinaryArithOp& a, BinaryArithOp& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryArithOp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryArithOp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryArithOp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryArithOp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BinaryArithOp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BinaryArithOp& from) {
    BinaryArithOp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BinaryArithOp* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.BinaryArithOp";
  }
  protected:
  explicit BinaryArithOp(::google::protobuf::Arena* arena);
  BinaryArithOp(::google::protobuf::Arena* arena, const BinaryArithOp& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnInfoFieldNumber = 1,
    kRightOperandFieldNumber = 3,
    kArithOpFieldNumber = 2,
  };
  // .milvus.proto.plan.ColumnInfo column_info = 1;
  bool has_column_info() const;
  void clear_column_info() ;
  const ::milvus::proto::plan::ColumnInfo& column_info() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::ColumnInfo* release_column_info();
  ::milvus::proto::plan::ColumnInfo* mutable_column_info();
  void set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value);
  void unsafe_arena_set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value);
  ::milvus::proto::plan::ColumnInfo* unsafe_arena_release_column_info();

  private:
  const ::milvus::proto::plan::ColumnInfo& _internal_column_info() const;
  ::milvus::proto::plan::ColumnInfo* _internal_mutable_column_info();

  public:
  // .milvus.proto.plan.GenericValue right_operand = 3;
  bool has_right_operand() const;
  void clear_right_operand() ;
  const ::milvus::proto::plan::GenericValue& right_operand() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::GenericValue* release_right_operand();
  ::milvus::proto::plan::GenericValue* mutable_right_operand();
  void set_allocated_right_operand(::milvus::proto::plan::GenericValue* value);
  void unsafe_arena_set_allocated_right_operand(::milvus::proto::plan::GenericValue* value);
  ::milvus::proto::plan::GenericValue* unsafe_arena_release_right_operand();

  private:
  const ::milvus::proto::plan::GenericValue& _internal_right_operand() const;
  ::milvus::proto::plan::GenericValue* _internal_mutable_right_operand();

  public:
  // .milvus.proto.plan.ArithOpType arith_op = 2;
  void clear_arith_op() ;
  ::milvus::proto::plan::ArithOpType arith_op() const;
  void set_arith_op(::milvus::proto::plan::ArithOpType value);

  private:
  ::milvus::proto::plan::ArithOpType _internal_arith_op() const;
  void _internal_set_arith_op(::milvus::proto::plan::ArithOpType value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.BinaryArithOp)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::milvus::proto::plan::ColumnInfo* column_info_;
    ::milvus::proto::plan::GenericValue* right_operand_;
    int arith_op_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class BinaryArithExpr final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.BinaryArithExpr) */ {
 public:
  inline BinaryArithExpr() : BinaryArithExpr(nullptr) {}
  ~BinaryArithExpr() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BinaryArithExpr(::google::protobuf::internal::ConstantInitialized);

  inline BinaryArithExpr(const BinaryArithExpr& from)
      : BinaryArithExpr(nullptr, from) {}
  BinaryArithExpr(BinaryArithExpr&& from) noexcept
    : BinaryArithExpr() {
    *this = ::std::move(from);
  }

  inline BinaryArithExpr& operator=(const BinaryArithExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryArithExpr& operator=(BinaryArithExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryArithExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryArithExpr* internal_default_instance() {
    return reinterpret_cast<const BinaryArithExpr*>(
               &_BinaryArithExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BinaryArithExpr& a, BinaryArithExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryArithExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryArithExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryArithExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryArithExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BinaryArithExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BinaryArithExpr& from) {
    BinaryArithExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BinaryArithExpr* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.BinaryArithExpr";
  }
  protected:
  explicit BinaryArithExpr(::google::protobuf::Arena* arena);
  BinaryArithExpr(::google::protobuf::Arena* arena, const BinaryArithExpr& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftFieldNumber = 1,
    kRightFieldNumber = 2,
    kOpFieldNumber = 3,
  };
  // .milvus.proto.plan.Expr left = 1;
  bool has_left() const;
  void clear_left() ;
  const ::milvus::proto::plan::Expr& left() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::Expr* release_left();
  ::milvus::proto::plan::Expr* mutable_left();
  void set_allocated_left(::milvus::proto::plan::Expr* value);
  void unsafe_arena_set_allocated_left(::milvus::proto::plan::Expr* value);
  ::milvus::proto::plan::Expr* unsafe_arena_release_left();

  private:
  const ::milvus::proto::plan::Expr& _internal_left() const;
  ::milvus::proto::plan::Expr* _internal_mutable_left();

  public:
  // .milvus.proto.plan.Expr right = 2;
  bool has_right() const;
  void clear_right() ;
  const ::milvus::proto::plan::Expr& right() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::Expr* release_right();
  ::milvus::proto::plan::Expr* mutable_right();
  void set_allocated_right(::milvus::proto::plan::Expr* value);
  void unsafe_arena_set_allocated_right(::milvus::proto::plan::Expr* value);
  ::milvus::proto::plan::Expr* unsafe_arena_release_right();

  private:
  const ::milvus::proto::plan::Expr& _internal_right() const;
  ::milvus::proto::plan::Expr* _internal_mutable_right();

  public:
  // .milvus.proto.plan.ArithOpType op = 3;
  void clear_op() ;
  ::milvus::proto::plan::ArithOpType op() const;
  void set_op(::milvus::proto::plan::ArithOpType value);

  private:
  ::milvus::proto::plan::ArithOpType _internal_op() const;
  void _internal_set_op(::milvus::proto::plan::ArithOpType value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.BinaryArithExpr)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::milvus::proto::plan::Expr* left_;
    ::milvus::proto::plan::Expr* right_;
    int op_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class BinaryExpr final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.BinaryExpr) */ {
 public:
  inline BinaryExpr() : BinaryExpr(nullptr) {}
  ~BinaryExpr() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BinaryExpr(::google::protobuf::internal::ConstantInitialized);

  inline BinaryExpr(const BinaryExpr& from)
      : BinaryExpr(nullptr, from) {}
  BinaryExpr(BinaryExpr&& from) noexcept
    : BinaryExpr() {
    *this = ::std::move(from);
  }

  inline BinaryExpr& operator=(const BinaryExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryExpr& operator=(BinaryExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryExpr* internal_default_instance() {
    return reinterpret_cast<const BinaryExpr*>(
               &_BinaryExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BinaryExpr& a, BinaryExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BinaryExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BinaryExpr& from) {
    BinaryExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BinaryExpr* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.BinaryExpr";
  }
  protected:
  explicit BinaryExpr(::google::protobuf::Arena* arena);
  BinaryExpr(::google::protobuf::Arena* arena, const BinaryExpr& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using BinaryOp = BinaryExpr_BinaryOp;
  static constexpr BinaryOp Invalid = BinaryExpr_BinaryOp_Invalid;
  static constexpr BinaryOp LogicalAnd = BinaryExpr_BinaryOp_LogicalAnd;
  static constexpr BinaryOp LogicalOr = BinaryExpr_BinaryOp_LogicalOr;
  static inline bool BinaryOp_IsValid(int value) {
    return BinaryExpr_BinaryOp_IsValid(value);
  }
  static constexpr BinaryOp BinaryOp_MIN = BinaryExpr_BinaryOp_BinaryOp_MIN;
  static constexpr BinaryOp BinaryOp_MAX = BinaryExpr_BinaryOp_BinaryOp_MAX;
  static constexpr int BinaryOp_ARRAYSIZE = BinaryExpr_BinaryOp_BinaryOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* BinaryOp_descriptor() {
    return BinaryExpr_BinaryOp_descriptor();
  }
  template <typename T>
  static inline const std::string& BinaryOp_Name(T value) {
    return BinaryExpr_BinaryOp_Name(value);
  }
  static inline bool BinaryOp_Parse(absl::string_view name, BinaryOp* value) {
    return BinaryExpr_BinaryOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeftFieldNumber = 2,
    kRightFieldNumber = 3,
    kOpFieldNumber = 1,
  };
  // .milvus.proto.plan.Expr left = 2;
  bool has_left() const;
  void clear_left() ;
  const ::milvus::proto::plan::Expr& left() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::Expr* release_left();
  ::milvus::proto::plan::Expr* mutable_left();
  void set_allocated_left(::milvus::proto::plan::Expr* value);
  void unsafe_arena_set_allocated_left(::milvus::proto::plan::Expr* value);
  ::milvus::proto::plan::Expr* unsafe_arena_release_left();

  private:
  const ::milvus::proto::plan::Expr& _internal_left() const;
  ::milvus::proto::plan::Expr* _internal_mutable_left();

  public:
  // .milvus.proto.plan.Expr right = 3;
  bool has_right() const;
  void clear_right() ;
  const ::milvus::proto::plan::Expr& right() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::Expr* release_right();
  ::milvus::proto::plan::Expr* mutable_right();
  void set_allocated_right(::milvus::proto::plan::Expr* value);
  void unsafe_arena_set_allocated_right(::milvus::proto::plan::Expr* value);
  ::milvus::proto::plan::Expr* unsafe_arena_release_right();

  private:
  const ::milvus::proto::plan::Expr& _internal_right() const;
  ::milvus::proto::plan::Expr* _internal_mutable_right();

  public:
  // .milvus.proto.plan.BinaryExpr.BinaryOp op = 1;
  void clear_op() ;
  ::milvus::proto::plan::BinaryExpr_BinaryOp op() const;
  void set_op(::milvus::proto::plan::BinaryExpr_BinaryOp value);

  private:
  ::milvus::proto::plan::BinaryExpr_BinaryOp _internal_op() const;
  void _internal_set_op(::milvus::proto::plan::BinaryExpr_BinaryOp value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.BinaryExpr)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::milvus::proto::plan::Expr* left_;
    ::milvus::proto::plan::Expr* right_;
    int op_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class Expr final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.Expr) */ {
 public:
  inline Expr() : Expr(nullptr) {}
  ~Expr() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Expr(::google::protobuf::internal::ConstantInitialized);

  inline Expr(const Expr& from)
      : Expr(nullptr, from) {}
  Expr(Expr&& from) noexcept
    : Expr() {
    *this = ::std::move(from);
  }

  inline Expr& operator=(const Expr& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expr& operator=(Expr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Expr& default_instance() {
    return *internal_default_instance();
  }
  enum ExprCase {
    kTermExpr = 1,
    kUnaryExpr = 2,
    kBinaryExpr = 3,
    kCompareExpr = 4,
    kUnaryRangeExpr = 5,
    kBinaryRangeExpr = 6,
    kBinaryArithOpEvalRangeExpr = 7,
    kBinaryArithExpr = 8,
    kValueExpr = 9,
    kColumnExpr = 10,
    kExistsExpr = 11,
    kAlwaysTrueExpr = 12,
    kJsonContainsExpr = 13,
    EXPR_NOT_SET = 0,
  };

  static inline const Expr* internal_default_instance() {
    return reinterpret_cast<const Expr*>(
               &_Expr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Expr& a, Expr& b) {
    a.Swap(&b);
  }
  inline void Swap(Expr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Expr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Expr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Expr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Expr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Expr& from) {
    Expr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Expr* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.Expr";
  }
  protected:
  explicit Expr(::google::protobuf::Arena* arena);
  Expr(::google::protobuf::Arena* arena, const Expr& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermExprFieldNumber = 1,
    kUnaryExprFieldNumber = 2,
    kBinaryExprFieldNumber = 3,
    kCompareExprFieldNumber = 4,
    kUnaryRangeExprFieldNumber = 5,
    kBinaryRangeExprFieldNumber = 6,
    kBinaryArithOpEvalRangeExprFieldNumber = 7,
    kBinaryArithExprFieldNumber = 8,
    kValueExprFieldNumber = 9,
    kColumnExprFieldNumber = 10,
    kExistsExprFieldNumber = 11,
    kAlwaysTrueExprFieldNumber = 12,
    kJsonContainsExprFieldNumber = 13,
  };
  // .milvus.proto.plan.TermExpr term_expr = 1;
  bool has_term_expr() const;
  private:
  bool _internal_has_term_expr() const;

  public:
  void clear_term_expr() ;
  const ::milvus::proto::plan::TermExpr& term_expr() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::TermExpr* release_term_expr();
  ::milvus::proto::plan::TermExpr* mutable_term_expr();
  void set_allocated_term_expr(::milvus::proto::plan::TermExpr* value);
  void unsafe_arena_set_allocated_term_expr(::milvus::proto::plan::TermExpr* value);
  ::milvus::proto::plan::TermExpr* unsafe_arena_release_term_expr();

  private:
  const ::milvus::proto::plan::TermExpr& _internal_term_expr() const;
  ::milvus::proto::plan::TermExpr* _internal_mutable_term_expr();

  public:
  // .milvus.proto.plan.UnaryExpr unary_expr = 2;
  bool has_unary_expr() const;
  private:
  bool _internal_has_unary_expr() const;

  public:
  void clear_unary_expr() ;
  const ::milvus::proto::plan::UnaryExpr& unary_expr() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::UnaryExpr* release_unary_expr();
  ::milvus::proto::plan::UnaryExpr* mutable_unary_expr();
  void set_allocated_unary_expr(::milvus::proto::plan::UnaryExpr* value);
  void unsafe_arena_set_allocated_unary_expr(::milvus::proto::plan::UnaryExpr* value);
  ::milvus::proto::plan::UnaryExpr* unsafe_arena_release_unary_expr();

  private:
  const ::milvus::proto::plan::UnaryExpr& _internal_unary_expr() const;
  ::milvus::proto::plan::UnaryExpr* _internal_mutable_unary_expr();

  public:
  // .milvus.proto.plan.BinaryExpr binary_expr = 3;
  bool has_binary_expr() const;
  private:
  bool _internal_has_binary_expr() const;

  public:
  void clear_binary_expr() ;
  const ::milvus::proto::plan::BinaryExpr& binary_expr() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::BinaryExpr* release_binary_expr();
  ::milvus::proto::plan::BinaryExpr* mutable_binary_expr();
  void set_allocated_binary_expr(::milvus::proto::plan::BinaryExpr* value);
  void unsafe_arena_set_allocated_binary_expr(::milvus::proto::plan::BinaryExpr* value);
  ::milvus::proto::plan::BinaryExpr* unsafe_arena_release_binary_expr();

  private:
  const ::milvus::proto::plan::BinaryExpr& _internal_binary_expr() const;
  ::milvus::proto::plan::BinaryExpr* _internal_mutable_binary_expr();

  public:
  // .milvus.proto.plan.CompareExpr compare_expr = 4;
  bool has_compare_expr() const;
  private:
  bool _internal_has_compare_expr() const;

  public:
  void clear_compare_expr() ;
  const ::milvus::proto::plan::CompareExpr& compare_expr() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::CompareExpr* release_compare_expr();
  ::milvus::proto::plan::CompareExpr* mutable_compare_expr();
  void set_allocated_compare_expr(::milvus::proto::plan::CompareExpr* value);
  void unsafe_arena_set_allocated_compare_expr(::milvus::proto::plan::CompareExpr* value);
  ::milvus::proto::plan::CompareExpr* unsafe_arena_release_compare_expr();

  private:
  const ::milvus::proto::plan::CompareExpr& _internal_compare_expr() const;
  ::milvus::proto::plan::CompareExpr* _internal_mutable_compare_expr();

  public:
  // .milvus.proto.plan.UnaryRangeExpr unary_range_expr = 5;
  bool has_unary_range_expr() const;
  private:
  bool _internal_has_unary_range_expr() const;

  public:
  void clear_unary_range_expr() ;
  const ::milvus::proto::plan::UnaryRangeExpr& unary_range_expr() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::UnaryRangeExpr* release_unary_range_expr();
  ::milvus::proto::plan::UnaryRangeExpr* mutable_unary_range_expr();
  void set_allocated_unary_range_expr(::milvus::proto::plan::UnaryRangeExpr* value);
  void unsafe_arena_set_allocated_unary_range_expr(::milvus::proto::plan::UnaryRangeExpr* value);
  ::milvus::proto::plan::UnaryRangeExpr* unsafe_arena_release_unary_range_expr();

  private:
  const ::milvus::proto::plan::UnaryRangeExpr& _internal_unary_range_expr() const;
  ::milvus::proto::plan::UnaryRangeExpr* _internal_mutable_unary_range_expr();

  public:
  // .milvus.proto.plan.BinaryRangeExpr binary_range_expr = 6;
  bool has_binary_range_expr() const;
  private:
  bool _internal_has_binary_range_expr() const;

  public:
  void clear_binary_range_expr() ;
  const ::milvus::proto::plan::BinaryRangeExpr& binary_range_expr() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::BinaryRangeExpr* release_binary_range_expr();
  ::milvus::proto::plan::BinaryRangeExpr* mutable_binary_range_expr();
  void set_allocated_binary_range_expr(::milvus::proto::plan::BinaryRangeExpr* value);
  void unsafe_arena_set_allocated_binary_range_expr(::milvus::proto::plan::BinaryRangeExpr* value);
  ::milvus::proto::plan::BinaryRangeExpr* unsafe_arena_release_binary_range_expr();

  private:
  const ::milvus::proto::plan::BinaryRangeExpr& _internal_binary_range_expr() const;
  ::milvus::proto::plan::BinaryRangeExpr* _internal_mutable_binary_range_expr();

  public:
  // .milvus.proto.plan.BinaryArithOpEvalRangeExpr binary_arith_op_eval_range_expr = 7;
  bool has_binary_arith_op_eval_range_expr() const;
  private:
  bool _internal_has_binary_arith_op_eval_range_expr() const;

  public:
  void clear_binary_arith_op_eval_range_expr() ;
  const ::milvus::proto::plan::BinaryArithOpEvalRangeExpr& binary_arith_op_eval_range_expr() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::BinaryArithOpEvalRangeExpr* release_binary_arith_op_eval_range_expr();
  ::milvus::proto::plan::BinaryArithOpEvalRangeExpr* mutable_binary_arith_op_eval_range_expr();
  void set_allocated_binary_arith_op_eval_range_expr(::milvus::proto::plan::BinaryArithOpEvalRangeExpr* value);
  void unsafe_arena_set_allocated_binary_arith_op_eval_range_expr(::milvus::proto::plan::BinaryArithOpEvalRangeExpr* value);
  ::milvus::proto::plan::BinaryArithOpEvalRangeExpr* unsafe_arena_release_binary_arith_op_eval_range_expr();

  private:
  const ::milvus::proto::plan::BinaryArithOpEvalRangeExpr& _internal_binary_arith_op_eval_range_expr() const;
  ::milvus::proto::plan::BinaryArithOpEvalRangeExpr* _internal_mutable_binary_arith_op_eval_range_expr();

  public:
  // .milvus.proto.plan.BinaryArithExpr binary_arith_expr = 8;
  bool has_binary_arith_expr() const;
  private:
  bool _internal_has_binary_arith_expr() const;

  public:
  void clear_binary_arith_expr() ;
  const ::milvus::proto::plan::BinaryArithExpr& binary_arith_expr() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::BinaryArithExpr* release_binary_arith_expr();
  ::milvus::proto::plan::BinaryArithExpr* mutable_binary_arith_expr();
  void set_allocated_binary_arith_expr(::milvus::proto::plan::BinaryArithExpr* value);
  void unsafe_arena_set_allocated_binary_arith_expr(::milvus::proto::plan::BinaryArithExpr* value);
  ::milvus::proto::plan::BinaryArithExpr* unsafe_arena_release_binary_arith_expr();

  private:
  const ::milvus::proto::plan::BinaryArithExpr& _internal_binary_arith_expr() const;
  ::milvus::proto::plan::BinaryArithExpr* _internal_mutable_binary_arith_expr();

  public:
  // .milvus.proto.plan.ValueExpr value_expr = 9;
  bool has_value_expr() const;
  private:
  bool _internal_has_value_expr() const;

  public:
  void clear_value_expr() ;
  const ::milvus::proto::plan::ValueExpr& value_expr() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::ValueExpr* release_value_expr();
  ::milvus::proto::plan::ValueExpr* mutable_value_expr();
  void set_allocated_value_expr(::milvus::proto::plan::ValueExpr* value);
  void unsafe_arena_set_allocated_value_expr(::milvus::proto::plan::ValueExpr* value);
  ::milvus::proto::plan::ValueExpr* unsafe_arena_release_value_expr();

  private:
  const ::milvus::proto::plan::ValueExpr& _internal_value_expr() const;
  ::milvus::proto::plan::ValueExpr* _internal_mutable_value_expr();

  public:
  // .milvus.proto.plan.ColumnExpr column_expr = 10;
  bool has_column_expr() const;
  private:
  bool _internal_has_column_expr() const;

  public:
  void clear_column_expr() ;
  const ::milvus::proto::plan::ColumnExpr& column_expr() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::ColumnExpr* release_column_expr();
  ::milvus::proto::plan::ColumnExpr* mutable_column_expr();
  void set_allocated_column_expr(::milvus::proto::plan::ColumnExpr* value);
  void unsafe_arena_set_allocated_column_expr(::milvus::proto::plan::ColumnExpr* value);
  ::milvus::proto::plan::ColumnExpr* unsafe_arena_release_column_expr();

  private:
  const ::milvus::proto::plan::ColumnExpr& _internal_column_expr() const;
  ::milvus::proto::plan::ColumnExpr* _internal_mutable_column_expr();

  public:
  // .milvus.proto.plan.ExistsExpr exists_expr = 11;
  bool has_exists_expr() const;
  private:
  bool _internal_has_exists_expr() const;

  public:
  void clear_exists_expr() ;
  const ::milvus::proto::plan::ExistsExpr& exists_expr() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::ExistsExpr* release_exists_expr();
  ::milvus::proto::plan::ExistsExpr* mutable_exists_expr();
  void set_allocated_exists_expr(::milvus::proto::plan::ExistsExpr* value);
  void unsafe_arena_set_allocated_exists_expr(::milvus::proto::plan::ExistsExpr* value);
  ::milvus::proto::plan::ExistsExpr* unsafe_arena_release_exists_expr();

  private:
  const ::milvus::proto::plan::ExistsExpr& _internal_exists_expr() const;
  ::milvus::proto::plan::ExistsExpr* _internal_mutable_exists_expr();

  public:
  // .milvus.proto.plan.AlwaysTrueExpr always_true_expr = 12;
  bool has_always_true_expr() const;
  private:
  bool _internal_has_always_true_expr() const;

  public:
  void clear_always_true_expr() ;
  const ::milvus::proto::plan::AlwaysTrueExpr& always_true_expr() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::AlwaysTrueExpr* release_always_true_expr();
  ::milvus::proto::plan::AlwaysTrueExpr* mutable_always_true_expr();
  void set_allocated_always_true_expr(::milvus::proto::plan::AlwaysTrueExpr* value);
  void unsafe_arena_set_allocated_always_true_expr(::milvus::proto::plan::AlwaysTrueExpr* value);
  ::milvus::proto::plan::AlwaysTrueExpr* unsafe_arena_release_always_true_expr();

  private:
  const ::milvus::proto::plan::AlwaysTrueExpr& _internal_always_true_expr() const;
  ::milvus::proto::plan::AlwaysTrueExpr* _internal_mutable_always_true_expr();

  public:
  // .milvus.proto.plan.JSONContainsExpr json_contains_expr = 13;
  bool has_json_contains_expr() const;
  private:
  bool _internal_has_json_contains_expr() const;

  public:
  void clear_json_contains_expr() ;
  const ::milvus::proto::plan::JSONContainsExpr& json_contains_expr() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::JSONContainsExpr* release_json_contains_expr();
  ::milvus::proto::plan::JSONContainsExpr* mutable_json_contains_expr();
  void set_allocated_json_contains_expr(::milvus::proto::plan::JSONContainsExpr* value);
  void unsafe_arena_set_allocated_json_contains_expr(::milvus::proto::plan::JSONContainsExpr* value);
  ::milvus::proto::plan::JSONContainsExpr* unsafe_arena_release_json_contains_expr();

  private:
  const ::milvus::proto::plan::JSONContainsExpr& _internal_json_contains_expr() const;
  ::milvus::proto::plan::JSONContainsExpr* _internal_mutable_json_contains_expr();

  public:
  void clear_expr();
  ExprCase expr_case() const;
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.Expr)
 private:
  class _Internal;
  void set_has_term_expr();
  void set_has_unary_expr();
  void set_has_binary_expr();
  void set_has_compare_expr();
  void set_has_unary_range_expr();
  void set_has_binary_range_expr();
  void set_has_binary_arith_op_eval_range_expr();
  void set_has_binary_arith_expr();
  void set_has_value_expr();
  void set_has_column_expr();
  void set_has_exists_expr();
  void set_has_always_true_expr();
  void set_has_json_contains_expr();

  inline bool has_expr() const;
  inline void clear_has_expr();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 13, 13,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union ExprUnion {
      constexpr ExprUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::milvus::proto::plan::TermExpr* term_expr_;
      ::milvus::proto::plan::UnaryExpr* unary_expr_;
      ::milvus::proto::plan::BinaryExpr* binary_expr_;
      ::milvus::proto::plan::CompareExpr* compare_expr_;
      ::milvus::proto::plan::UnaryRangeExpr* unary_range_expr_;
      ::milvus::proto::plan::BinaryRangeExpr* binary_range_expr_;
      ::milvus::proto::plan::BinaryArithOpEvalRangeExpr* binary_arith_op_eval_range_expr_;
      ::milvus::proto::plan::BinaryArithExpr* binary_arith_expr_;
      ::milvus::proto::plan::ValueExpr* value_expr_;
      ::milvus::proto::plan::ColumnExpr* column_expr_;
      ::milvus::proto::plan::ExistsExpr* exists_expr_;
      ::milvus::proto::plan::AlwaysTrueExpr* always_true_expr_;
      ::milvus::proto::plan::JSONContainsExpr* json_contains_expr_;
    } expr_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class UnaryExpr final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.UnaryExpr) */ {
 public:
  inline UnaryExpr() : UnaryExpr(nullptr) {}
  ~UnaryExpr() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UnaryExpr(::google::protobuf::internal::ConstantInitialized);

  inline UnaryExpr(const UnaryExpr& from)
      : UnaryExpr(nullptr, from) {}
  UnaryExpr(UnaryExpr&& from) noexcept
    : UnaryExpr() {
    *this = ::std::move(from);
  }

  inline UnaryExpr& operator=(const UnaryExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnaryExpr& operator=(UnaryExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnaryExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnaryExpr* internal_default_instance() {
    return reinterpret_cast<const UnaryExpr*>(
               &_UnaryExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UnaryExpr& a, UnaryExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(UnaryExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnaryExpr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnaryExpr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnaryExpr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UnaryExpr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UnaryExpr& from) {
    UnaryExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UnaryExpr* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.UnaryExpr";
  }
  protected:
  explicit UnaryExpr(::google::protobuf::Arena* arena);
  UnaryExpr(::google::protobuf::Arena* arena, const UnaryExpr& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using UnaryOp = UnaryExpr_UnaryOp;
  static constexpr UnaryOp Invalid = UnaryExpr_UnaryOp_Invalid;
  static constexpr UnaryOp Not = UnaryExpr_UnaryOp_Not;
  static inline bool UnaryOp_IsValid(int value) {
    return UnaryExpr_UnaryOp_IsValid(value);
  }
  static constexpr UnaryOp UnaryOp_MIN = UnaryExpr_UnaryOp_UnaryOp_MIN;
  static constexpr UnaryOp UnaryOp_MAX = UnaryExpr_UnaryOp_UnaryOp_MAX;
  static constexpr int UnaryOp_ARRAYSIZE = UnaryExpr_UnaryOp_UnaryOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* UnaryOp_descriptor() {
    return UnaryExpr_UnaryOp_descriptor();
  }
  template <typename T>
  static inline const std::string& UnaryOp_Name(T value) {
    return UnaryExpr_UnaryOp_Name(value);
  }
  static inline bool UnaryOp_Parse(absl::string_view name, UnaryOp* value) {
    return UnaryExpr_UnaryOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 2,
    kOpFieldNumber = 1,
  };
  // .milvus.proto.plan.Expr child = 2;
  bool has_child() const;
  void clear_child() ;
  const ::milvus::proto::plan::Expr& child() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::Expr* release_child();
  ::milvus::proto::plan::Expr* mutable_child();
  void set_allocated_child(::milvus::proto::plan::Expr* value);
  void unsafe_arena_set_allocated_child(::milvus::proto::plan::Expr* value);
  ::milvus::proto::plan::Expr* unsafe_arena_release_child();

  private:
  const ::milvus::proto::plan::Expr& _internal_child() const;
  ::milvus::proto::plan::Expr* _internal_mutable_child();

  public:
  // .milvus.proto.plan.UnaryExpr.UnaryOp op = 1;
  void clear_op() ;
  ::milvus::proto::plan::UnaryExpr_UnaryOp op() const;
  void set_op(::milvus::proto::plan::UnaryExpr_UnaryOp value);

  private:
  ::milvus::proto::plan::UnaryExpr_UnaryOp _internal_op() const;
  void _internal_set_op(::milvus::proto::plan::UnaryExpr_UnaryOp value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.UnaryExpr)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::milvus::proto::plan::Expr* child_;
    int op_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class VectorANNS final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.VectorANNS) */ {
 public:
  inline VectorANNS() : VectorANNS(nullptr) {}
  ~VectorANNS() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorANNS(::google::protobuf::internal::ConstantInitialized);

  inline VectorANNS(const VectorANNS& from)
      : VectorANNS(nullptr, from) {}
  VectorANNS(VectorANNS&& from) noexcept
    : VectorANNS() {
    *this = ::std::move(from);
  }

  inline VectorANNS& operator=(const VectorANNS& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorANNS& operator=(VectorANNS&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorANNS& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorANNS* internal_default_instance() {
    return reinterpret_cast<const VectorANNS*>(
               &_VectorANNS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(VectorANNS& a, VectorANNS& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorANNS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorANNS* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorANNS* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorANNS>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorANNS& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorANNS& from) {
    VectorANNS::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorANNS* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.VectorANNS";
  }
  protected:
  explicit VectorANNS(::google::protobuf::Arena* arena);
  VectorANNS(::google::protobuf::Arena* arena, const VectorANNS& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaceholderTagFieldNumber = 5,
    kPredicatesFieldNumber = 3,
    kQueryInfoFieldNumber = 4,
    kFieldIdFieldNumber = 2,
    kVectorTypeFieldNumber = 1,
  };
  // string placeholder_tag = 5;
  void clear_placeholder_tag() ;
  const std::string& placeholder_tag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_placeholder_tag(Arg_&& arg, Args_... args);
  std::string* mutable_placeholder_tag();
  PROTOBUF_NODISCARD std::string* release_placeholder_tag();
  void set_allocated_placeholder_tag(std::string* value);

  private:
  const std::string& _internal_placeholder_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_placeholder_tag(
      const std::string& value);
  std::string* _internal_mutable_placeholder_tag();

  public:
  // .milvus.proto.plan.Expr predicates = 3;
  bool has_predicates() const;
  void clear_predicates() ;
  const ::milvus::proto::plan::Expr& predicates() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::Expr* release_predicates();
  ::milvus::proto::plan::Expr* mutable_predicates();
  void set_allocated_predicates(::milvus::proto::plan::Expr* value);
  void unsafe_arena_set_allocated_predicates(::milvus::proto::plan::Expr* value);
  ::milvus::proto::plan::Expr* unsafe_arena_release_predicates();

  private:
  const ::milvus::proto::plan::Expr& _internal_predicates() const;
  ::milvus::proto::plan::Expr* _internal_mutable_predicates();

  public:
  // .milvus.proto.plan.QueryInfo query_info = 4;
  bool has_query_info() const;
  void clear_query_info() ;
  const ::milvus::proto::plan::QueryInfo& query_info() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::QueryInfo* release_query_info();
  ::milvus::proto::plan::QueryInfo* mutable_query_info();
  void set_allocated_query_info(::milvus::proto::plan::QueryInfo* value);
  void unsafe_arena_set_allocated_query_info(::milvus::proto::plan::QueryInfo* value);
  ::milvus::proto::plan::QueryInfo* unsafe_arena_release_query_info();

  private:
  const ::milvus::proto::plan::QueryInfo& _internal_query_info() const;
  ::milvus::proto::plan::QueryInfo* _internal_mutable_query_info();

  public:
  // int64 field_id = 2;
  void clear_field_id() ;
  ::int64_t field_id() const;
  void set_field_id(::int64_t value);

  private:
  ::int64_t _internal_field_id() const;
  void _internal_set_field_id(::int64_t value);

  public:
  // .milvus.proto.plan.VectorType vector_type = 1;
  void clear_vector_type() ;
  ::milvus::proto::plan::VectorType vector_type() const;
  void set_vector_type(::milvus::proto::plan::VectorType value);

  private:
  ::milvus::proto::plan::VectorType _internal_vector_type() const;
  void _internal_set_vector_type(::milvus::proto::plan::VectorType value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.VectorANNS)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr placeholder_tag_;
    ::milvus::proto::plan::Expr* predicates_;
    ::milvus::proto::plan::QueryInfo* query_info_;
    ::int64_t field_id_;
    int vector_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class QueryPlanNode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.QueryPlanNode) */ {
 public:
  inline QueryPlanNode() : QueryPlanNode(nullptr) {}
  ~QueryPlanNode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QueryPlanNode(::google::protobuf::internal::ConstantInitialized);

  inline QueryPlanNode(const QueryPlanNode& from)
      : QueryPlanNode(nullptr, from) {}
  QueryPlanNode(QueryPlanNode&& from) noexcept
    : QueryPlanNode() {
    *this = ::std::move(from);
  }

  inline QueryPlanNode& operator=(const QueryPlanNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryPlanNode& operator=(QueryPlanNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryPlanNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryPlanNode* internal_default_instance() {
    return reinterpret_cast<const QueryPlanNode*>(
               &_QueryPlanNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(QueryPlanNode& a, QueryPlanNode& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryPlanNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryPlanNode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryPlanNode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryPlanNode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryPlanNode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const QueryPlanNode& from) {
    QueryPlanNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryPlanNode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.QueryPlanNode";
  }
  protected:
  explicit QueryPlanNode(::google::protobuf::Arena* arena);
  QueryPlanNode(::google::protobuf::Arena* arena, const QueryPlanNode& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPredicatesFieldNumber = 1,
    kLimitFieldNumber = 3,
    kIsCountFieldNumber = 2,
  };
  // .milvus.proto.plan.Expr predicates = 1;
  bool has_predicates() const;
  void clear_predicates() ;
  const ::milvus::proto::plan::Expr& predicates() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::Expr* release_predicates();
  ::milvus::proto::plan::Expr* mutable_predicates();
  void set_allocated_predicates(::milvus::proto::plan::Expr* value);
  void unsafe_arena_set_allocated_predicates(::milvus::proto::plan::Expr* value);
  ::milvus::proto::plan::Expr* unsafe_arena_release_predicates();

  private:
  const ::milvus::proto::plan::Expr& _internal_predicates() const;
  ::milvus::proto::plan::Expr* _internal_mutable_predicates();

  public:
  // int64 limit = 3;
  void clear_limit() ;
  ::int64_t limit() const;
  void set_limit(::int64_t value);

  private:
  ::int64_t _internal_limit() const;
  void _internal_set_limit(::int64_t value);

  public:
  // bool is_count = 2;
  void clear_is_count() ;
  bool is_count() const;
  void set_is_count(bool value);

  private:
  bool _internal_is_count() const;
  void _internal_set_is_count(bool value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.QueryPlanNode)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::milvus::proto::plan::Expr* predicates_;
    ::int64_t limit_;
    bool is_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};// -------------------------------------------------------------------

class PlanNode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.PlanNode) */ {
 public:
  inline PlanNode() : PlanNode(nullptr) {}
  ~PlanNode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlanNode(::google::protobuf::internal::ConstantInitialized);

  inline PlanNode(const PlanNode& from)
      : PlanNode(nullptr, from) {}
  PlanNode(PlanNode&& from) noexcept
    : PlanNode() {
    *this = ::std::move(from);
  }

  inline PlanNode& operator=(const PlanNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanNode& operator=(PlanNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanNode& default_instance() {
    return *internal_default_instance();
  }
  enum NodeCase {
    kVectorAnns = 1,
    kPredicates = 2,
    kQuery = 4,
    NODE_NOT_SET = 0,
  };

  static inline const PlanNode* internal_default_instance() {
    return reinterpret_cast<const PlanNode*>(
               &_PlanNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PlanNode& a, PlanNode& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanNode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanNode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanNode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlanNode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlanNode& from) {
    PlanNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlanNode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.plan.PlanNode";
  }
  protected:
  explicit PlanNode(::google::protobuf::Arena* arena);
  PlanNode(::google::protobuf::Arena* arena, const PlanNode& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputFieldIdsFieldNumber = 3,
    kVectorAnnsFieldNumber = 1,
    kPredicatesFieldNumber = 2,
    kQueryFieldNumber = 4,
  };
  // repeated int64 output_field_ids = 3;
  int output_field_ids_size() const;
  private:
  int _internal_output_field_ids_size() const;

  public:
  void clear_output_field_ids() ;
  ::int64_t output_field_ids(int index) const;
  void set_output_field_ids(int index, ::int64_t value);
  void add_output_field_ids(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& output_field_ids() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_output_field_ids();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_output_field_ids() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_output_field_ids();

  public:
  // .milvus.proto.plan.VectorANNS vector_anns = 1;
  bool has_vector_anns() const;
  private:
  bool _internal_has_vector_anns() const;

  public:
  void clear_vector_anns() ;
  const ::milvus::proto::plan::VectorANNS& vector_anns() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::VectorANNS* release_vector_anns();
  ::milvus::proto::plan::VectorANNS* mutable_vector_anns();
  void set_allocated_vector_anns(::milvus::proto::plan::VectorANNS* value);
  void unsafe_arena_set_allocated_vector_anns(::milvus::proto::plan::VectorANNS* value);
  ::milvus::proto::plan::VectorANNS* unsafe_arena_release_vector_anns();

  private:
  const ::milvus::proto::plan::VectorANNS& _internal_vector_anns() const;
  ::milvus::proto::plan::VectorANNS* _internal_mutable_vector_anns();

  public:
  // .milvus.proto.plan.Expr predicates = 2;
  bool has_predicates() const;
  private:
  bool _internal_has_predicates() const;

  public:
  void clear_predicates() ;
  const ::milvus::proto::plan::Expr& predicates() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::Expr* release_predicates();
  ::milvus::proto::plan::Expr* mutable_predicates();
  void set_allocated_predicates(::milvus::proto::plan::Expr* value);
  void unsafe_arena_set_allocated_predicates(::milvus::proto::plan::Expr* value);
  ::milvus::proto::plan::Expr* unsafe_arena_release_predicates();

  private:
  const ::milvus::proto::plan::Expr& _internal_predicates() const;
  ::milvus::proto::plan::Expr* _internal_mutable_predicates();

  public:
  // .milvus.proto.plan.QueryPlanNode query = 4;
  bool has_query() const;
  private:
  bool _internal_has_query() const;

  public:
  void clear_query() ;
  const ::milvus::proto::plan::QueryPlanNode& query() const;
  PROTOBUF_NODISCARD ::milvus::proto::plan::QueryPlanNode* release_query();
  ::milvus::proto::plan::QueryPlanNode* mutable_query();
  void set_allocated_query(::milvus::proto::plan::QueryPlanNode* value);
  void unsafe_arena_set_allocated_query(::milvus::proto::plan::QueryPlanNode* value);
  ::milvus::proto::plan::QueryPlanNode* unsafe_arena_release_query();

  private:
  const ::milvus::proto::plan::QueryPlanNode& _internal_query() const;
  ::milvus::proto::plan::QueryPlanNode* _internal_mutable_query();

  public:
  void clear_node();
  NodeCase node_case() const;
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.PlanNode)
 private:
  class _Internal;
  void set_has_vector_anns();
  void set_has_predicates();
  void set_has_query();

  inline bool has_node() const;
  inline void clear_has_node();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::int64_t> output_field_ids_;
    mutable ::google::protobuf::internal::CachedSize _output_field_ids_cached_byte_size_;
    union NodeUnion {
      constexpr NodeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::milvus::proto::plan::VectorANNS* vector_anns_;
      ::milvus::proto::plan::Expr* predicates_;
      ::milvus::proto::plan::QueryPlanNode* query_;
    } node_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Plan_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GenericValue

// bool bool_val = 1;
inline bool GenericValue::has_bool_val() const {
  return val_case() == kBoolVal;
}
inline void GenericValue::set_has_bool_val() {
  _impl_._oneof_case_[0] = kBoolVal;
}
inline void GenericValue::clear_bool_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (val_case() == kBoolVal) {
    _impl_.val_.bool_val_ = false;
    clear_has_val();
  }
}
inline bool GenericValue::bool_val() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.GenericValue.bool_val)
  return _internal_bool_val();
}
inline void GenericValue::set_bool_val(bool value) {
  _internal_set_bool_val(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.GenericValue.bool_val)
}
inline bool GenericValue::_internal_bool_val() const {
  if (val_case() == kBoolVal) {
    return _impl_.val_.bool_val_;
  }
  return false;
}
inline void GenericValue::_internal_set_bool_val(bool value) {
  if (val_case() != kBoolVal) {
    clear_val();
    set_has_bool_val();
  }
  _impl_.val_.bool_val_ = value;
}

// int64 int64_val = 2;
inline bool GenericValue::has_int64_val() const {
  return val_case() == kInt64Val;
}
inline void GenericValue::set_has_int64_val() {
  _impl_._oneof_case_[0] = kInt64Val;
}
inline void GenericValue::clear_int64_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (val_case() == kInt64Val) {
    _impl_.val_.int64_val_ = ::int64_t{0};
    clear_has_val();
  }
}
inline ::int64_t GenericValue::int64_val() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.GenericValue.int64_val)
  return _internal_int64_val();
}
inline void GenericValue::set_int64_val(::int64_t value) {
  _internal_set_int64_val(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.GenericValue.int64_val)
}
inline ::int64_t GenericValue::_internal_int64_val() const {
  if (val_case() == kInt64Val) {
    return _impl_.val_.int64_val_;
  }
  return ::int64_t{0};
}
inline void GenericValue::_internal_set_int64_val(::int64_t value) {
  if (val_case() != kInt64Val) {
    clear_val();
    set_has_int64_val();
  }
  _impl_.val_.int64_val_ = value;
}

// double float_val = 3;
inline bool GenericValue::has_float_val() const {
  return val_case() == kFloatVal;
}
inline void GenericValue::set_has_float_val() {
  _impl_._oneof_case_[0] = kFloatVal;
}
inline void GenericValue::clear_float_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (val_case() == kFloatVal) {
    _impl_.val_.float_val_ = 0;
    clear_has_val();
  }
}
inline double GenericValue::float_val() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.GenericValue.float_val)
  return _internal_float_val();
}
inline void GenericValue::set_float_val(double value) {
  _internal_set_float_val(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.GenericValue.float_val)
}
inline double GenericValue::_internal_float_val() const {
  if (val_case() == kFloatVal) {
    return _impl_.val_.float_val_;
  }
  return 0;
}
inline void GenericValue::_internal_set_float_val(double value) {
  if (val_case() != kFloatVal) {
    clear_val();
    set_has_float_val();
  }
  _impl_.val_.float_val_ = value;
}

// string string_val = 4;
inline bool GenericValue::has_string_val() const {
  return val_case() == kStringVal;
}
inline void GenericValue::set_has_string_val() {
  _impl_._oneof_case_[0] = kStringVal;
}
inline void GenericValue::clear_string_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (val_case() == kStringVal) {
    _impl_.val_.string_val_.Destroy();
    clear_has_val();
  }
}
inline const std::string& GenericValue::string_val() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.GenericValue.string_val)
  return _internal_string_val();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericValue::set_string_val(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (val_case() != kStringVal) {
    clear_val();

    set_has_string_val();
    _impl_.val_.string_val_.InitDefault();
  }
  _impl_.val_.string_val_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:milvus.proto.plan.GenericValue.string_val)
}
inline std::string* GenericValue::mutable_string_val() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_string_val();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.GenericValue.string_val)
  return _s;
}
inline const std::string& GenericValue::_internal_string_val() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (val_case() != kStringVal) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.val_.string_val_.Get();
}
inline void GenericValue::_internal_set_string_val(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (val_case() != kStringVal) {
    clear_val();

    set_has_string_val();
    _impl_.val_.string_val_.InitDefault();
  }
  _impl_.val_.string_val_.Set(value, GetArena());
}
inline std::string* GenericValue::_internal_mutable_string_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (val_case() != kStringVal) {
    clear_val();

    set_has_string_val();
    _impl_.val_.string_val_.InitDefault();
  }
  return _impl_.val_.string_val_.Mutable( GetArena());
}
inline std::string* GenericValue::release_string_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.GenericValue.string_val)
  if (val_case() != kStringVal) {
    return nullptr;
  }
  clear_has_val();
  return _impl_.val_.string_val_.Release();
}
inline void GenericValue::set_allocated_string_val(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_val()) {
    clear_val();
  }
  if (value != nullptr) {
    set_has_string_val();
    _impl_.val_.string_val_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.GenericValue.string_val)
}

// .milvus.proto.plan.Array array_val = 5;
inline bool GenericValue::has_array_val() const {
  return val_case() == kArrayVal;
}
inline bool GenericValue::_internal_has_array_val() const {
  return val_case() == kArrayVal;
}
inline void GenericValue::set_has_array_val() {
  _impl_._oneof_case_[0] = kArrayVal;
}
inline void GenericValue::clear_array_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (val_case() == kArrayVal) {
    if (GetArena() == nullptr) {
      delete _impl_.val_.array_val_;
    }
    clear_has_val();
  }
}
inline ::milvus::proto::plan::Array* GenericValue::release_array_val() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.GenericValue.array_val)
  if (val_case() == kArrayVal) {
    clear_has_val();
    auto* temp = _impl_.val_.array_val_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.val_.array_val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::Array& GenericValue::_internal_array_val() const {
  return val_case() == kArrayVal ? *_impl_.val_.array_val_ : reinterpret_cast<::milvus::proto::plan::Array&>(::milvus::proto::plan::_Array_default_instance_);
}
inline const ::milvus::proto::plan::Array& GenericValue::array_val() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.GenericValue.array_val)
  return _internal_array_val();
}
inline ::milvus::proto::plan::Array* GenericValue::unsafe_arena_release_array_val() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.plan.GenericValue.array_val)
  if (val_case() == kArrayVal) {
    clear_has_val();
    auto* temp = _impl_.val_.array_val_;
    _impl_.val_.array_val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GenericValue::unsafe_arena_set_allocated_array_val(::milvus::proto::plan::Array* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_val();
  if (value) {
    set_has_array_val();
    _impl_.val_.array_val_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.GenericValue.array_val)
}
inline ::milvus::proto::plan::Array* GenericValue::_internal_mutable_array_val() {
  if (val_case() != kArrayVal) {
    clear_val();
    set_has_array_val();
    _impl_.val_.array_val_ = CreateMaybeMessage<::milvus::proto::plan::Array>(GetArena());
  }
  return _impl_.val_.array_val_;
}
inline ::milvus::proto::plan::Array* GenericValue::mutable_array_val() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::Array* _msg = _internal_mutable_array_val();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.GenericValue.array_val)
  return _msg;
}

inline bool GenericValue::has_val() const {
  return val_case() != VAL_NOT_SET;
}
inline void GenericValue::clear_has_val() {
  _impl_._oneof_case_[0] = VAL_NOT_SET;
}
inline GenericValue::ValCase GenericValue::val_case() const {
  return GenericValue::ValCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Array

// repeated .milvus.proto.plan.GenericValue array = 1;
inline int Array::_internal_array_size() const {
  return _internal_array().size();
}
inline int Array::array_size() const {
  return _internal_array_size();
}
inline void Array::clear_array() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.array_.Clear();
}
inline ::milvus::proto::plan::GenericValue* Array::mutable_array(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Array.array)
  return _internal_mutable_array()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>* Array::mutable_array()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.plan.Array.array)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_array();
}
inline const ::milvus::proto::plan::GenericValue& Array::array(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Array.array)
  return _internal_array().Get(index);
}
inline ::milvus::proto::plan::GenericValue* Array::add_array() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::milvus::proto::plan::GenericValue* _add = _internal_mutable_array()->Add();
  // @@protoc_insertion_point(field_add:milvus.proto.plan.Array.array)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>& Array::array() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.plan.Array.array)
  return _internal_array();
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>&
Array::_internal_array() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.array_;
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>*
Array::_internal_mutable_array() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.array_;
}

// bool same_type = 2;
inline void Array::clear_same_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.same_type_ = false;
}
inline bool Array::same_type() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Array.same_type)
  return _internal_same_type();
}
inline void Array::set_same_type(bool value) {
  _internal_set_same_type(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.Array.same_type)
}
inline bool Array::_internal_same_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.same_type_;
}
inline void Array::_internal_set_same_type(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.same_type_ = value;
}

// .milvus.proto.schema.DataType element_type = 3;
inline void Array::clear_element_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.element_type_ = 0;
}
inline ::milvus::proto::schema::DataType Array::element_type() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Array.element_type)
  return _internal_element_type();
}
inline void Array::set_element_type(::milvus::proto::schema::DataType value) {
  _internal_set_element_type(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.Array.element_type)
}
inline ::milvus::proto::schema::DataType Array::_internal_element_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::schema::DataType>(_impl_.element_type_);
}
inline void Array::_internal_set_element_type(::milvus::proto::schema::DataType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.element_type_ = value;
}

// -------------------------------------------------------------------

// QueryInfo

// int64 topk = 1;
inline void QueryInfo::clear_topk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topk_ = ::int64_t{0};
}
inline ::int64_t QueryInfo::topk() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.QueryInfo.topk)
  return _internal_topk();
}
inline void QueryInfo::set_topk(::int64_t value) {
  _internal_set_topk(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.QueryInfo.topk)
}
inline ::int64_t QueryInfo::_internal_topk() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topk_;
}
inline void QueryInfo::_internal_set_topk(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.topk_ = value;
}

// string metric_type = 3;
inline void QueryInfo::clear_metric_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metric_type_.ClearToEmpty();
}
inline const std::string& QueryInfo::metric_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.QueryInfo.metric_type)
  return _internal_metric_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryInfo::set_metric_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.metric_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:milvus.proto.plan.QueryInfo.metric_type)
}
inline std::string* QueryInfo::mutable_metric_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_metric_type();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.QueryInfo.metric_type)
  return _s;
}
inline const std::string& QueryInfo::_internal_metric_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metric_type_.Get();
}
inline void QueryInfo::_internal_set_metric_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.metric_type_.Set(value, GetArena());
}
inline std::string* QueryInfo::_internal_mutable_metric_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.metric_type_.Mutable( GetArena());
}
inline std::string* QueryInfo::release_metric_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.QueryInfo.metric_type)
  return _impl_.metric_type_.Release();
}
inline void QueryInfo::set_allocated_metric_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metric_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.metric_type_.IsDefault()) {
          _impl_.metric_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.QueryInfo.metric_type)
}

// string search_params = 4;
inline void QueryInfo::clear_search_params() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.search_params_.ClearToEmpty();
}
inline const std::string& QueryInfo::search_params() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.QueryInfo.search_params)
  return _internal_search_params();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryInfo::set_search_params(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.search_params_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:milvus.proto.plan.QueryInfo.search_params)
}
inline std::string* QueryInfo::mutable_search_params() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_search_params();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.QueryInfo.search_params)
  return _s;
}
inline const std::string& QueryInfo::_internal_search_params() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.search_params_.Get();
}
inline void QueryInfo::_internal_set_search_params(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.search_params_.Set(value, GetArena());
}
inline std::string* QueryInfo::_internal_mutable_search_params() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.search_params_.Mutable( GetArena());
}
inline std::string* QueryInfo::release_search_params() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.QueryInfo.search_params)
  return _impl_.search_params_.Release();
}
inline void QueryInfo::set_allocated_search_params(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.search_params_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.search_params_.IsDefault()) {
          _impl_.search_params_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.QueryInfo.search_params)
}

// int64 round_decimal = 5;
inline void QueryInfo::clear_round_decimal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.round_decimal_ = ::int64_t{0};
}
inline ::int64_t QueryInfo::round_decimal() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.QueryInfo.round_decimal)
  return _internal_round_decimal();
}
inline void QueryInfo::set_round_decimal(::int64_t value) {
  _internal_set_round_decimal(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.QueryInfo.round_decimal)
}
inline ::int64_t QueryInfo::_internal_round_decimal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.round_decimal_;
}
inline void QueryInfo::_internal_set_round_decimal(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.round_decimal_ = value;
}

// -------------------------------------------------------------------

// ColumnInfo

// int64 field_id = 1;
inline void ColumnInfo::clear_field_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.field_id_ = ::int64_t{0};
}
inline ::int64_t ColumnInfo::field_id() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ColumnInfo.field_id)
  return _internal_field_id();
}
inline void ColumnInfo::set_field_id(::int64_t value) {
  _internal_set_field_id(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.ColumnInfo.field_id)
}
inline ::int64_t ColumnInfo::_internal_field_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.field_id_;
}
inline void ColumnInfo::_internal_set_field_id(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.field_id_ = value;
}

// .milvus.proto.schema.DataType data_type = 2;
inline void ColumnInfo::clear_data_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_type_ = 0;
}
inline ::milvus::proto::schema::DataType ColumnInfo::data_type() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ColumnInfo.data_type)
  return _internal_data_type();
}
inline void ColumnInfo::set_data_type(::milvus::proto::schema::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.ColumnInfo.data_type)
}
inline ::milvus::proto::schema::DataType ColumnInfo::_internal_data_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::schema::DataType>(_impl_.data_type_);
}
inline void ColumnInfo::_internal_set_data_type(::milvus::proto::schema::DataType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_type_ = value;
}

// bool is_primary_key = 3;
inline void ColumnInfo::clear_is_primary_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_primary_key_ = false;
}
inline bool ColumnInfo::is_primary_key() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ColumnInfo.is_primary_key)
  return _internal_is_primary_key();
}
inline void ColumnInfo::set_is_primary_key(bool value) {
  _internal_set_is_primary_key(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.ColumnInfo.is_primary_key)
}
inline bool ColumnInfo::_internal_is_primary_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_primary_key_;
}
inline void ColumnInfo::_internal_set_is_primary_key(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_primary_key_ = value;
}

// bool is_autoID = 4;
inline void ColumnInfo::clear_is_autoid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_autoid_ = false;
}
inline bool ColumnInfo::is_autoid() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ColumnInfo.is_autoID)
  return _internal_is_autoid();
}
inline void ColumnInfo::set_is_autoid(bool value) {
  _internal_set_is_autoid(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.ColumnInfo.is_autoID)
}
inline bool ColumnInfo::_internal_is_autoid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_autoid_;
}
inline void ColumnInfo::_internal_set_is_autoid(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_autoid_ = value;
}

// repeated string nested_path = 5;
inline int ColumnInfo::_internal_nested_path_size() const {
  return _internal_nested_path().size();
}
inline int ColumnInfo::nested_path_size() const {
  return _internal_nested_path_size();
}
inline void ColumnInfo::clear_nested_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nested_path_.Clear();
}
inline std::string* ColumnInfo::add_nested_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_nested_path()->Add();
  // @@protoc_insertion_point(field_add_mutable:milvus.proto.plan.ColumnInfo.nested_path)
  return _s;
}
inline const std::string& ColumnInfo::nested_path(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ColumnInfo.nested_path)
  return _internal_nested_path().Get(index);
}
inline std::string* ColumnInfo::mutable_nested_path(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.ColumnInfo.nested_path)
  return _internal_mutable_nested_path()->Mutable(index);
}
inline void ColumnInfo::set_nested_path(int index, const std::string& value) {
  _internal_mutable_nested_path()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.ColumnInfo.nested_path)
}
inline void ColumnInfo::set_nested_path(int index, std::string&& value) {
  _internal_mutable_nested_path()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:milvus.proto.plan.ColumnInfo.nested_path)
}
inline void ColumnInfo::set_nested_path(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_nested_path()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:milvus.proto.plan.ColumnInfo.nested_path)
}
inline void ColumnInfo::set_nested_path(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_nested_path()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:milvus.proto.plan.ColumnInfo.nested_path)
}
inline void ColumnInfo::set_nested_path(int index, absl::string_view value) {
  _internal_mutable_nested_path()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:milvus.proto.plan.ColumnInfo.nested_path)
}
inline void ColumnInfo::add_nested_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_nested_path()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:milvus.proto.plan.ColumnInfo.nested_path)
}
inline void ColumnInfo::add_nested_path(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_nested_path()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:milvus.proto.plan.ColumnInfo.nested_path)
}
inline void ColumnInfo::add_nested_path(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_nested_path()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:milvus.proto.plan.ColumnInfo.nested_path)
}
inline void ColumnInfo::add_nested_path(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_nested_path()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:milvus.proto.plan.ColumnInfo.nested_path)
}
inline void ColumnInfo::add_nested_path(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_nested_path()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:milvus.proto.plan.ColumnInfo.nested_path)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ColumnInfo::nested_path() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.plan.ColumnInfo.nested_path)
  return _internal_nested_path();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ColumnInfo::mutable_nested_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.plan.ColumnInfo.nested_path)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_nested_path();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ColumnInfo::_internal_nested_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nested_path_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ColumnInfo::_internal_mutable_nested_path() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.nested_path_;
}

// bool is_partition_key = 6;
inline void ColumnInfo::clear_is_partition_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_partition_key_ = false;
}
inline bool ColumnInfo::is_partition_key() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ColumnInfo.is_partition_key)
  return _internal_is_partition_key();
}
inline void ColumnInfo::set_is_partition_key(bool value) {
  _internal_set_is_partition_key(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.ColumnInfo.is_partition_key)
}
inline bool ColumnInfo::_internal_is_partition_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_partition_key_;
}
inline void ColumnInfo::_internal_set_is_partition_key(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_partition_key_ = value;
}

// .milvus.proto.schema.DataType element_type = 7;
inline void ColumnInfo::clear_element_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.element_type_ = 0;
}
inline ::milvus::proto::schema::DataType ColumnInfo::element_type() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ColumnInfo.element_type)
  return _internal_element_type();
}
inline void ColumnInfo::set_element_type(::milvus::proto::schema::DataType value) {
  _internal_set_element_type(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.ColumnInfo.element_type)
}
inline ::milvus::proto::schema::DataType ColumnInfo::_internal_element_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::schema::DataType>(_impl_.element_type_);
}
inline void ColumnInfo::_internal_set_element_type(::milvus::proto::schema::DataType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.element_type_ = value;
}

// -------------------------------------------------------------------

// ColumnExpr

// .milvus.proto.plan.ColumnInfo info = 1;
inline bool ColumnExpr::has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline void ColumnExpr::clear_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::plan::ColumnInfo& ColumnExpr::_internal_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::ColumnInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::ColumnInfo&>(::milvus::proto::plan::_ColumnInfo_default_instance_);
}
inline const ::milvus::proto::plan::ColumnInfo& ColumnExpr::info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ColumnExpr.info)
  return _internal_info();
}
inline void ColumnExpr::unsafe_arena_set_allocated_info(::milvus::proto::plan::ColumnInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.ColumnExpr.info)
}
inline ::milvus::proto::plan::ColumnInfo* ColumnExpr::release_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* released = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::ColumnInfo* ColumnExpr::unsafe_arena_release_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.ColumnExpr.info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::ColumnInfo* ColumnExpr::_internal_mutable_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(GetArena());
    _impl_.info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(p);
  }
  return _impl_.info_;
}
inline ::milvus::proto::plan::ColumnInfo* ColumnExpr::mutable_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::ColumnInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.ColumnExpr.info)
  return _msg;
}
inline void ColumnExpr::set_allocated_info(::milvus::proto::plan::ColumnInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(_impl_.info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.ColumnExpr.info)
}

// -------------------------------------------------------------------

// ExistsExpr

// .milvus.proto.plan.ColumnInfo info = 1;
inline bool ExistsExpr::has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline void ExistsExpr::clear_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::plan::ColumnInfo& ExistsExpr::_internal_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::ColumnInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::ColumnInfo&>(::milvus::proto::plan::_ColumnInfo_default_instance_);
}
inline const ::milvus::proto::plan::ColumnInfo& ExistsExpr::info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ExistsExpr.info)
  return _internal_info();
}
inline void ExistsExpr::unsafe_arena_set_allocated_info(::milvus::proto::plan::ColumnInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.ExistsExpr.info)
}
inline ::milvus::proto::plan::ColumnInfo* ExistsExpr::release_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* released = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::ColumnInfo* ExistsExpr::unsafe_arena_release_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.ExistsExpr.info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::ColumnInfo* ExistsExpr::_internal_mutable_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(GetArena());
    _impl_.info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(p);
  }
  return _impl_.info_;
}
inline ::milvus::proto::plan::ColumnInfo* ExistsExpr::mutable_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::ColumnInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.ExistsExpr.info)
  return _msg;
}
inline void ExistsExpr::set_allocated_info(::milvus::proto::plan::ColumnInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(_impl_.info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.ExistsExpr.info)
}

// -------------------------------------------------------------------

// ValueExpr

// .milvus.proto.plan.GenericValue value = 1;
inline bool ValueExpr::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline void ValueExpr::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::plan::GenericValue& ValueExpr::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::GenericValue* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::GenericValue&>(::milvus::proto::plan::_GenericValue_default_instance_);
}
inline const ::milvus::proto::plan::GenericValue& ValueExpr::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ValueExpr.value)
  return _internal_value();
}
inline void ValueExpr::unsafe_arena_set_allocated_value(::milvus::proto::plan::GenericValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.ValueExpr.value)
}
inline ::milvus::proto::plan::GenericValue* ValueExpr::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::GenericValue* released = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::GenericValue* ValueExpr::unsafe_arena_release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.ValueExpr.value)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::GenericValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::GenericValue* ValueExpr::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::GenericValue>(GetArena());
    _impl_.value_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(p);
  }
  return _impl_.value_;
}
inline ::milvus::proto::plan::GenericValue* ValueExpr::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::GenericValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.ValueExpr.value)
  return _msg;
}
inline void ValueExpr::set_allocated_value(::milvus::proto::plan::GenericValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::GenericValue*>(_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.value_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.ValueExpr.value)
}

// -------------------------------------------------------------------

// UnaryRangeExpr

// .milvus.proto.plan.ColumnInfo column_info = 1;
inline bool UnaryRangeExpr::has_column_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.column_info_ != nullptr);
  return value;
}
inline void UnaryRangeExpr::clear_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.column_info_ != nullptr) _impl_.column_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::plan::ColumnInfo& UnaryRangeExpr::_internal_column_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::ColumnInfo* p = _impl_.column_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::ColumnInfo&>(::milvus::proto::plan::_ColumnInfo_default_instance_);
}
inline const ::milvus::proto::plan::ColumnInfo& UnaryRangeExpr::column_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.UnaryRangeExpr.column_info)
  return _internal_column_info();
}
inline void UnaryRangeExpr::unsafe_arena_set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.column_info_);
  }
  _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.UnaryRangeExpr.column_info)
}
inline ::milvus::proto::plan::ColumnInfo* UnaryRangeExpr::release_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* released = _impl_.column_info_;
  _impl_.column_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::ColumnInfo* UnaryRangeExpr::unsafe_arena_release_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.UnaryRangeExpr.column_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* temp = _impl_.column_info_;
  _impl_.column_info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::ColumnInfo* UnaryRangeExpr::_internal_mutable_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.column_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(GetArena());
    _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(p);
  }
  return _impl_.column_info_;
}
inline ::milvus::proto::plan::ColumnInfo* UnaryRangeExpr::mutable_column_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::ColumnInfo* _msg = _internal_mutable_column_info();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.UnaryRangeExpr.column_info)
  return _msg;
}
inline void UnaryRangeExpr::set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(_impl_.column_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.UnaryRangeExpr.column_info)
}

// .milvus.proto.plan.OpType op = 2;
inline void UnaryRangeExpr::clear_op() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.op_ = 0;
}
inline ::milvus::proto::plan::OpType UnaryRangeExpr::op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.UnaryRangeExpr.op)
  return _internal_op();
}
inline void UnaryRangeExpr::set_op(::milvus::proto::plan::OpType value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.UnaryRangeExpr.op)
}
inline ::milvus::proto::plan::OpType UnaryRangeExpr::_internal_op() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::plan::OpType>(_impl_.op_);
}
inline void UnaryRangeExpr::_internal_set_op(::milvus::proto::plan::OpType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.op_ = value;
}

// .milvus.proto.plan.GenericValue value = 3;
inline bool UnaryRangeExpr::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline void UnaryRangeExpr::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::milvus::proto::plan::GenericValue& UnaryRangeExpr::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::GenericValue* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::GenericValue&>(::milvus::proto::plan::_GenericValue_default_instance_);
}
inline const ::milvus::proto::plan::GenericValue& UnaryRangeExpr::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.UnaryRangeExpr.value)
  return _internal_value();
}
inline void UnaryRangeExpr::unsafe_arena_set_allocated_value(::milvus::proto::plan::GenericValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.UnaryRangeExpr.value)
}
inline ::milvus::proto::plan::GenericValue* UnaryRangeExpr::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::plan::GenericValue* released = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::GenericValue* UnaryRangeExpr::unsafe_arena_release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.UnaryRangeExpr.value)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::plan::GenericValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::GenericValue* UnaryRangeExpr::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::GenericValue>(GetArena());
    _impl_.value_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(p);
  }
  return _impl_.value_;
}
inline ::milvus::proto::plan::GenericValue* UnaryRangeExpr::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::GenericValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.UnaryRangeExpr.value)
  return _msg;
}
inline void UnaryRangeExpr::set_allocated_value(::milvus::proto::plan::GenericValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::GenericValue*>(_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.value_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.UnaryRangeExpr.value)
}

// -------------------------------------------------------------------

// BinaryRangeExpr

// .milvus.proto.plan.ColumnInfo column_info = 1;
inline bool BinaryRangeExpr::has_column_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.column_info_ != nullptr);
  return value;
}
inline void BinaryRangeExpr::clear_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.column_info_ != nullptr) _impl_.column_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::plan::ColumnInfo& BinaryRangeExpr::_internal_column_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::ColumnInfo* p = _impl_.column_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::ColumnInfo&>(::milvus::proto::plan::_ColumnInfo_default_instance_);
}
inline const ::milvus::proto::plan::ColumnInfo& BinaryRangeExpr::column_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryRangeExpr.column_info)
  return _internal_column_info();
}
inline void BinaryRangeExpr::unsafe_arena_set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.column_info_);
  }
  _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.BinaryRangeExpr.column_info)
}
inline ::milvus::proto::plan::ColumnInfo* BinaryRangeExpr::release_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* released = _impl_.column_info_;
  _impl_.column_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::ColumnInfo* BinaryRangeExpr::unsafe_arena_release_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryRangeExpr.column_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* temp = _impl_.column_info_;
  _impl_.column_info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::ColumnInfo* BinaryRangeExpr::_internal_mutable_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.column_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(GetArena());
    _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(p);
  }
  return _impl_.column_info_;
}
inline ::milvus::proto::plan::ColumnInfo* BinaryRangeExpr::mutable_column_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::ColumnInfo* _msg = _internal_mutable_column_info();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryRangeExpr.column_info)
  return _msg;
}
inline void BinaryRangeExpr::set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(_impl_.column_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryRangeExpr.column_info)
}

// bool lower_inclusive = 2;
inline void BinaryRangeExpr::clear_lower_inclusive() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lower_inclusive_ = false;
}
inline bool BinaryRangeExpr::lower_inclusive() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryRangeExpr.lower_inclusive)
  return _internal_lower_inclusive();
}
inline void BinaryRangeExpr::set_lower_inclusive(bool value) {
  _internal_set_lower_inclusive(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.BinaryRangeExpr.lower_inclusive)
}
inline bool BinaryRangeExpr::_internal_lower_inclusive() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lower_inclusive_;
}
inline void BinaryRangeExpr::_internal_set_lower_inclusive(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.lower_inclusive_ = value;
}

// bool upper_inclusive = 3;
inline void BinaryRangeExpr::clear_upper_inclusive() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.upper_inclusive_ = false;
}
inline bool BinaryRangeExpr::upper_inclusive() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryRangeExpr.upper_inclusive)
  return _internal_upper_inclusive();
}
inline void BinaryRangeExpr::set_upper_inclusive(bool value) {
  _internal_set_upper_inclusive(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.BinaryRangeExpr.upper_inclusive)
}
inline bool BinaryRangeExpr::_internal_upper_inclusive() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.upper_inclusive_;
}
inline void BinaryRangeExpr::_internal_set_upper_inclusive(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.upper_inclusive_ = value;
}

// .milvus.proto.plan.GenericValue lower_value = 4;
inline bool BinaryRangeExpr::has_lower_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lower_value_ != nullptr);
  return value;
}
inline void BinaryRangeExpr::clear_lower_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.lower_value_ != nullptr) _impl_.lower_value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::milvus::proto::plan::GenericValue& BinaryRangeExpr::_internal_lower_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::GenericValue* p = _impl_.lower_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::GenericValue&>(::milvus::proto::plan::_GenericValue_default_instance_);
}
inline const ::milvus::proto::plan::GenericValue& BinaryRangeExpr::lower_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryRangeExpr.lower_value)
  return _internal_lower_value();
}
inline void BinaryRangeExpr::unsafe_arena_set_allocated_lower_value(::milvus::proto::plan::GenericValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lower_value_);
  }
  _impl_.lower_value_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.BinaryRangeExpr.lower_value)
}
inline ::milvus::proto::plan::GenericValue* BinaryRangeExpr::release_lower_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::plan::GenericValue* released = _impl_.lower_value_;
  _impl_.lower_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::GenericValue* BinaryRangeExpr::unsafe_arena_release_lower_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryRangeExpr.lower_value)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::plan::GenericValue* temp = _impl_.lower_value_;
  _impl_.lower_value_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::GenericValue* BinaryRangeExpr::_internal_mutable_lower_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.lower_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::GenericValue>(GetArena());
    _impl_.lower_value_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(p);
  }
  return _impl_.lower_value_;
}
inline ::milvus::proto::plan::GenericValue* BinaryRangeExpr::mutable_lower_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::GenericValue* _msg = _internal_mutable_lower_value();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryRangeExpr.lower_value)
  return _msg;
}
inline void BinaryRangeExpr::set_allocated_lower_value(::milvus::proto::plan::GenericValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::GenericValue*>(_impl_.lower_value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lower_value_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryRangeExpr.lower_value)
}

// .milvus.proto.plan.GenericValue upper_value = 5;
inline bool BinaryRangeExpr::has_upper_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.upper_value_ != nullptr);
  return value;
}
inline void BinaryRangeExpr::clear_upper_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.upper_value_ != nullptr) _impl_.upper_value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::milvus::proto::plan::GenericValue& BinaryRangeExpr::_internal_upper_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::GenericValue* p = _impl_.upper_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::GenericValue&>(::milvus::proto::plan::_GenericValue_default_instance_);
}
inline const ::milvus::proto::plan::GenericValue& BinaryRangeExpr::upper_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryRangeExpr.upper_value)
  return _internal_upper_value();
}
inline void BinaryRangeExpr::unsafe_arena_set_allocated_upper_value(::milvus::proto::plan::GenericValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.upper_value_);
  }
  _impl_.upper_value_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.BinaryRangeExpr.upper_value)
}
inline ::milvus::proto::plan::GenericValue* BinaryRangeExpr::release_upper_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::milvus::proto::plan::GenericValue* released = _impl_.upper_value_;
  _impl_.upper_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::GenericValue* BinaryRangeExpr::unsafe_arena_release_upper_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryRangeExpr.upper_value)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::milvus::proto::plan::GenericValue* temp = _impl_.upper_value_;
  _impl_.upper_value_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::GenericValue* BinaryRangeExpr::_internal_mutable_upper_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.upper_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::GenericValue>(GetArena());
    _impl_.upper_value_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(p);
  }
  return _impl_.upper_value_;
}
inline ::milvus::proto::plan::GenericValue* BinaryRangeExpr::mutable_upper_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::GenericValue* _msg = _internal_mutable_upper_value();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryRangeExpr.upper_value)
  return _msg;
}
inline void BinaryRangeExpr::set_allocated_upper_value(::milvus::proto::plan::GenericValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::GenericValue*>(_impl_.upper_value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.upper_value_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryRangeExpr.upper_value)
}

// -------------------------------------------------------------------

// CompareExpr

// .milvus.proto.plan.ColumnInfo left_column_info = 1;
inline bool CompareExpr::has_left_column_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_column_info_ != nullptr);
  return value;
}
inline void CompareExpr::clear_left_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.left_column_info_ != nullptr) _impl_.left_column_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::plan::ColumnInfo& CompareExpr::_internal_left_column_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::ColumnInfo* p = _impl_.left_column_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::ColumnInfo&>(::milvus::proto::plan::_ColumnInfo_default_instance_);
}
inline const ::milvus::proto::plan::ColumnInfo& CompareExpr::left_column_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.CompareExpr.left_column_info)
  return _internal_left_column_info();
}
inline void CompareExpr::unsafe_arena_set_allocated_left_column_info(::milvus::proto::plan::ColumnInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_column_info_);
  }
  _impl_.left_column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.CompareExpr.left_column_info)
}
inline ::milvus::proto::plan::ColumnInfo* CompareExpr::release_left_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* released = _impl_.left_column_info_;
  _impl_.left_column_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::ColumnInfo* CompareExpr::unsafe_arena_release_left_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.CompareExpr.left_column_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* temp = _impl_.left_column_info_;
  _impl_.left_column_info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::ColumnInfo* CompareExpr::_internal_mutable_left_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.left_column_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(GetArena());
    _impl_.left_column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(p);
  }
  return _impl_.left_column_info_;
}
inline ::milvus::proto::plan::ColumnInfo* CompareExpr::mutable_left_column_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::ColumnInfo* _msg = _internal_mutable_left_column_info();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.CompareExpr.left_column_info)
  return _msg;
}
inline void CompareExpr::set_allocated_left_column_info(::milvus::proto::plan::ColumnInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(_impl_.left_column_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.left_column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.CompareExpr.left_column_info)
}

// .milvus.proto.plan.ColumnInfo right_column_info = 2;
inline bool CompareExpr::has_right_column_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_column_info_ != nullptr);
  return value;
}
inline void CompareExpr::clear_right_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.right_column_info_ != nullptr) _impl_.right_column_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::milvus::proto::plan::ColumnInfo& CompareExpr::_internal_right_column_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::ColumnInfo* p = _impl_.right_column_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::ColumnInfo&>(::milvus::proto::plan::_ColumnInfo_default_instance_);
}
inline const ::milvus::proto::plan::ColumnInfo& CompareExpr::right_column_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.CompareExpr.right_column_info)
  return _internal_right_column_info();
}
inline void CompareExpr::unsafe_arena_set_allocated_right_column_info(::milvus::proto::plan::ColumnInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_column_info_);
  }
  _impl_.right_column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.CompareExpr.right_column_info)
}
inline ::milvus::proto::plan::ColumnInfo* CompareExpr::release_right_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::plan::ColumnInfo* released = _impl_.right_column_info_;
  _impl_.right_column_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::ColumnInfo* CompareExpr::unsafe_arena_release_right_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.CompareExpr.right_column_info)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::plan::ColumnInfo* temp = _impl_.right_column_info_;
  _impl_.right_column_info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::ColumnInfo* CompareExpr::_internal_mutable_right_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.right_column_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(GetArena());
    _impl_.right_column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(p);
  }
  return _impl_.right_column_info_;
}
inline ::milvus::proto::plan::ColumnInfo* CompareExpr::mutable_right_column_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::ColumnInfo* _msg = _internal_mutable_right_column_info();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.CompareExpr.right_column_info)
  return _msg;
}
inline void CompareExpr::set_allocated_right_column_info(::milvus::proto::plan::ColumnInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(_impl_.right_column_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.right_column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.CompareExpr.right_column_info)
}

// .milvus.proto.plan.OpType op = 3;
inline void CompareExpr::clear_op() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.op_ = 0;
}
inline ::milvus::proto::plan::OpType CompareExpr::op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.CompareExpr.op)
  return _internal_op();
}
inline void CompareExpr::set_op(::milvus::proto::plan::OpType value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.CompareExpr.op)
}
inline ::milvus::proto::plan::OpType CompareExpr::_internal_op() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::plan::OpType>(_impl_.op_);
}
inline void CompareExpr::_internal_set_op(::milvus::proto::plan::OpType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.op_ = value;
}

// -------------------------------------------------------------------

// TermExpr

// .milvus.proto.plan.ColumnInfo column_info = 1;
inline bool TermExpr::has_column_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.column_info_ != nullptr);
  return value;
}
inline void TermExpr::clear_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.column_info_ != nullptr) _impl_.column_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::plan::ColumnInfo& TermExpr::_internal_column_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::ColumnInfo* p = _impl_.column_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::ColumnInfo&>(::milvus::proto::plan::_ColumnInfo_default_instance_);
}
inline const ::milvus::proto::plan::ColumnInfo& TermExpr::column_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.TermExpr.column_info)
  return _internal_column_info();
}
inline void TermExpr::unsafe_arena_set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.column_info_);
  }
  _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.TermExpr.column_info)
}
inline ::milvus::proto::plan::ColumnInfo* TermExpr::release_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* released = _impl_.column_info_;
  _impl_.column_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::ColumnInfo* TermExpr::unsafe_arena_release_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.TermExpr.column_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* temp = _impl_.column_info_;
  _impl_.column_info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::ColumnInfo* TermExpr::_internal_mutable_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.column_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(GetArena());
    _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(p);
  }
  return _impl_.column_info_;
}
inline ::milvus::proto::plan::ColumnInfo* TermExpr::mutable_column_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::ColumnInfo* _msg = _internal_mutable_column_info();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.TermExpr.column_info)
  return _msg;
}
inline void TermExpr::set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(_impl_.column_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.TermExpr.column_info)
}

// repeated .milvus.proto.plan.GenericValue values = 2;
inline int TermExpr::_internal_values_size() const {
  return _internal_values().size();
}
inline int TermExpr::values_size() const {
  return _internal_values_size();
}
inline void TermExpr::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline ::milvus::proto::plan::GenericValue* TermExpr::mutable_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.TermExpr.values)
  return _internal_mutable_values()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>* TermExpr::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.plan.TermExpr.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::milvus::proto::plan::GenericValue& TermExpr::values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.TermExpr.values)
  return _internal_values().Get(index);
}
inline ::milvus::proto::plan::GenericValue* TermExpr::add_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::milvus::proto::plan::GenericValue* _add = _internal_mutable_values()->Add();
  // @@protoc_insertion_point(field_add:milvus.proto.plan.TermExpr.values)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>& TermExpr::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.plan.TermExpr.values)
  return _internal_values();
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>&
TermExpr::_internal_values() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>*
TermExpr::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// bool is_in_field = 3;
inline void TermExpr::clear_is_in_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_in_field_ = false;
}
inline bool TermExpr::is_in_field() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.TermExpr.is_in_field)
  return _internal_is_in_field();
}
inline void TermExpr::set_is_in_field(bool value) {
  _internal_set_is_in_field(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.TermExpr.is_in_field)
}
inline bool TermExpr::_internal_is_in_field() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_in_field_;
}
inline void TermExpr::_internal_set_is_in_field(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_in_field_ = value;
}

// -------------------------------------------------------------------

// JSONContainsExpr

// .milvus.proto.plan.ColumnInfo column_info = 1;
inline bool JSONContainsExpr::has_column_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.column_info_ != nullptr);
  return value;
}
inline void JSONContainsExpr::clear_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.column_info_ != nullptr) _impl_.column_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::plan::ColumnInfo& JSONContainsExpr::_internal_column_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::ColumnInfo* p = _impl_.column_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::ColumnInfo&>(::milvus::proto::plan::_ColumnInfo_default_instance_);
}
inline const ::milvus::proto::plan::ColumnInfo& JSONContainsExpr::column_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.JSONContainsExpr.column_info)
  return _internal_column_info();
}
inline void JSONContainsExpr::unsafe_arena_set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.column_info_);
  }
  _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.JSONContainsExpr.column_info)
}
inline ::milvus::proto::plan::ColumnInfo* JSONContainsExpr::release_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* released = _impl_.column_info_;
  _impl_.column_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::ColumnInfo* JSONContainsExpr::unsafe_arena_release_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.JSONContainsExpr.column_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* temp = _impl_.column_info_;
  _impl_.column_info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::ColumnInfo* JSONContainsExpr::_internal_mutable_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.column_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(GetArena());
    _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(p);
  }
  return _impl_.column_info_;
}
inline ::milvus::proto::plan::ColumnInfo* JSONContainsExpr::mutable_column_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::ColumnInfo* _msg = _internal_mutable_column_info();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.JSONContainsExpr.column_info)
  return _msg;
}
inline void JSONContainsExpr::set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(_impl_.column_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.JSONContainsExpr.column_info)
}

// repeated .milvus.proto.plan.GenericValue elements = 2;
inline int JSONContainsExpr::_internal_elements_size() const {
  return _internal_elements().size();
}
inline int JSONContainsExpr::elements_size() const {
  return _internal_elements_size();
}
inline void JSONContainsExpr::clear_elements() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.elements_.Clear();
}
inline ::milvus::proto::plan::GenericValue* JSONContainsExpr::mutable_elements(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.JSONContainsExpr.elements)
  return _internal_mutable_elements()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>* JSONContainsExpr::mutable_elements()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.plan.JSONContainsExpr.elements)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_elements();
}
inline const ::milvus::proto::plan::GenericValue& JSONContainsExpr::elements(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.JSONContainsExpr.elements)
  return _internal_elements().Get(index);
}
inline ::milvus::proto::plan::GenericValue* JSONContainsExpr::add_elements() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::milvus::proto::plan::GenericValue* _add = _internal_mutable_elements()->Add();
  // @@protoc_insertion_point(field_add:milvus.proto.plan.JSONContainsExpr.elements)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>& JSONContainsExpr::elements() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.plan.JSONContainsExpr.elements)
  return _internal_elements();
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>&
JSONContainsExpr::_internal_elements() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.elements_;
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::plan::GenericValue>*
JSONContainsExpr::_internal_mutable_elements() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.elements_;
}

// .milvus.proto.plan.JSONContainsExpr.JSONOp op = 3;
inline void JSONContainsExpr::clear_op() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.op_ = 0;
}
inline ::milvus::proto::plan::JSONContainsExpr_JSONOp JSONContainsExpr::op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.JSONContainsExpr.op)
  return _internal_op();
}
inline void JSONContainsExpr::set_op(::milvus::proto::plan::JSONContainsExpr_JSONOp value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.JSONContainsExpr.op)
}
inline ::milvus::proto::plan::JSONContainsExpr_JSONOp JSONContainsExpr::_internal_op() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::plan::JSONContainsExpr_JSONOp>(_impl_.op_);
}
inline void JSONContainsExpr::_internal_set_op(::milvus::proto::plan::JSONContainsExpr_JSONOp value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.op_ = value;
}

// bool elements_same_type = 4;
inline void JSONContainsExpr::clear_elements_same_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.elements_same_type_ = false;
}
inline bool JSONContainsExpr::elements_same_type() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.JSONContainsExpr.elements_same_type)
  return _internal_elements_same_type();
}
inline void JSONContainsExpr::set_elements_same_type(bool value) {
  _internal_set_elements_same_type(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.JSONContainsExpr.elements_same_type)
}
inline bool JSONContainsExpr::_internal_elements_same_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.elements_same_type_;
}
inline void JSONContainsExpr::_internal_set_elements_same_type(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.elements_same_type_ = value;
}

// -------------------------------------------------------------------

// UnaryExpr

// .milvus.proto.plan.UnaryExpr.UnaryOp op = 1;
inline void UnaryExpr::clear_op() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.op_ = 0;
}
inline ::milvus::proto::plan::UnaryExpr_UnaryOp UnaryExpr::op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.UnaryExpr.op)
  return _internal_op();
}
inline void UnaryExpr::set_op(::milvus::proto::plan::UnaryExpr_UnaryOp value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.UnaryExpr.op)
}
inline ::milvus::proto::plan::UnaryExpr_UnaryOp UnaryExpr::_internal_op() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::plan::UnaryExpr_UnaryOp>(_impl_.op_);
}
inline void UnaryExpr::_internal_set_op(::milvus::proto::plan::UnaryExpr_UnaryOp value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.op_ = value;
}

// .milvus.proto.plan.Expr child = 2;
inline bool UnaryExpr::has_child() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.child_ != nullptr);
  return value;
}
inline void UnaryExpr::clear_child() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.child_ != nullptr) _impl_.child_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::plan::Expr& UnaryExpr::_internal_child() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::Expr* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::Expr&>(::milvus::proto::plan::_Expr_default_instance_);
}
inline const ::milvus::proto::plan::Expr& UnaryExpr::child() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.UnaryExpr.child)
  return _internal_child();
}
inline void UnaryExpr::unsafe_arena_set_allocated_child(::milvus::proto::plan::Expr* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = reinterpret_cast<::milvus::proto::plan::Expr*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.UnaryExpr.child)
}
inline ::milvus::proto::plan::Expr* UnaryExpr::release_child() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::Expr* released = _impl_.child_;
  _impl_.child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::Expr* UnaryExpr::unsafe_arena_release_child() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.UnaryExpr.child)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::Expr* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* UnaryExpr::_internal_mutable_child() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.child_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArena());
    _impl_.child_ = reinterpret_cast<::milvus::proto::plan::Expr*>(p);
  }
  return _impl_.child_;
}
inline ::milvus::proto::plan::Expr* UnaryExpr::mutable_child() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::Expr* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.UnaryExpr.child)
  return _msg;
}
inline void UnaryExpr::set_allocated_child(::milvus::proto::plan::Expr* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::Expr*>(_impl_.child_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::Expr*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.child_ = reinterpret_cast<::milvus::proto::plan::Expr*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.UnaryExpr.child)
}

// -------------------------------------------------------------------

// BinaryExpr

// .milvus.proto.plan.BinaryExpr.BinaryOp op = 1;
inline void BinaryExpr::clear_op() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.op_ = 0;
}
inline ::milvus::proto::plan::BinaryExpr_BinaryOp BinaryExpr::op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryExpr.op)
  return _internal_op();
}
inline void BinaryExpr::set_op(::milvus::proto::plan::BinaryExpr_BinaryOp value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.BinaryExpr.op)
}
inline ::milvus::proto::plan::BinaryExpr_BinaryOp BinaryExpr::_internal_op() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::plan::BinaryExpr_BinaryOp>(_impl_.op_);
}
inline void BinaryExpr::_internal_set_op(::milvus::proto::plan::BinaryExpr_BinaryOp value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.op_ = value;
}

// .milvus.proto.plan.Expr left = 2;
inline bool BinaryExpr::has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline void BinaryExpr::clear_left() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::plan::Expr& BinaryExpr::_internal_left() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::Expr* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::Expr&>(::milvus::proto::plan::_Expr_default_instance_);
}
inline const ::milvus::proto::plan::Expr& BinaryExpr::left() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryExpr.left)
  return _internal_left();
}
inline void BinaryExpr::unsafe_arena_set_allocated_left(::milvus::proto::plan::Expr* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = reinterpret_cast<::milvus::proto::plan::Expr*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.BinaryExpr.left)
}
inline ::milvus::proto::plan::Expr* BinaryExpr::release_left() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::Expr* released = _impl_.left_;
  _impl_.left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::Expr* BinaryExpr::unsafe_arena_release_left() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryExpr.left)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::Expr* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* BinaryExpr::_internal_mutable_left() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.left_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArena());
    _impl_.left_ = reinterpret_cast<::milvus::proto::plan::Expr*>(p);
  }
  return _impl_.left_;
}
inline ::milvus::proto::plan::Expr* BinaryExpr::mutable_left() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::Expr* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryExpr.left)
  return _msg;
}
inline void BinaryExpr::set_allocated_left(::milvus::proto::plan::Expr* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::Expr*>(_impl_.left_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::Expr*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.left_ = reinterpret_cast<::milvus::proto::plan::Expr*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryExpr.left)
}

// .milvus.proto.plan.Expr right = 3;
inline bool BinaryExpr::has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline void BinaryExpr::clear_right() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::milvus::proto::plan::Expr& BinaryExpr::_internal_right() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::Expr* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::Expr&>(::milvus::proto::plan::_Expr_default_instance_);
}
inline const ::milvus::proto::plan::Expr& BinaryExpr::right() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryExpr.right)
  return _internal_right();
}
inline void BinaryExpr::unsafe_arena_set_allocated_right(::milvus::proto::plan::Expr* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = reinterpret_cast<::milvus::proto::plan::Expr*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.BinaryExpr.right)
}
inline ::milvus::proto::plan::Expr* BinaryExpr::release_right() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::plan::Expr* released = _impl_.right_;
  _impl_.right_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::Expr* BinaryExpr::unsafe_arena_release_right() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryExpr.right)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::plan::Expr* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* BinaryExpr::_internal_mutable_right() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.right_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArena());
    _impl_.right_ = reinterpret_cast<::milvus::proto::plan::Expr*>(p);
  }
  return _impl_.right_;
}
inline ::milvus::proto::plan::Expr* BinaryExpr::mutable_right() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::Expr* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryExpr.right)
  return _msg;
}
inline void BinaryExpr::set_allocated_right(::milvus::proto::plan::Expr* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::Expr*>(_impl_.right_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::Expr*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.right_ = reinterpret_cast<::milvus::proto::plan::Expr*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryExpr.right)
}

// -------------------------------------------------------------------

// BinaryArithOp

// .milvus.proto.plan.ColumnInfo column_info = 1;
inline bool BinaryArithOp::has_column_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.column_info_ != nullptr);
  return value;
}
inline void BinaryArithOp::clear_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.column_info_ != nullptr) _impl_.column_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::plan::ColumnInfo& BinaryArithOp::_internal_column_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::ColumnInfo* p = _impl_.column_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::ColumnInfo&>(::milvus::proto::plan::_ColumnInfo_default_instance_);
}
inline const ::milvus::proto::plan::ColumnInfo& BinaryArithOp::column_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryArithOp.column_info)
  return _internal_column_info();
}
inline void BinaryArithOp::unsafe_arena_set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.column_info_);
  }
  _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.BinaryArithOp.column_info)
}
inline ::milvus::proto::plan::ColumnInfo* BinaryArithOp::release_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* released = _impl_.column_info_;
  _impl_.column_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::ColumnInfo* BinaryArithOp::unsafe_arena_release_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryArithOp.column_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* temp = _impl_.column_info_;
  _impl_.column_info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::ColumnInfo* BinaryArithOp::_internal_mutable_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.column_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(GetArena());
    _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(p);
  }
  return _impl_.column_info_;
}
inline ::milvus::proto::plan::ColumnInfo* BinaryArithOp::mutable_column_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::ColumnInfo* _msg = _internal_mutable_column_info();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryArithOp.column_info)
  return _msg;
}
inline void BinaryArithOp::set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(_impl_.column_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryArithOp.column_info)
}

// .milvus.proto.plan.ArithOpType arith_op = 2;
inline void BinaryArithOp::clear_arith_op() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.arith_op_ = 0;
}
inline ::milvus::proto::plan::ArithOpType BinaryArithOp::arith_op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryArithOp.arith_op)
  return _internal_arith_op();
}
inline void BinaryArithOp::set_arith_op(::milvus::proto::plan::ArithOpType value) {
  _internal_set_arith_op(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.BinaryArithOp.arith_op)
}
inline ::milvus::proto::plan::ArithOpType BinaryArithOp::_internal_arith_op() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::plan::ArithOpType>(_impl_.arith_op_);
}
inline void BinaryArithOp::_internal_set_arith_op(::milvus::proto::plan::ArithOpType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.arith_op_ = value;
}

// .milvus.proto.plan.GenericValue right_operand = 3;
inline bool BinaryArithOp::has_right_operand() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_operand_ != nullptr);
  return value;
}
inline void BinaryArithOp::clear_right_operand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.right_operand_ != nullptr) _impl_.right_operand_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::milvus::proto::plan::GenericValue& BinaryArithOp::_internal_right_operand() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::GenericValue* p = _impl_.right_operand_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::GenericValue&>(::milvus::proto::plan::_GenericValue_default_instance_);
}
inline const ::milvus::proto::plan::GenericValue& BinaryArithOp::right_operand() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryArithOp.right_operand)
  return _internal_right_operand();
}
inline void BinaryArithOp::unsafe_arena_set_allocated_right_operand(::milvus::proto::plan::GenericValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_operand_);
  }
  _impl_.right_operand_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.BinaryArithOp.right_operand)
}
inline ::milvus::proto::plan::GenericValue* BinaryArithOp::release_right_operand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::plan::GenericValue* released = _impl_.right_operand_;
  _impl_.right_operand_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::GenericValue* BinaryArithOp::unsafe_arena_release_right_operand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryArithOp.right_operand)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::plan::GenericValue* temp = _impl_.right_operand_;
  _impl_.right_operand_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::GenericValue* BinaryArithOp::_internal_mutable_right_operand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.right_operand_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::GenericValue>(GetArena());
    _impl_.right_operand_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(p);
  }
  return _impl_.right_operand_;
}
inline ::milvus::proto::plan::GenericValue* BinaryArithOp::mutable_right_operand() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::GenericValue* _msg = _internal_mutable_right_operand();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryArithOp.right_operand)
  return _msg;
}
inline void BinaryArithOp::set_allocated_right_operand(::milvus::proto::plan::GenericValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::GenericValue*>(_impl_.right_operand_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.right_operand_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryArithOp.right_operand)
}

// -------------------------------------------------------------------

// BinaryArithExpr

// .milvus.proto.plan.Expr left = 1;
inline bool BinaryArithExpr::has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_ != nullptr);
  return value;
}
inline void BinaryArithExpr::clear_left() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.left_ != nullptr) _impl_.left_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::plan::Expr& BinaryArithExpr::_internal_left() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::Expr* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::Expr&>(::milvus::proto::plan::_Expr_default_instance_);
}
inline const ::milvus::proto::plan::Expr& BinaryArithExpr::left() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryArithExpr.left)
  return _internal_left();
}
inline void BinaryArithExpr::unsafe_arena_set_allocated_left(::milvus::proto::plan::Expr* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = reinterpret_cast<::milvus::proto::plan::Expr*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.BinaryArithExpr.left)
}
inline ::milvus::proto::plan::Expr* BinaryArithExpr::release_left() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::Expr* released = _impl_.left_;
  _impl_.left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::Expr* BinaryArithExpr::unsafe_arena_release_left() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryArithExpr.left)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::Expr* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* BinaryArithExpr::_internal_mutable_left() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.left_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArena());
    _impl_.left_ = reinterpret_cast<::milvus::proto::plan::Expr*>(p);
  }
  return _impl_.left_;
}
inline ::milvus::proto::plan::Expr* BinaryArithExpr::mutable_left() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::Expr* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryArithExpr.left)
  return _msg;
}
inline void BinaryArithExpr::set_allocated_left(::milvus::proto::plan::Expr* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::Expr*>(_impl_.left_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::Expr*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.left_ = reinterpret_cast<::milvus::proto::plan::Expr*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryArithExpr.left)
}

// .milvus.proto.plan.Expr right = 2;
inline bool BinaryArithExpr::has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_ != nullptr);
  return value;
}
inline void BinaryArithExpr::clear_right() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.right_ != nullptr) _impl_.right_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::milvus::proto::plan::Expr& BinaryArithExpr::_internal_right() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::Expr* p = _impl_.right_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::Expr&>(::milvus::proto::plan::_Expr_default_instance_);
}
inline const ::milvus::proto::plan::Expr& BinaryArithExpr::right() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryArithExpr.right)
  return _internal_right();
}
inline void BinaryArithExpr::unsafe_arena_set_allocated_right(::milvus::proto::plan::Expr* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_);
  }
  _impl_.right_ = reinterpret_cast<::milvus::proto::plan::Expr*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.BinaryArithExpr.right)
}
inline ::milvus::proto::plan::Expr* BinaryArithExpr::release_right() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::plan::Expr* released = _impl_.right_;
  _impl_.right_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::Expr* BinaryArithExpr::unsafe_arena_release_right() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryArithExpr.right)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::plan::Expr* temp = _impl_.right_;
  _impl_.right_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* BinaryArithExpr::_internal_mutable_right() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.right_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArena());
    _impl_.right_ = reinterpret_cast<::milvus::proto::plan::Expr*>(p);
  }
  return _impl_.right_;
}
inline ::milvus::proto::plan::Expr* BinaryArithExpr::mutable_right() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::Expr* _msg = _internal_mutable_right();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryArithExpr.right)
  return _msg;
}
inline void BinaryArithExpr::set_allocated_right(::milvus::proto::plan::Expr* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::Expr*>(_impl_.right_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::Expr*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.right_ = reinterpret_cast<::milvus::proto::plan::Expr*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryArithExpr.right)
}

// .milvus.proto.plan.ArithOpType op = 3;
inline void BinaryArithExpr::clear_op() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.op_ = 0;
}
inline ::milvus::proto::plan::ArithOpType BinaryArithExpr::op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryArithExpr.op)
  return _internal_op();
}
inline void BinaryArithExpr::set_op(::milvus::proto::plan::ArithOpType value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.BinaryArithExpr.op)
}
inline ::milvus::proto::plan::ArithOpType BinaryArithExpr::_internal_op() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::plan::ArithOpType>(_impl_.op_);
}
inline void BinaryArithExpr::_internal_set_op(::milvus::proto::plan::ArithOpType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.op_ = value;
}

// -------------------------------------------------------------------

// BinaryArithOpEvalRangeExpr

// .milvus.proto.plan.ColumnInfo column_info = 1;
inline bool BinaryArithOpEvalRangeExpr::has_column_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.column_info_ != nullptr);
  return value;
}
inline void BinaryArithOpEvalRangeExpr::clear_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.column_info_ != nullptr) _impl_.column_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::plan::ColumnInfo& BinaryArithOpEvalRangeExpr::_internal_column_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::ColumnInfo* p = _impl_.column_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::ColumnInfo&>(::milvus::proto::plan::_ColumnInfo_default_instance_);
}
inline const ::milvus::proto::plan::ColumnInfo& BinaryArithOpEvalRangeExpr::column_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryArithOpEvalRangeExpr.column_info)
  return _internal_column_info();
}
inline void BinaryArithOpEvalRangeExpr::unsafe_arena_set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.column_info_);
  }
  _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.BinaryArithOpEvalRangeExpr.column_info)
}
inline ::milvus::proto::plan::ColumnInfo* BinaryArithOpEvalRangeExpr::release_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* released = _impl_.column_info_;
  _impl_.column_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::ColumnInfo* BinaryArithOpEvalRangeExpr::unsafe_arena_release_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryArithOpEvalRangeExpr.column_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::ColumnInfo* temp = _impl_.column_info_;
  _impl_.column_info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::ColumnInfo* BinaryArithOpEvalRangeExpr::_internal_mutable_column_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.column_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(GetArena());
    _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(p);
  }
  return _impl_.column_info_;
}
inline ::milvus::proto::plan::ColumnInfo* BinaryArithOpEvalRangeExpr::mutable_column_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::ColumnInfo* _msg = _internal_mutable_column_info();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryArithOpEvalRangeExpr.column_info)
  return _msg;
}
inline void BinaryArithOpEvalRangeExpr::set_allocated_column_info(::milvus::proto::plan::ColumnInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(_impl_.column_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.column_info_ = reinterpret_cast<::milvus::proto::plan::ColumnInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryArithOpEvalRangeExpr.column_info)
}

// .milvus.proto.plan.ArithOpType arith_op = 2;
inline void BinaryArithOpEvalRangeExpr::clear_arith_op() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.arith_op_ = 0;
}
inline ::milvus::proto::plan::ArithOpType BinaryArithOpEvalRangeExpr::arith_op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryArithOpEvalRangeExpr.arith_op)
  return _internal_arith_op();
}
inline void BinaryArithOpEvalRangeExpr::set_arith_op(::milvus::proto::plan::ArithOpType value) {
  _internal_set_arith_op(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.BinaryArithOpEvalRangeExpr.arith_op)
}
inline ::milvus::proto::plan::ArithOpType BinaryArithOpEvalRangeExpr::_internal_arith_op() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::plan::ArithOpType>(_impl_.arith_op_);
}
inline void BinaryArithOpEvalRangeExpr::_internal_set_arith_op(::milvus::proto::plan::ArithOpType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.arith_op_ = value;
}

// .milvus.proto.plan.GenericValue right_operand = 3;
inline bool BinaryArithOpEvalRangeExpr::has_right_operand() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_operand_ != nullptr);
  return value;
}
inline void BinaryArithOpEvalRangeExpr::clear_right_operand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.right_operand_ != nullptr) _impl_.right_operand_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::milvus::proto::plan::GenericValue& BinaryArithOpEvalRangeExpr::_internal_right_operand() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::GenericValue* p = _impl_.right_operand_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::GenericValue&>(::milvus::proto::plan::_GenericValue_default_instance_);
}
inline const ::milvus::proto::plan::GenericValue& BinaryArithOpEvalRangeExpr::right_operand() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryArithOpEvalRangeExpr.right_operand)
  return _internal_right_operand();
}
inline void BinaryArithOpEvalRangeExpr::unsafe_arena_set_allocated_right_operand(::milvus::proto::plan::GenericValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_operand_);
  }
  _impl_.right_operand_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.BinaryArithOpEvalRangeExpr.right_operand)
}
inline ::milvus::proto::plan::GenericValue* BinaryArithOpEvalRangeExpr::release_right_operand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::plan::GenericValue* released = _impl_.right_operand_;
  _impl_.right_operand_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::GenericValue* BinaryArithOpEvalRangeExpr::unsafe_arena_release_right_operand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryArithOpEvalRangeExpr.right_operand)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::plan::GenericValue* temp = _impl_.right_operand_;
  _impl_.right_operand_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::GenericValue* BinaryArithOpEvalRangeExpr::_internal_mutable_right_operand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.right_operand_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::GenericValue>(GetArena());
    _impl_.right_operand_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(p);
  }
  return _impl_.right_operand_;
}
inline ::milvus::proto::plan::GenericValue* BinaryArithOpEvalRangeExpr::mutable_right_operand() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::GenericValue* _msg = _internal_mutable_right_operand();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryArithOpEvalRangeExpr.right_operand)
  return _msg;
}
inline void BinaryArithOpEvalRangeExpr::set_allocated_right_operand(::milvus::proto::plan::GenericValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::GenericValue*>(_impl_.right_operand_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.right_operand_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryArithOpEvalRangeExpr.right_operand)
}

// .milvus.proto.plan.OpType op = 4;
inline void BinaryArithOpEvalRangeExpr::clear_op() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.op_ = 0;
}
inline ::milvus::proto::plan::OpType BinaryArithOpEvalRangeExpr::op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryArithOpEvalRangeExpr.op)
  return _internal_op();
}
inline void BinaryArithOpEvalRangeExpr::set_op(::milvus::proto::plan::OpType value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.BinaryArithOpEvalRangeExpr.op)
}
inline ::milvus::proto::plan::OpType BinaryArithOpEvalRangeExpr::_internal_op() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::plan::OpType>(_impl_.op_);
}
inline void BinaryArithOpEvalRangeExpr::_internal_set_op(::milvus::proto::plan::OpType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.op_ = value;
}

// .milvus.proto.plan.GenericValue value = 5;
inline bool BinaryArithOpEvalRangeExpr::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline void BinaryArithOpEvalRangeExpr::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::milvus::proto::plan::GenericValue& BinaryArithOpEvalRangeExpr::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::GenericValue* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::GenericValue&>(::milvus::proto::plan::_GenericValue_default_instance_);
}
inline const ::milvus::proto::plan::GenericValue& BinaryArithOpEvalRangeExpr::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryArithOpEvalRangeExpr.value)
  return _internal_value();
}
inline void BinaryArithOpEvalRangeExpr::unsafe_arena_set_allocated_value(::milvus::proto::plan::GenericValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.BinaryArithOpEvalRangeExpr.value)
}
inline ::milvus::proto::plan::GenericValue* BinaryArithOpEvalRangeExpr::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::milvus::proto::plan::GenericValue* released = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::GenericValue* BinaryArithOpEvalRangeExpr::unsafe_arena_release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryArithOpEvalRangeExpr.value)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::milvus::proto::plan::GenericValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::GenericValue* BinaryArithOpEvalRangeExpr::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::GenericValue>(GetArena());
    _impl_.value_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(p);
  }
  return _impl_.value_;
}
inline ::milvus::proto::plan::GenericValue* BinaryArithOpEvalRangeExpr::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::GenericValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryArithOpEvalRangeExpr.value)
  return _msg;
}
inline void BinaryArithOpEvalRangeExpr::set_allocated_value(::milvus::proto::plan::GenericValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::GenericValue*>(_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.value_ = reinterpret_cast<::milvus::proto::plan::GenericValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryArithOpEvalRangeExpr.value)
}

// -------------------------------------------------------------------

// AlwaysTrueExpr

// -------------------------------------------------------------------

// Expr

// .milvus.proto.plan.TermExpr term_expr = 1;
inline bool Expr::has_term_expr() const {
  return expr_case() == kTermExpr;
}
inline bool Expr::_internal_has_term_expr() const {
  return expr_case() == kTermExpr;
}
inline void Expr::set_has_term_expr() {
  _impl_._oneof_case_[0] = kTermExpr;
}
inline void Expr::clear_term_expr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (expr_case() == kTermExpr) {
    if (GetArena() == nullptr) {
      delete _impl_.expr_.term_expr_;
    }
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::TermExpr* Expr::release_term_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.term_expr)
  if (expr_case() == kTermExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.term_expr_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.term_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::TermExpr& Expr::_internal_term_expr() const {
  return expr_case() == kTermExpr ? *_impl_.expr_.term_expr_ : reinterpret_cast<::milvus::proto::plan::TermExpr&>(::milvus::proto::plan::_TermExpr_default_instance_);
}
inline const ::milvus::proto::plan::TermExpr& Expr::term_expr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.term_expr)
  return _internal_term_expr();
}
inline ::milvus::proto::plan::TermExpr* Expr::unsafe_arena_release_term_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.plan.Expr.term_expr)
  if (expr_case() == kTermExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.term_expr_;
    _impl_.expr_.term_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_term_expr(::milvus::proto::plan::TermExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_expr();
  if (value) {
    set_has_term_expr();
    _impl_.expr_.term_expr_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.Expr.term_expr)
}
inline ::milvus::proto::plan::TermExpr* Expr::_internal_mutable_term_expr() {
  if (expr_case() != kTermExpr) {
    clear_expr();
    set_has_term_expr();
    _impl_.expr_.term_expr_ = CreateMaybeMessage<::milvus::proto::plan::TermExpr>(GetArena());
  }
  return _impl_.expr_.term_expr_;
}
inline ::milvus::proto::plan::TermExpr* Expr::mutable_term_expr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::TermExpr* _msg = _internal_mutable_term_expr();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.term_expr)
  return _msg;
}

// .milvus.proto.plan.UnaryExpr unary_expr = 2;
inline bool Expr::has_unary_expr() const {
  return expr_case() == kUnaryExpr;
}
inline bool Expr::_internal_has_unary_expr() const {
  return expr_case() == kUnaryExpr;
}
inline void Expr::set_has_unary_expr() {
  _impl_._oneof_case_[0] = kUnaryExpr;
}
inline void Expr::clear_unary_expr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (expr_case() == kUnaryExpr) {
    if (GetArena() == nullptr) {
      delete _impl_.expr_.unary_expr_;
    }
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::UnaryExpr* Expr::release_unary_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.unary_expr)
  if (expr_case() == kUnaryExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.unary_expr_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.unary_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::UnaryExpr& Expr::_internal_unary_expr() const {
  return expr_case() == kUnaryExpr ? *_impl_.expr_.unary_expr_ : reinterpret_cast<::milvus::proto::plan::UnaryExpr&>(::milvus::proto::plan::_UnaryExpr_default_instance_);
}
inline const ::milvus::proto::plan::UnaryExpr& Expr::unary_expr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.unary_expr)
  return _internal_unary_expr();
}
inline ::milvus::proto::plan::UnaryExpr* Expr::unsafe_arena_release_unary_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.plan.Expr.unary_expr)
  if (expr_case() == kUnaryExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.unary_expr_;
    _impl_.expr_.unary_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_unary_expr(::milvus::proto::plan::UnaryExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_expr();
  if (value) {
    set_has_unary_expr();
    _impl_.expr_.unary_expr_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.Expr.unary_expr)
}
inline ::milvus::proto::plan::UnaryExpr* Expr::_internal_mutable_unary_expr() {
  if (expr_case() != kUnaryExpr) {
    clear_expr();
    set_has_unary_expr();
    _impl_.expr_.unary_expr_ = CreateMaybeMessage<::milvus::proto::plan::UnaryExpr>(GetArena());
  }
  return _impl_.expr_.unary_expr_;
}
inline ::milvus::proto::plan::UnaryExpr* Expr::mutable_unary_expr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::UnaryExpr* _msg = _internal_mutable_unary_expr();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.unary_expr)
  return _msg;
}

// .milvus.proto.plan.BinaryExpr binary_expr = 3;
inline bool Expr::has_binary_expr() const {
  return expr_case() == kBinaryExpr;
}
inline bool Expr::_internal_has_binary_expr() const {
  return expr_case() == kBinaryExpr;
}
inline void Expr::set_has_binary_expr() {
  _impl_._oneof_case_[0] = kBinaryExpr;
}
inline void Expr::clear_binary_expr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (expr_case() == kBinaryExpr) {
    if (GetArena() == nullptr) {
      delete _impl_.expr_.binary_expr_;
    }
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::BinaryExpr* Expr::release_binary_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.binary_expr)
  if (expr_case() == kBinaryExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.binary_expr_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.binary_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::BinaryExpr& Expr::_internal_binary_expr() const {
  return expr_case() == kBinaryExpr ? *_impl_.expr_.binary_expr_ : reinterpret_cast<::milvus::proto::plan::BinaryExpr&>(::milvus::proto::plan::_BinaryExpr_default_instance_);
}
inline const ::milvus::proto::plan::BinaryExpr& Expr::binary_expr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.binary_expr)
  return _internal_binary_expr();
}
inline ::milvus::proto::plan::BinaryExpr* Expr::unsafe_arena_release_binary_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.plan.Expr.binary_expr)
  if (expr_case() == kBinaryExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.binary_expr_;
    _impl_.expr_.binary_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_binary_expr(::milvus::proto::plan::BinaryExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_expr();
  if (value) {
    set_has_binary_expr();
    _impl_.expr_.binary_expr_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.Expr.binary_expr)
}
inline ::milvus::proto::plan::BinaryExpr* Expr::_internal_mutable_binary_expr() {
  if (expr_case() != kBinaryExpr) {
    clear_expr();
    set_has_binary_expr();
    _impl_.expr_.binary_expr_ = CreateMaybeMessage<::milvus::proto::plan::BinaryExpr>(GetArena());
  }
  return _impl_.expr_.binary_expr_;
}
inline ::milvus::proto::plan::BinaryExpr* Expr::mutable_binary_expr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::BinaryExpr* _msg = _internal_mutable_binary_expr();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.binary_expr)
  return _msg;
}

// .milvus.proto.plan.CompareExpr compare_expr = 4;
inline bool Expr::has_compare_expr() const {
  return expr_case() == kCompareExpr;
}
inline bool Expr::_internal_has_compare_expr() const {
  return expr_case() == kCompareExpr;
}
inline void Expr::set_has_compare_expr() {
  _impl_._oneof_case_[0] = kCompareExpr;
}
inline void Expr::clear_compare_expr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (expr_case() == kCompareExpr) {
    if (GetArena() == nullptr) {
      delete _impl_.expr_.compare_expr_;
    }
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::CompareExpr* Expr::release_compare_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.compare_expr)
  if (expr_case() == kCompareExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.compare_expr_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.compare_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::CompareExpr& Expr::_internal_compare_expr() const {
  return expr_case() == kCompareExpr ? *_impl_.expr_.compare_expr_ : reinterpret_cast<::milvus::proto::plan::CompareExpr&>(::milvus::proto::plan::_CompareExpr_default_instance_);
}
inline const ::milvus::proto::plan::CompareExpr& Expr::compare_expr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.compare_expr)
  return _internal_compare_expr();
}
inline ::milvus::proto::plan::CompareExpr* Expr::unsafe_arena_release_compare_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.plan.Expr.compare_expr)
  if (expr_case() == kCompareExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.compare_expr_;
    _impl_.expr_.compare_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_compare_expr(::milvus::proto::plan::CompareExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_expr();
  if (value) {
    set_has_compare_expr();
    _impl_.expr_.compare_expr_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.Expr.compare_expr)
}
inline ::milvus::proto::plan::CompareExpr* Expr::_internal_mutable_compare_expr() {
  if (expr_case() != kCompareExpr) {
    clear_expr();
    set_has_compare_expr();
    _impl_.expr_.compare_expr_ = CreateMaybeMessage<::milvus::proto::plan::CompareExpr>(GetArena());
  }
  return _impl_.expr_.compare_expr_;
}
inline ::milvus::proto::plan::CompareExpr* Expr::mutable_compare_expr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::CompareExpr* _msg = _internal_mutable_compare_expr();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.compare_expr)
  return _msg;
}

// .milvus.proto.plan.UnaryRangeExpr unary_range_expr = 5;
inline bool Expr::has_unary_range_expr() const {
  return expr_case() == kUnaryRangeExpr;
}
inline bool Expr::_internal_has_unary_range_expr() const {
  return expr_case() == kUnaryRangeExpr;
}
inline void Expr::set_has_unary_range_expr() {
  _impl_._oneof_case_[0] = kUnaryRangeExpr;
}
inline void Expr::clear_unary_range_expr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (expr_case() == kUnaryRangeExpr) {
    if (GetArena() == nullptr) {
      delete _impl_.expr_.unary_range_expr_;
    }
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::UnaryRangeExpr* Expr::release_unary_range_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.unary_range_expr)
  if (expr_case() == kUnaryRangeExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.unary_range_expr_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.unary_range_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::UnaryRangeExpr& Expr::_internal_unary_range_expr() const {
  return expr_case() == kUnaryRangeExpr ? *_impl_.expr_.unary_range_expr_ : reinterpret_cast<::milvus::proto::plan::UnaryRangeExpr&>(::milvus::proto::plan::_UnaryRangeExpr_default_instance_);
}
inline const ::milvus::proto::plan::UnaryRangeExpr& Expr::unary_range_expr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.unary_range_expr)
  return _internal_unary_range_expr();
}
inline ::milvus::proto::plan::UnaryRangeExpr* Expr::unsafe_arena_release_unary_range_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.plan.Expr.unary_range_expr)
  if (expr_case() == kUnaryRangeExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.unary_range_expr_;
    _impl_.expr_.unary_range_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_unary_range_expr(::milvus::proto::plan::UnaryRangeExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_expr();
  if (value) {
    set_has_unary_range_expr();
    _impl_.expr_.unary_range_expr_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.Expr.unary_range_expr)
}
inline ::milvus::proto::plan::UnaryRangeExpr* Expr::_internal_mutable_unary_range_expr() {
  if (expr_case() != kUnaryRangeExpr) {
    clear_expr();
    set_has_unary_range_expr();
    _impl_.expr_.unary_range_expr_ = CreateMaybeMessage<::milvus::proto::plan::UnaryRangeExpr>(GetArena());
  }
  return _impl_.expr_.unary_range_expr_;
}
inline ::milvus::proto::plan::UnaryRangeExpr* Expr::mutable_unary_range_expr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::UnaryRangeExpr* _msg = _internal_mutable_unary_range_expr();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.unary_range_expr)
  return _msg;
}

// .milvus.proto.plan.BinaryRangeExpr binary_range_expr = 6;
inline bool Expr::has_binary_range_expr() const {
  return expr_case() == kBinaryRangeExpr;
}
inline bool Expr::_internal_has_binary_range_expr() const {
  return expr_case() == kBinaryRangeExpr;
}
inline void Expr::set_has_binary_range_expr() {
  _impl_._oneof_case_[0] = kBinaryRangeExpr;
}
inline void Expr::clear_binary_range_expr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (expr_case() == kBinaryRangeExpr) {
    if (GetArena() == nullptr) {
      delete _impl_.expr_.binary_range_expr_;
    }
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::BinaryRangeExpr* Expr::release_binary_range_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.binary_range_expr)
  if (expr_case() == kBinaryRangeExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.binary_range_expr_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.binary_range_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::BinaryRangeExpr& Expr::_internal_binary_range_expr() const {
  return expr_case() == kBinaryRangeExpr ? *_impl_.expr_.binary_range_expr_ : reinterpret_cast<::milvus::proto::plan::BinaryRangeExpr&>(::milvus::proto::plan::_BinaryRangeExpr_default_instance_);
}
inline const ::milvus::proto::plan::BinaryRangeExpr& Expr::binary_range_expr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.binary_range_expr)
  return _internal_binary_range_expr();
}
inline ::milvus::proto::plan::BinaryRangeExpr* Expr::unsafe_arena_release_binary_range_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.plan.Expr.binary_range_expr)
  if (expr_case() == kBinaryRangeExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.binary_range_expr_;
    _impl_.expr_.binary_range_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_binary_range_expr(::milvus::proto::plan::BinaryRangeExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_expr();
  if (value) {
    set_has_binary_range_expr();
    _impl_.expr_.binary_range_expr_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.Expr.binary_range_expr)
}
inline ::milvus::proto::plan::BinaryRangeExpr* Expr::_internal_mutable_binary_range_expr() {
  if (expr_case() != kBinaryRangeExpr) {
    clear_expr();
    set_has_binary_range_expr();
    _impl_.expr_.binary_range_expr_ = CreateMaybeMessage<::milvus::proto::plan::BinaryRangeExpr>(GetArena());
  }
  return _impl_.expr_.binary_range_expr_;
}
inline ::milvus::proto::plan::BinaryRangeExpr* Expr::mutable_binary_range_expr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::BinaryRangeExpr* _msg = _internal_mutable_binary_range_expr();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.binary_range_expr)
  return _msg;
}

// .milvus.proto.plan.BinaryArithOpEvalRangeExpr binary_arith_op_eval_range_expr = 7;
inline bool Expr::has_binary_arith_op_eval_range_expr() const {
  return expr_case() == kBinaryArithOpEvalRangeExpr;
}
inline bool Expr::_internal_has_binary_arith_op_eval_range_expr() const {
  return expr_case() == kBinaryArithOpEvalRangeExpr;
}
inline void Expr::set_has_binary_arith_op_eval_range_expr() {
  _impl_._oneof_case_[0] = kBinaryArithOpEvalRangeExpr;
}
inline void Expr::clear_binary_arith_op_eval_range_expr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (expr_case() == kBinaryArithOpEvalRangeExpr) {
    if (GetArena() == nullptr) {
      delete _impl_.expr_.binary_arith_op_eval_range_expr_;
    }
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::BinaryArithOpEvalRangeExpr* Expr::release_binary_arith_op_eval_range_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.binary_arith_op_eval_range_expr)
  if (expr_case() == kBinaryArithOpEvalRangeExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.binary_arith_op_eval_range_expr_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.binary_arith_op_eval_range_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::BinaryArithOpEvalRangeExpr& Expr::_internal_binary_arith_op_eval_range_expr() const {
  return expr_case() == kBinaryArithOpEvalRangeExpr ? *_impl_.expr_.binary_arith_op_eval_range_expr_ : reinterpret_cast<::milvus::proto::plan::BinaryArithOpEvalRangeExpr&>(::milvus::proto::plan::_BinaryArithOpEvalRangeExpr_default_instance_);
}
inline const ::milvus::proto::plan::BinaryArithOpEvalRangeExpr& Expr::binary_arith_op_eval_range_expr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.binary_arith_op_eval_range_expr)
  return _internal_binary_arith_op_eval_range_expr();
}
inline ::milvus::proto::plan::BinaryArithOpEvalRangeExpr* Expr::unsafe_arena_release_binary_arith_op_eval_range_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.plan.Expr.binary_arith_op_eval_range_expr)
  if (expr_case() == kBinaryArithOpEvalRangeExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.binary_arith_op_eval_range_expr_;
    _impl_.expr_.binary_arith_op_eval_range_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_binary_arith_op_eval_range_expr(::milvus::proto::plan::BinaryArithOpEvalRangeExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_expr();
  if (value) {
    set_has_binary_arith_op_eval_range_expr();
    _impl_.expr_.binary_arith_op_eval_range_expr_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.Expr.binary_arith_op_eval_range_expr)
}
inline ::milvus::proto::plan::BinaryArithOpEvalRangeExpr* Expr::_internal_mutable_binary_arith_op_eval_range_expr() {
  if (expr_case() != kBinaryArithOpEvalRangeExpr) {
    clear_expr();
    set_has_binary_arith_op_eval_range_expr();
    _impl_.expr_.binary_arith_op_eval_range_expr_ = CreateMaybeMessage<::milvus::proto::plan::BinaryArithOpEvalRangeExpr>(GetArena());
  }
  return _impl_.expr_.binary_arith_op_eval_range_expr_;
}
inline ::milvus::proto::plan::BinaryArithOpEvalRangeExpr* Expr::mutable_binary_arith_op_eval_range_expr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::BinaryArithOpEvalRangeExpr* _msg = _internal_mutable_binary_arith_op_eval_range_expr();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.binary_arith_op_eval_range_expr)
  return _msg;
}

// .milvus.proto.plan.BinaryArithExpr binary_arith_expr = 8;
inline bool Expr::has_binary_arith_expr() const {
  return expr_case() == kBinaryArithExpr;
}
inline bool Expr::_internal_has_binary_arith_expr() const {
  return expr_case() == kBinaryArithExpr;
}
inline void Expr::set_has_binary_arith_expr() {
  _impl_._oneof_case_[0] = kBinaryArithExpr;
}
inline void Expr::clear_binary_arith_expr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (expr_case() == kBinaryArithExpr) {
    if (GetArena() == nullptr) {
      delete _impl_.expr_.binary_arith_expr_;
    }
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::BinaryArithExpr* Expr::release_binary_arith_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.binary_arith_expr)
  if (expr_case() == kBinaryArithExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.binary_arith_expr_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.binary_arith_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::BinaryArithExpr& Expr::_internal_binary_arith_expr() const {
  return expr_case() == kBinaryArithExpr ? *_impl_.expr_.binary_arith_expr_ : reinterpret_cast<::milvus::proto::plan::BinaryArithExpr&>(::milvus::proto::plan::_BinaryArithExpr_default_instance_);
}
inline const ::milvus::proto::plan::BinaryArithExpr& Expr::binary_arith_expr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.binary_arith_expr)
  return _internal_binary_arith_expr();
}
inline ::milvus::proto::plan::BinaryArithExpr* Expr::unsafe_arena_release_binary_arith_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.plan.Expr.binary_arith_expr)
  if (expr_case() == kBinaryArithExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.binary_arith_expr_;
    _impl_.expr_.binary_arith_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_binary_arith_expr(::milvus::proto::plan::BinaryArithExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_expr();
  if (value) {
    set_has_binary_arith_expr();
    _impl_.expr_.binary_arith_expr_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.Expr.binary_arith_expr)
}
inline ::milvus::proto::plan::BinaryArithExpr* Expr::_internal_mutable_binary_arith_expr() {
  if (expr_case() != kBinaryArithExpr) {
    clear_expr();
    set_has_binary_arith_expr();
    _impl_.expr_.binary_arith_expr_ = CreateMaybeMessage<::milvus::proto::plan::BinaryArithExpr>(GetArena());
  }
  return _impl_.expr_.binary_arith_expr_;
}
inline ::milvus::proto::plan::BinaryArithExpr* Expr::mutable_binary_arith_expr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::BinaryArithExpr* _msg = _internal_mutable_binary_arith_expr();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.binary_arith_expr)
  return _msg;
}

// .milvus.proto.plan.ValueExpr value_expr = 9;
inline bool Expr::has_value_expr() const {
  return expr_case() == kValueExpr;
}
inline bool Expr::_internal_has_value_expr() const {
  return expr_case() == kValueExpr;
}
inline void Expr::set_has_value_expr() {
  _impl_._oneof_case_[0] = kValueExpr;
}
inline void Expr::clear_value_expr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (expr_case() == kValueExpr) {
    if (GetArena() == nullptr) {
      delete _impl_.expr_.value_expr_;
    }
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::ValueExpr* Expr::release_value_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.value_expr)
  if (expr_case() == kValueExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.value_expr_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.value_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::ValueExpr& Expr::_internal_value_expr() const {
  return expr_case() == kValueExpr ? *_impl_.expr_.value_expr_ : reinterpret_cast<::milvus::proto::plan::ValueExpr&>(::milvus::proto::plan::_ValueExpr_default_instance_);
}
inline const ::milvus::proto::plan::ValueExpr& Expr::value_expr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.value_expr)
  return _internal_value_expr();
}
inline ::milvus::proto::plan::ValueExpr* Expr::unsafe_arena_release_value_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.plan.Expr.value_expr)
  if (expr_case() == kValueExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.value_expr_;
    _impl_.expr_.value_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_value_expr(::milvus::proto::plan::ValueExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_expr();
  if (value) {
    set_has_value_expr();
    _impl_.expr_.value_expr_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.Expr.value_expr)
}
inline ::milvus::proto::plan::ValueExpr* Expr::_internal_mutable_value_expr() {
  if (expr_case() != kValueExpr) {
    clear_expr();
    set_has_value_expr();
    _impl_.expr_.value_expr_ = CreateMaybeMessage<::milvus::proto::plan::ValueExpr>(GetArena());
  }
  return _impl_.expr_.value_expr_;
}
inline ::milvus::proto::plan::ValueExpr* Expr::mutable_value_expr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::ValueExpr* _msg = _internal_mutable_value_expr();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.value_expr)
  return _msg;
}

// .milvus.proto.plan.ColumnExpr column_expr = 10;
inline bool Expr::has_column_expr() const {
  return expr_case() == kColumnExpr;
}
inline bool Expr::_internal_has_column_expr() const {
  return expr_case() == kColumnExpr;
}
inline void Expr::set_has_column_expr() {
  _impl_._oneof_case_[0] = kColumnExpr;
}
inline void Expr::clear_column_expr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (expr_case() == kColumnExpr) {
    if (GetArena() == nullptr) {
      delete _impl_.expr_.column_expr_;
    }
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::ColumnExpr* Expr::release_column_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.column_expr)
  if (expr_case() == kColumnExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.column_expr_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.column_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::ColumnExpr& Expr::_internal_column_expr() const {
  return expr_case() == kColumnExpr ? *_impl_.expr_.column_expr_ : reinterpret_cast<::milvus::proto::plan::ColumnExpr&>(::milvus::proto::plan::_ColumnExpr_default_instance_);
}
inline const ::milvus::proto::plan::ColumnExpr& Expr::column_expr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.column_expr)
  return _internal_column_expr();
}
inline ::milvus::proto::plan::ColumnExpr* Expr::unsafe_arena_release_column_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.plan.Expr.column_expr)
  if (expr_case() == kColumnExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.column_expr_;
    _impl_.expr_.column_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_column_expr(::milvus::proto::plan::ColumnExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_expr();
  if (value) {
    set_has_column_expr();
    _impl_.expr_.column_expr_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.Expr.column_expr)
}
inline ::milvus::proto::plan::ColumnExpr* Expr::_internal_mutable_column_expr() {
  if (expr_case() != kColumnExpr) {
    clear_expr();
    set_has_column_expr();
    _impl_.expr_.column_expr_ = CreateMaybeMessage<::milvus::proto::plan::ColumnExpr>(GetArena());
  }
  return _impl_.expr_.column_expr_;
}
inline ::milvus::proto::plan::ColumnExpr* Expr::mutable_column_expr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::ColumnExpr* _msg = _internal_mutable_column_expr();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.column_expr)
  return _msg;
}

// .milvus.proto.plan.ExistsExpr exists_expr = 11;
inline bool Expr::has_exists_expr() const {
  return expr_case() == kExistsExpr;
}
inline bool Expr::_internal_has_exists_expr() const {
  return expr_case() == kExistsExpr;
}
inline void Expr::set_has_exists_expr() {
  _impl_._oneof_case_[0] = kExistsExpr;
}
inline void Expr::clear_exists_expr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (expr_case() == kExistsExpr) {
    if (GetArena() == nullptr) {
      delete _impl_.expr_.exists_expr_;
    }
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::ExistsExpr* Expr::release_exists_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.exists_expr)
  if (expr_case() == kExistsExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.exists_expr_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.exists_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::ExistsExpr& Expr::_internal_exists_expr() const {
  return expr_case() == kExistsExpr ? *_impl_.expr_.exists_expr_ : reinterpret_cast<::milvus::proto::plan::ExistsExpr&>(::milvus::proto::plan::_ExistsExpr_default_instance_);
}
inline const ::milvus::proto::plan::ExistsExpr& Expr::exists_expr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.exists_expr)
  return _internal_exists_expr();
}
inline ::milvus::proto::plan::ExistsExpr* Expr::unsafe_arena_release_exists_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.plan.Expr.exists_expr)
  if (expr_case() == kExistsExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.exists_expr_;
    _impl_.expr_.exists_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_exists_expr(::milvus::proto::plan::ExistsExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_expr();
  if (value) {
    set_has_exists_expr();
    _impl_.expr_.exists_expr_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.Expr.exists_expr)
}
inline ::milvus::proto::plan::ExistsExpr* Expr::_internal_mutable_exists_expr() {
  if (expr_case() != kExistsExpr) {
    clear_expr();
    set_has_exists_expr();
    _impl_.expr_.exists_expr_ = CreateMaybeMessage<::milvus::proto::plan::ExistsExpr>(GetArena());
  }
  return _impl_.expr_.exists_expr_;
}
inline ::milvus::proto::plan::ExistsExpr* Expr::mutable_exists_expr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::ExistsExpr* _msg = _internal_mutable_exists_expr();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.exists_expr)
  return _msg;
}

// .milvus.proto.plan.AlwaysTrueExpr always_true_expr = 12;
inline bool Expr::has_always_true_expr() const {
  return expr_case() == kAlwaysTrueExpr;
}
inline bool Expr::_internal_has_always_true_expr() const {
  return expr_case() == kAlwaysTrueExpr;
}
inline void Expr::set_has_always_true_expr() {
  _impl_._oneof_case_[0] = kAlwaysTrueExpr;
}
inline void Expr::clear_always_true_expr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (expr_case() == kAlwaysTrueExpr) {
    if (GetArena() == nullptr) {
      delete _impl_.expr_.always_true_expr_;
    }
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::AlwaysTrueExpr* Expr::release_always_true_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.always_true_expr)
  if (expr_case() == kAlwaysTrueExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.always_true_expr_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.always_true_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::AlwaysTrueExpr& Expr::_internal_always_true_expr() const {
  return expr_case() == kAlwaysTrueExpr ? *_impl_.expr_.always_true_expr_ : reinterpret_cast<::milvus::proto::plan::AlwaysTrueExpr&>(::milvus::proto::plan::_AlwaysTrueExpr_default_instance_);
}
inline const ::milvus::proto::plan::AlwaysTrueExpr& Expr::always_true_expr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.always_true_expr)
  return _internal_always_true_expr();
}
inline ::milvus::proto::plan::AlwaysTrueExpr* Expr::unsafe_arena_release_always_true_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.plan.Expr.always_true_expr)
  if (expr_case() == kAlwaysTrueExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.always_true_expr_;
    _impl_.expr_.always_true_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_always_true_expr(::milvus::proto::plan::AlwaysTrueExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_expr();
  if (value) {
    set_has_always_true_expr();
    _impl_.expr_.always_true_expr_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.Expr.always_true_expr)
}
inline ::milvus::proto::plan::AlwaysTrueExpr* Expr::_internal_mutable_always_true_expr() {
  if (expr_case() != kAlwaysTrueExpr) {
    clear_expr();
    set_has_always_true_expr();
    _impl_.expr_.always_true_expr_ = CreateMaybeMessage<::milvus::proto::plan::AlwaysTrueExpr>(GetArena());
  }
  return _impl_.expr_.always_true_expr_;
}
inline ::milvus::proto::plan::AlwaysTrueExpr* Expr::mutable_always_true_expr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::AlwaysTrueExpr* _msg = _internal_mutable_always_true_expr();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.always_true_expr)
  return _msg;
}

// .milvus.proto.plan.JSONContainsExpr json_contains_expr = 13;
inline bool Expr::has_json_contains_expr() const {
  return expr_case() == kJsonContainsExpr;
}
inline bool Expr::_internal_has_json_contains_expr() const {
  return expr_case() == kJsonContainsExpr;
}
inline void Expr::set_has_json_contains_expr() {
  _impl_._oneof_case_[0] = kJsonContainsExpr;
}
inline void Expr::clear_json_contains_expr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (expr_case() == kJsonContainsExpr) {
    if (GetArena() == nullptr) {
      delete _impl_.expr_.json_contains_expr_;
    }
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::JSONContainsExpr* Expr::release_json_contains_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.json_contains_expr)
  if (expr_case() == kJsonContainsExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.json_contains_expr_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.expr_.json_contains_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::JSONContainsExpr& Expr::_internal_json_contains_expr() const {
  return expr_case() == kJsonContainsExpr ? *_impl_.expr_.json_contains_expr_ : reinterpret_cast<::milvus::proto::plan::JSONContainsExpr&>(::milvus::proto::plan::_JSONContainsExpr_default_instance_);
}
inline const ::milvus::proto::plan::JSONContainsExpr& Expr::json_contains_expr() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.json_contains_expr)
  return _internal_json_contains_expr();
}
inline ::milvus::proto::plan::JSONContainsExpr* Expr::unsafe_arena_release_json_contains_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.plan.Expr.json_contains_expr)
  if (expr_case() == kJsonContainsExpr) {
    clear_has_expr();
    auto* temp = _impl_.expr_.json_contains_expr_;
    _impl_.expr_.json_contains_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Expr::unsafe_arena_set_allocated_json_contains_expr(::milvus::proto::plan::JSONContainsExpr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_expr();
  if (value) {
    set_has_json_contains_expr();
    _impl_.expr_.json_contains_expr_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.Expr.json_contains_expr)
}
inline ::milvus::proto::plan::JSONContainsExpr* Expr::_internal_mutable_json_contains_expr() {
  if (expr_case() != kJsonContainsExpr) {
    clear_expr();
    set_has_json_contains_expr();
    _impl_.expr_.json_contains_expr_ = CreateMaybeMessage<::milvus::proto::plan::JSONContainsExpr>(GetArena());
  }
  return _impl_.expr_.json_contains_expr_;
}
inline ::milvus::proto::plan::JSONContainsExpr* Expr::mutable_json_contains_expr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::JSONContainsExpr* _msg = _internal_mutable_json_contains_expr();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.json_contains_expr)
  return _msg;
}

inline bool Expr::has_expr() const {
  return expr_case() != EXPR_NOT_SET;
}
inline void Expr::clear_has_expr() {
  _impl_._oneof_case_[0] = EXPR_NOT_SET;
}
inline Expr::ExprCase Expr::expr_case() const {
  return Expr::ExprCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VectorANNS

// .milvus.proto.plan.VectorType vector_type = 1;
inline void VectorANNS::clear_vector_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vector_type_ = 0;
}
inline ::milvus::proto::plan::VectorType VectorANNS::vector_type() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.VectorANNS.vector_type)
  return _internal_vector_type();
}
inline void VectorANNS::set_vector_type(::milvus::proto::plan::VectorType value) {
  _internal_set_vector_type(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.VectorANNS.vector_type)
}
inline ::milvus::proto::plan::VectorType VectorANNS::_internal_vector_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::plan::VectorType>(_impl_.vector_type_);
}
inline void VectorANNS::_internal_set_vector_type(::milvus::proto::plan::VectorType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.vector_type_ = value;
}

// int64 field_id = 2;
inline void VectorANNS::clear_field_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.field_id_ = ::int64_t{0};
}
inline ::int64_t VectorANNS::field_id() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.VectorANNS.field_id)
  return _internal_field_id();
}
inline void VectorANNS::set_field_id(::int64_t value) {
  _internal_set_field_id(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.VectorANNS.field_id)
}
inline ::int64_t VectorANNS::_internal_field_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.field_id_;
}
inline void VectorANNS::_internal_set_field_id(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.field_id_ = value;
}

// .milvus.proto.plan.Expr predicates = 3;
inline bool VectorANNS::has_predicates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.predicates_ != nullptr);
  return value;
}
inline void VectorANNS::clear_predicates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.predicates_ != nullptr) _impl_.predicates_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::plan::Expr& VectorANNS::_internal_predicates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::Expr* p = _impl_.predicates_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::Expr&>(::milvus::proto::plan::_Expr_default_instance_);
}
inline const ::milvus::proto::plan::Expr& VectorANNS::predicates() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.VectorANNS.predicates)
  return _internal_predicates();
}
inline void VectorANNS::unsafe_arena_set_allocated_predicates(::milvus::proto::plan::Expr* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.predicates_);
  }
  _impl_.predicates_ = reinterpret_cast<::milvus::proto::plan::Expr*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.VectorANNS.predicates)
}
inline ::milvus::proto::plan::Expr* VectorANNS::release_predicates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::Expr* released = _impl_.predicates_;
  _impl_.predicates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::Expr* VectorANNS::unsafe_arena_release_predicates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.VectorANNS.predicates)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::Expr* temp = _impl_.predicates_;
  _impl_.predicates_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* VectorANNS::_internal_mutable_predicates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.predicates_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArena());
    _impl_.predicates_ = reinterpret_cast<::milvus::proto::plan::Expr*>(p);
  }
  return _impl_.predicates_;
}
inline ::milvus::proto::plan::Expr* VectorANNS::mutable_predicates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::Expr* _msg = _internal_mutable_predicates();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.VectorANNS.predicates)
  return _msg;
}
inline void VectorANNS::set_allocated_predicates(::milvus::proto::plan::Expr* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::Expr*>(_impl_.predicates_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::Expr*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.predicates_ = reinterpret_cast<::milvus::proto::plan::Expr*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.VectorANNS.predicates)
}

// .milvus.proto.plan.QueryInfo query_info = 4;
inline bool VectorANNS::has_query_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.query_info_ != nullptr);
  return value;
}
inline void VectorANNS::clear_query_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.query_info_ != nullptr) _impl_.query_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::milvus::proto::plan::QueryInfo& VectorANNS::_internal_query_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::QueryInfo* p = _impl_.query_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::QueryInfo&>(::milvus::proto::plan::_QueryInfo_default_instance_);
}
inline const ::milvus::proto::plan::QueryInfo& VectorANNS::query_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.VectorANNS.query_info)
  return _internal_query_info();
}
inline void VectorANNS::unsafe_arena_set_allocated_query_info(::milvus::proto::plan::QueryInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.query_info_);
  }
  _impl_.query_info_ = reinterpret_cast<::milvus::proto::plan::QueryInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.VectorANNS.query_info)
}
inline ::milvus::proto::plan::QueryInfo* VectorANNS::release_query_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::plan::QueryInfo* released = _impl_.query_info_;
  _impl_.query_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::QueryInfo* VectorANNS::unsafe_arena_release_query_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.VectorANNS.query_info)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::plan::QueryInfo* temp = _impl_.query_info_;
  _impl_.query_info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::QueryInfo* VectorANNS::_internal_mutable_query_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.query_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::QueryInfo>(GetArena());
    _impl_.query_info_ = reinterpret_cast<::milvus::proto::plan::QueryInfo*>(p);
  }
  return _impl_.query_info_;
}
inline ::milvus::proto::plan::QueryInfo* VectorANNS::mutable_query_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::QueryInfo* _msg = _internal_mutable_query_info();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.VectorANNS.query_info)
  return _msg;
}
inline void VectorANNS::set_allocated_query_info(::milvus::proto::plan::QueryInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::QueryInfo*>(_impl_.query_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::QueryInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.query_info_ = reinterpret_cast<::milvus::proto::plan::QueryInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.VectorANNS.query_info)
}

// string placeholder_tag = 5;
inline void VectorANNS::clear_placeholder_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.placeholder_tag_.ClearToEmpty();
}
inline const std::string& VectorANNS::placeholder_tag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.VectorANNS.placeholder_tag)
  return _internal_placeholder_tag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VectorANNS::set_placeholder_tag(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.placeholder_tag_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:milvus.proto.plan.VectorANNS.placeholder_tag)
}
inline std::string* VectorANNS::mutable_placeholder_tag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_placeholder_tag();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.VectorANNS.placeholder_tag)
  return _s;
}
inline const std::string& VectorANNS::_internal_placeholder_tag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.placeholder_tag_.Get();
}
inline void VectorANNS::_internal_set_placeholder_tag(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.placeholder_tag_.Set(value, GetArena());
}
inline std::string* VectorANNS::_internal_mutable_placeholder_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.placeholder_tag_.Mutable( GetArena());
}
inline std::string* VectorANNS::release_placeholder_tag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.VectorANNS.placeholder_tag)
  return _impl_.placeholder_tag_.Release();
}
inline void VectorANNS::set_allocated_placeholder_tag(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.placeholder_tag_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.placeholder_tag_.IsDefault()) {
          _impl_.placeholder_tag_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.VectorANNS.placeholder_tag)
}

// -------------------------------------------------------------------

// QueryPlanNode

// .milvus.proto.plan.Expr predicates = 1;
inline bool QueryPlanNode::has_predicates() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.predicates_ != nullptr);
  return value;
}
inline void QueryPlanNode::clear_predicates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.predicates_ != nullptr) _impl_.predicates_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::plan::Expr& QueryPlanNode::_internal_predicates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::plan::Expr* p = _impl_.predicates_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::plan::Expr&>(::milvus::proto::plan::_Expr_default_instance_);
}
inline const ::milvus::proto::plan::Expr& QueryPlanNode::predicates() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.QueryPlanNode.predicates)
  return _internal_predicates();
}
inline void QueryPlanNode::unsafe_arena_set_allocated_predicates(::milvus::proto::plan::Expr* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.predicates_);
  }
  _impl_.predicates_ = reinterpret_cast<::milvus::proto::plan::Expr*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.QueryPlanNode.predicates)
}
inline ::milvus::proto::plan::Expr* QueryPlanNode::release_predicates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::Expr* released = _impl_.predicates_;
  _impl_.predicates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::plan::Expr* QueryPlanNode::unsafe_arena_release_predicates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.plan.QueryPlanNode.predicates)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::plan::Expr* temp = _impl_.predicates_;
  _impl_.predicates_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* QueryPlanNode::_internal_mutable_predicates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.predicates_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArena());
    _impl_.predicates_ = reinterpret_cast<::milvus::proto::plan::Expr*>(p);
  }
  return _impl_.predicates_;
}
inline ::milvus::proto::plan::Expr* QueryPlanNode::mutable_predicates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::Expr* _msg = _internal_mutable_predicates();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.QueryPlanNode.predicates)
  return _msg;
}
inline void QueryPlanNode::set_allocated_predicates(::milvus::proto::plan::Expr* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::plan::Expr*>(_impl_.predicates_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::plan::Expr*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.predicates_ = reinterpret_cast<::milvus::proto::plan::Expr*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.QueryPlanNode.predicates)
}

// bool is_count = 2;
inline void QueryPlanNode::clear_is_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_count_ = false;
}
inline bool QueryPlanNode::is_count() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.QueryPlanNode.is_count)
  return _internal_is_count();
}
inline void QueryPlanNode::set_is_count(bool value) {
  _internal_set_is_count(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.QueryPlanNode.is_count)
}
inline bool QueryPlanNode::_internal_is_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_count_;
}
inline void QueryPlanNode::_internal_set_is_count(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_count_ = value;
}

// int64 limit = 3;
inline void QueryPlanNode::clear_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.limit_ = ::int64_t{0};
}
inline ::int64_t QueryPlanNode::limit() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.QueryPlanNode.limit)
  return _internal_limit();
}
inline void QueryPlanNode::set_limit(::int64_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.QueryPlanNode.limit)
}
inline ::int64_t QueryPlanNode::_internal_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.limit_;
}
inline void QueryPlanNode::_internal_set_limit(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.limit_ = value;
}

// -------------------------------------------------------------------

// PlanNode

// .milvus.proto.plan.VectorANNS vector_anns = 1;
inline bool PlanNode::has_vector_anns() const {
  return node_case() == kVectorAnns;
}
inline bool PlanNode::_internal_has_vector_anns() const {
  return node_case() == kVectorAnns;
}
inline void PlanNode::set_has_vector_anns() {
  _impl_._oneof_case_[0] = kVectorAnns;
}
inline void PlanNode::clear_vector_anns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (node_case() == kVectorAnns) {
    if (GetArena() == nullptr) {
      delete _impl_.node_.vector_anns_;
    }
    clear_has_node();
  }
}
inline ::milvus::proto::plan::VectorANNS* PlanNode::release_vector_anns() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.PlanNode.vector_anns)
  if (node_case() == kVectorAnns) {
    clear_has_node();
    auto* temp = _impl_.node_.vector_anns_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.node_.vector_anns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::VectorANNS& PlanNode::_internal_vector_anns() const {
  return node_case() == kVectorAnns ? *_impl_.node_.vector_anns_ : reinterpret_cast<::milvus::proto::plan::VectorANNS&>(::milvus::proto::plan::_VectorANNS_default_instance_);
}
inline const ::milvus::proto::plan::VectorANNS& PlanNode::vector_anns() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.PlanNode.vector_anns)
  return _internal_vector_anns();
}
inline ::milvus::proto::plan::VectorANNS* PlanNode::unsafe_arena_release_vector_anns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.plan.PlanNode.vector_anns)
  if (node_case() == kVectorAnns) {
    clear_has_node();
    auto* temp = _impl_.node_.vector_anns_;
    _impl_.node_.vector_anns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlanNode::unsafe_arena_set_allocated_vector_anns(::milvus::proto::plan::VectorANNS* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_node();
  if (value) {
    set_has_vector_anns();
    _impl_.node_.vector_anns_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.PlanNode.vector_anns)
}
inline ::milvus::proto::plan::VectorANNS* PlanNode::_internal_mutable_vector_anns() {
  if (node_case() != kVectorAnns) {
    clear_node();
    set_has_vector_anns();
    _impl_.node_.vector_anns_ = CreateMaybeMessage<::milvus::proto::plan::VectorANNS>(GetArena());
  }
  return _impl_.node_.vector_anns_;
}
inline ::milvus::proto::plan::VectorANNS* PlanNode::mutable_vector_anns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::VectorANNS* _msg = _internal_mutable_vector_anns();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.PlanNode.vector_anns)
  return _msg;
}

// .milvus.proto.plan.Expr predicates = 2;
inline bool PlanNode::has_predicates() const {
  return node_case() == kPredicates;
}
inline bool PlanNode::_internal_has_predicates() const {
  return node_case() == kPredicates;
}
inline void PlanNode::set_has_predicates() {
  _impl_._oneof_case_[0] = kPredicates;
}
inline void PlanNode::clear_predicates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (node_case() == kPredicates) {
    if (GetArena() == nullptr) {
      delete _impl_.node_.predicates_;
    }
    clear_has_node();
  }
}
inline ::milvus::proto::plan::Expr* PlanNode::release_predicates() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.PlanNode.predicates)
  if (node_case() == kPredicates) {
    clear_has_node();
    auto* temp = _impl_.node_.predicates_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.node_.predicates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::Expr& PlanNode::_internal_predicates() const {
  return node_case() == kPredicates ? *_impl_.node_.predicates_ : reinterpret_cast<::milvus::proto::plan::Expr&>(::milvus::proto::plan::_Expr_default_instance_);
}
inline const ::milvus::proto::plan::Expr& PlanNode::predicates() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.PlanNode.predicates)
  return _internal_predicates();
}
inline ::milvus::proto::plan::Expr* PlanNode::unsafe_arena_release_predicates() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.plan.PlanNode.predicates)
  if (node_case() == kPredicates) {
    clear_has_node();
    auto* temp = _impl_.node_.predicates_;
    _impl_.node_.predicates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlanNode::unsafe_arena_set_allocated_predicates(::milvus::proto::plan::Expr* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_node();
  if (value) {
    set_has_predicates();
    _impl_.node_.predicates_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.PlanNode.predicates)
}
inline ::milvus::proto::plan::Expr* PlanNode::_internal_mutable_predicates() {
  if (node_case() != kPredicates) {
    clear_node();
    set_has_predicates();
    _impl_.node_.predicates_ = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArena());
  }
  return _impl_.node_.predicates_;
}
inline ::milvus::proto::plan::Expr* PlanNode::mutable_predicates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::Expr* _msg = _internal_mutable_predicates();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.PlanNode.predicates)
  return _msg;
}

// .milvus.proto.plan.QueryPlanNode query = 4;
inline bool PlanNode::has_query() const {
  return node_case() == kQuery;
}
inline bool PlanNode::_internal_has_query() const {
  return node_case() == kQuery;
}
inline void PlanNode::set_has_query() {
  _impl_._oneof_case_[0] = kQuery;
}
inline void PlanNode::clear_query() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (node_case() == kQuery) {
    if (GetArena() == nullptr) {
      delete _impl_.node_.query_;
    }
    clear_has_node();
  }
}
inline ::milvus::proto::plan::QueryPlanNode* PlanNode::release_query() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.PlanNode.query)
  if (node_case() == kQuery) {
    clear_has_node();
    auto* temp = _impl_.node_.query_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.node_.query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::QueryPlanNode& PlanNode::_internal_query() const {
  return node_case() == kQuery ? *_impl_.node_.query_ : reinterpret_cast<::milvus::proto::plan::QueryPlanNode&>(::milvus::proto::plan::_QueryPlanNode_default_instance_);
}
inline const ::milvus::proto::plan::QueryPlanNode& PlanNode::query() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.PlanNode.query)
  return _internal_query();
}
inline ::milvus::proto::plan::QueryPlanNode* PlanNode::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.plan.PlanNode.query)
  if (node_case() == kQuery) {
    clear_has_node();
    auto* temp = _impl_.node_.query_;
    _impl_.node_.query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlanNode::unsafe_arena_set_allocated_query(::milvus::proto::plan::QueryPlanNode* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_node();
  if (value) {
    set_has_query();
    _impl_.node_.query_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.plan.PlanNode.query)
}
inline ::milvus::proto::plan::QueryPlanNode* PlanNode::_internal_mutable_query() {
  if (node_case() != kQuery) {
    clear_node();
    set_has_query();
    _impl_.node_.query_ = CreateMaybeMessage<::milvus::proto::plan::QueryPlanNode>(GetArena());
  }
  return _impl_.node_.query_;
}
inline ::milvus::proto::plan::QueryPlanNode* PlanNode::mutable_query() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::plan::QueryPlanNode* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.PlanNode.query)
  return _msg;
}

// repeated int64 output_field_ids = 3;
inline int PlanNode::_internal_output_field_ids_size() const {
  return _internal_output_field_ids().size();
}
inline int PlanNode::output_field_ids_size() const {
  return _internal_output_field_ids_size();
}
inline void PlanNode::clear_output_field_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.output_field_ids_.Clear();
}
inline ::int64_t PlanNode::output_field_ids(int index) const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.PlanNode.output_field_ids)
  return _internal_output_field_ids().Get(index);
}
inline void PlanNode::set_output_field_ids(int index, ::int64_t value) {
  _internal_mutable_output_field_ids()->Set(index, value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.PlanNode.output_field_ids)
}
inline void PlanNode::add_output_field_ids(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_output_field_ids()->Add(value);
  // @@protoc_insertion_point(field_add:milvus.proto.plan.PlanNode.output_field_ids)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& PlanNode::output_field_ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.plan.PlanNode.output_field_ids)
  return _internal_output_field_ids();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PlanNode::mutable_output_field_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.plan.PlanNode.output_field_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_output_field_ids();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& PlanNode::_internal_output_field_ids()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.output_field_ids_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PlanNode::_internal_mutable_output_field_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.output_field_ids_;
}

inline bool PlanNode::has_node() const {
  return node_case() != NODE_NOT_SET;
}
inline void PlanNode::clear_has_node() {
  _impl_._oneof_case_[0] = NODE_NOT_SET;
}
inline PlanNode::NodeCase PlanNode::node_case() const {
  return PlanNode::NodeCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace plan
}  // namespace proto
}  // namespace milvus


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::milvus::proto::plan::JSONContainsExpr_JSONOp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::milvus::proto::plan::JSONContainsExpr_JSONOp>() {
  return ::milvus::proto::plan::JSONContainsExpr_JSONOp_descriptor();
}
template <>
struct is_proto_enum<::milvus::proto::plan::UnaryExpr_UnaryOp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::milvus::proto::plan::UnaryExpr_UnaryOp>() {
  return ::milvus::proto::plan::UnaryExpr_UnaryOp_descriptor();
}
template <>
struct is_proto_enum<::milvus::proto::plan::BinaryExpr_BinaryOp> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::milvus::proto::plan::BinaryExpr_BinaryOp>() {
  return ::milvus::proto::plan::BinaryExpr_BinaryOp_descriptor();
}
template <>
struct is_proto_enum<::milvus::proto::plan::OpType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::milvus::proto::plan::OpType>() {
  return ::milvus::proto::plan::OpType_descriptor();
}
template <>
struct is_proto_enum<::milvus::proto::plan::ArithOpType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::milvus::proto::plan::ArithOpType>() {
  return ::milvus::proto::plan::ArithOpType_descriptor();
}
template <>
struct is_proto_enum<::milvus::proto::plan::VectorType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::milvus::proto::plan::VectorType>() {
  return ::milvus::proto::plan::VectorType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_Plan_2eproto_2epb_2eh
