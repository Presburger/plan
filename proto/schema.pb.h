// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: schema.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_schema_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_schema_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "common.pb.h"
#include "google/protobuf/descriptor.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_schema_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_schema_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_schema_2eproto;
namespace milvus {
namespace proto {
namespace schema {
class ArrayArray;
struct ArrayArrayDefaultTypeInternal;
extern ArrayArrayDefaultTypeInternal _ArrayArray_default_instance_;
class BoolArray;
struct BoolArrayDefaultTypeInternal;
extern BoolArrayDefaultTypeInternal _BoolArray_default_instance_;
class BytesArray;
struct BytesArrayDefaultTypeInternal;
extern BytesArrayDefaultTypeInternal _BytesArray_default_instance_;
class ClusteringInfo;
struct ClusteringInfoDefaultTypeInternal;
extern ClusteringInfoDefaultTypeInternal _ClusteringInfo_default_instance_;
class CollectionSchema;
struct CollectionSchemaDefaultTypeInternal;
extern CollectionSchemaDefaultTypeInternal _CollectionSchema_default_instance_;
class DoubleArray;
struct DoubleArrayDefaultTypeInternal;
extern DoubleArrayDefaultTypeInternal _DoubleArray_default_instance_;
class FieldData;
struct FieldDataDefaultTypeInternal;
extern FieldDataDefaultTypeInternal _FieldData_default_instance_;
class FieldSchema;
struct FieldSchemaDefaultTypeInternal;
extern FieldSchemaDefaultTypeInternal _FieldSchema_default_instance_;
class FloatArray;
struct FloatArrayDefaultTypeInternal;
extern FloatArrayDefaultTypeInternal _FloatArray_default_instance_;
class IDs;
struct IDsDefaultTypeInternal;
extern IDsDefaultTypeInternal _IDs_default_instance_;
class IntArray;
struct IntArrayDefaultTypeInternal;
extern IntArrayDefaultTypeInternal _IntArray_default_instance_;
class JSONArray;
struct JSONArrayDefaultTypeInternal;
extern JSONArrayDefaultTypeInternal _JSONArray_default_instance_;
class LongArray;
struct LongArrayDefaultTypeInternal;
extern LongArrayDefaultTypeInternal _LongArray_default_instance_;
class ScalarClusteringInfo;
struct ScalarClusteringInfoDefaultTypeInternal;
extern ScalarClusteringInfoDefaultTypeInternal _ScalarClusteringInfo_default_instance_;
class ScalarField;
struct ScalarFieldDefaultTypeInternal;
extern ScalarFieldDefaultTypeInternal _ScalarField_default_instance_;
class SearchResultData;
struct SearchResultDataDefaultTypeInternal;
extern SearchResultDataDefaultTypeInternal _SearchResultData_default_instance_;
class StringArray;
struct StringArrayDefaultTypeInternal;
extern StringArrayDefaultTypeInternal _StringArray_default_instance_;
class ValueField;
struct ValueFieldDefaultTypeInternal;
extern ValueFieldDefaultTypeInternal _ValueField_default_instance_;
class VectorClusteringInfo;
struct VectorClusteringInfoDefaultTypeInternal;
extern VectorClusteringInfoDefaultTypeInternal _VectorClusteringInfo_default_instance_;
class VectorField;
struct VectorFieldDefaultTypeInternal;
extern VectorFieldDefaultTypeInternal _VectorField_default_instance_;
}  // namespace schema
}  // namespace proto
}  // namespace milvus
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace milvus {
namespace proto {
namespace schema {
enum DataType : int {
  None = 0,
  Bool = 1,
  Int8 = 2,
  Int16 = 3,
  Int32 = 4,
  Int64 = 5,
  Float = 10,
  Double = 11,
  String = 20,
  VarChar = 21,
  Array = 22,
  JSON = 23,
  BinaryVector = 100,
  FloatVector = 101,
  Float16Vector = 102,
  BFloat16Vector = 103,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DataType_IsValid(int value);
extern const uint32_t DataType_internal_data_[];
constexpr DataType DataType_MIN = static_cast<DataType>(0);
constexpr DataType DataType_MAX = static_cast<DataType>(103);
constexpr int DataType_ARRAYSIZE = 103 + 1;
const ::google::protobuf::EnumDescriptor*
DataType_descriptor();
template <typename T>
const std::string& DataType_Name(T value) {
  static_assert(std::is_same<T, DataType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DataType_Name().");
  return ::google::protobuf::internal::NameOfEnum(DataType_descriptor(), value);
}
inline bool DataType_Parse(absl::string_view name, DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataType>(
      DataType_descriptor(), name, value);
}
enum FieldState : int {
  FieldCreated = 0,
  FieldCreating = 1,
  FieldDropping = 2,
  FieldDropped = 3,
  FieldState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  FieldState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool FieldState_IsValid(int value);
extern const uint32_t FieldState_internal_data_[];
constexpr FieldState FieldState_MIN = static_cast<FieldState>(0);
constexpr FieldState FieldState_MAX = static_cast<FieldState>(3);
constexpr int FieldState_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
FieldState_descriptor();
template <typename T>
const std::string& FieldState_Name(T value) {
  static_assert(std::is_same<T, FieldState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FieldState_Name().");
  return FieldState_Name(static_cast<FieldState>(value));
}
template <>
inline const std::string& FieldState_Name(FieldState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FieldState_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool FieldState_Parse(absl::string_view name, FieldState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FieldState>(
      FieldState_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class ValueField final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.ValueField) */ {
 public:
  inline ValueField() : ValueField(nullptr) {}
  ~ValueField() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValueField(::google::protobuf::internal::ConstantInitialized);

  inline ValueField(const ValueField& from)
      : ValueField(nullptr, from) {}
  ValueField(ValueField&& from) noexcept
    : ValueField() {
    *this = ::std::move(from);
  }

  inline ValueField& operator=(const ValueField& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueField& operator=(ValueField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValueField& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kBoolData = 1,
    kIntData = 2,
    kLongData = 3,
    kFloatData = 4,
    kDoubleData = 5,
    kStringData = 6,
    kBytesData = 7,
    DATA_NOT_SET = 0,
  };

  static inline const ValueField* internal_default_instance() {
    return reinterpret_cast<const ValueField*>(
               &_ValueField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ValueField& a, ValueField& b) {
    a.Swap(&b);
  }
  inline void Swap(ValueField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValueField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValueField>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ValueField& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ValueField& from) {
    ValueField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ValueField* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.ValueField";
  }
  protected:
  explicit ValueField(::google::protobuf::Arena* arena);
  ValueField(::google::protobuf::Arena* arena, const ValueField& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoolDataFieldNumber = 1,
    kIntDataFieldNumber = 2,
    kLongDataFieldNumber = 3,
    kFloatDataFieldNumber = 4,
    kDoubleDataFieldNumber = 5,
    kStringDataFieldNumber = 6,
    kBytesDataFieldNumber = 7,
  };
  // bool bool_data = 1;
  bool has_bool_data() const;
  void clear_bool_data() ;
  bool bool_data() const;
  void set_bool_data(bool value);

  private:
  bool _internal_bool_data() const;
  void _internal_set_bool_data(bool value);

  public:
  // int32 int_data = 2;
  bool has_int_data() const;
  void clear_int_data() ;
  ::int32_t int_data() const;
  void set_int_data(::int32_t value);

  private:
  ::int32_t _internal_int_data() const;
  void _internal_set_int_data(::int32_t value);

  public:
  // int64 long_data = 3;
  bool has_long_data() const;
  void clear_long_data() ;
  ::int64_t long_data() const;
  void set_long_data(::int64_t value);

  private:
  ::int64_t _internal_long_data() const;
  void _internal_set_long_data(::int64_t value);

  public:
  // float float_data = 4;
  bool has_float_data() const;
  void clear_float_data() ;
  float float_data() const;
  void set_float_data(float value);

  private:
  float _internal_float_data() const;
  void _internal_set_float_data(float value);

  public:
  // double double_data = 5;
  bool has_double_data() const;
  void clear_double_data() ;
  double double_data() const;
  void set_double_data(double value);

  private:
  double _internal_double_data() const;
  void _internal_set_double_data(double value);

  public:
  // string string_data = 6;
  bool has_string_data() const;
  void clear_string_data() ;
  const std::string& string_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_string_data(Arg_&& arg, Args_... args);
  std::string* mutable_string_data();
  PROTOBUF_NODISCARD std::string* release_string_data();
  void set_allocated_string_data(std::string* value);

  private:
  const std::string& _internal_string_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_data(
      const std::string& value);
  std::string* _internal_mutable_string_data();

  public:
  // bytes bytes_data = 7;
  bool has_bytes_data() const;
  void clear_bytes_data() ;
  const std::string& bytes_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bytes_data(Arg_&& arg, Args_... args);
  std::string* mutable_bytes_data();
  PROTOBUF_NODISCARD std::string* release_bytes_data();
  void set_allocated_bytes_data(std::string* value);

  private:
  const std::string& _internal_bytes_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bytes_data(
      const std::string& value);
  std::string* _internal_mutable_bytes_data();

  public:
  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.ValueField)
 private:
  class _Internal;
  void set_has_bool_data();
  void set_has_int_data();
  void set_has_long_data();
  void set_has_float_data();
  void set_has_double_data();
  void set_has_string_data();
  void set_has_bytes_data();

  inline bool has_data() const;
  inline void clear_has_data();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 7, 0,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool bool_data_;
      ::int32_t int_data_;
      ::int64_t long_data_;
      float float_data_;
      double double_data_;
      ::google::protobuf::internal::ArenaStringPtr string_data_;
      ::google::protobuf::internal::ArenaStringPtr bytes_data_;
    } data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class StringArray final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.StringArray) */ {
 public:
  inline StringArray() : StringArray(nullptr) {}
  ~StringArray() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StringArray(::google::protobuf::internal::ConstantInitialized);

  inline StringArray(const StringArray& from)
      : StringArray(nullptr, from) {}
  StringArray(StringArray&& from) noexcept
    : StringArray() {
    *this = ::std::move(from);
  }

  inline StringArray& operator=(const StringArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringArray& operator=(StringArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringArray* internal_default_instance() {
    return reinterpret_cast<const StringArray*>(
               &_StringArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StringArray& a, StringArray& b) {
    a.Swap(&b);
  }
  inline void Swap(StringArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringArray* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringArray* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringArray>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StringArray& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StringArray& from) {
    StringArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StringArray* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.StringArray";
  }
  protected:
  explicit StringArray(::google::protobuf::Arena* arena);
  StringArray(::google::protobuf::Arena* arena, const StringArray& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated string data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  const std::string& data(int index) const;
  std::string* mutable_data(int index);
  void set_data(int index, const std::string& value);
  void set_data(int index, std::string&& value);
  void set_data(int index, const char* value);
  void set_data(int index, const char* value, std::size_t size);
  void set_data(int index, absl::string_view value);
  std::string* add_data();
  void add_data(const std::string& value);
  void add_data(std::string&& value);
  void add_data(const char* value);
  void add_data(const char* value, std::size_t size);
  void add_data(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& data() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_data();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_data() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.StringArray)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class ScalarClusteringInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.ScalarClusteringInfo) */ {
 public:
  inline ScalarClusteringInfo() : ScalarClusteringInfo(nullptr) {}
  ~ScalarClusteringInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ScalarClusteringInfo(::google::protobuf::internal::ConstantInitialized);

  inline ScalarClusteringInfo(const ScalarClusteringInfo& from)
      : ScalarClusteringInfo(nullptr, from) {}
  ScalarClusteringInfo(ScalarClusteringInfo&& from) noexcept
    : ScalarClusteringInfo() {
    *this = ::std::move(from);
  }

  inline ScalarClusteringInfo& operator=(const ScalarClusteringInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScalarClusteringInfo& operator=(ScalarClusteringInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScalarClusteringInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScalarClusteringInfo* internal_default_instance() {
    return reinterpret_cast<const ScalarClusteringInfo*>(
               &_ScalarClusteringInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ScalarClusteringInfo& a, ScalarClusteringInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ScalarClusteringInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScalarClusteringInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScalarClusteringInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScalarClusteringInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ScalarClusteringInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ScalarClusteringInfo& from) {
    ScalarClusteringInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ScalarClusteringInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.ScalarClusteringInfo";
  }
  protected:
  explicit ScalarClusteringInfo(::google::protobuf::Arena* arena);
  ScalarClusteringInfo(::google::protobuf::Arena* arena, const ScalarClusteringInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
  };
  // string field = 1;
  void clear_field() ;
  const std::string& field() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_field(Arg_&& arg, Args_... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* value);

  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(
      const std::string& value);
  std::string* _internal_mutable_field();

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.ScalarClusteringInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr field_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class LongArray final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.LongArray) */ {
 public:
  inline LongArray() : LongArray(nullptr) {}
  ~LongArray() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LongArray(::google::protobuf::internal::ConstantInitialized);

  inline LongArray(const LongArray& from)
      : LongArray(nullptr, from) {}
  LongArray(LongArray&& from) noexcept
    : LongArray() {
    *this = ::std::move(from);
  }

  inline LongArray& operator=(const LongArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongArray& operator=(LongArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LongArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const LongArray* internal_default_instance() {
    return reinterpret_cast<const LongArray*>(
               &_LongArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LongArray& a, LongArray& b) {
    a.Swap(&b);
  }
  inline void Swap(LongArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongArray* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LongArray* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LongArray>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LongArray& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LongArray& from) {
    LongArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LongArray* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.LongArray";
  }
  protected:
  explicit LongArray(::google::protobuf::Arena* arena);
  LongArray(::google::protobuf::Arena* arena, const LongArray& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated int64 data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::int64_t data(int index) const;
  void set_data(int index, ::int64_t value);
  void add_data(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& data() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_data();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_data() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.LongArray)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::int64_t> data_;
    mutable ::google::protobuf::internal::CachedSize _data_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class JSONArray final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.JSONArray) */ {
 public:
  inline JSONArray() : JSONArray(nullptr) {}
  ~JSONArray() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR JSONArray(::google::protobuf::internal::ConstantInitialized);

  inline JSONArray(const JSONArray& from)
      : JSONArray(nullptr, from) {}
  JSONArray(JSONArray&& from) noexcept
    : JSONArray() {
    *this = ::std::move(from);
  }

  inline JSONArray& operator=(const JSONArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline JSONArray& operator=(JSONArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JSONArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const JSONArray* internal_default_instance() {
    return reinterpret_cast<const JSONArray*>(
               &_JSONArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(JSONArray& a, JSONArray& b) {
    a.Swap(&b);
  }
  inline void Swap(JSONArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JSONArray* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JSONArray* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JSONArray>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JSONArray& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const JSONArray& from) {
    JSONArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(JSONArray* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.JSONArray";
  }
  protected:
  explicit JSONArray(::google::protobuf::Arena* arena);
  JSONArray(::google::protobuf::Arena* arena, const JSONArray& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated bytes data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  const std::string& data(int index) const;
  std::string* mutable_data(int index);
  void set_data(int index, const std::string& value);
  void set_data(int index, std::string&& value);
  void set_data(int index, const char* value);
  void set_data(int index, const void* value, std::size_t size);
  void set_data(int index, absl::string_view value);
  std::string* add_data();
  void add_data(const std::string& value);
  void add_data(std::string&& value);
  void add_data(const char* value);
  void add_data(const void* value, std::size_t size);
  void add_data(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& data() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_data();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_data() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.JSONArray)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class IntArray final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.IntArray) */ {
 public:
  inline IntArray() : IntArray(nullptr) {}
  ~IntArray() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IntArray(::google::protobuf::internal::ConstantInitialized);

  inline IntArray(const IntArray& from)
      : IntArray(nullptr, from) {}
  IntArray(IntArray&& from) noexcept
    : IntArray() {
    *this = ::std::move(from);
  }

  inline IntArray& operator=(const IntArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntArray& operator=(IntArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntArray* internal_default_instance() {
    return reinterpret_cast<const IntArray*>(
               &_IntArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(IntArray& a, IntArray& b) {
    a.Swap(&b);
  }
  inline void Swap(IntArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntArray* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntArray* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntArray>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IntArray& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const IntArray& from) {
    IntArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IntArray* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.IntArray";
  }
  protected:
  explicit IntArray(::google::protobuf::Arena* arena);
  IntArray(::google::protobuf::Arena* arena, const IntArray& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated int32 data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::int32_t data(int index) const;
  void set_data(int index, ::int32_t value);
  void add_data(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& data() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_data();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_data() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.IntArray)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::int32_t> data_;
    mutable ::google::protobuf::internal::CachedSize _data_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class FloatArray final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.FloatArray) */ {
 public:
  inline FloatArray() : FloatArray(nullptr) {}
  ~FloatArray() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FloatArray(::google::protobuf::internal::ConstantInitialized);

  inline FloatArray(const FloatArray& from)
      : FloatArray(nullptr, from) {}
  FloatArray(FloatArray&& from) noexcept
    : FloatArray() {
    *this = ::std::move(from);
  }

  inline FloatArray& operator=(const FloatArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatArray& operator=(FloatArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloatArray* internal_default_instance() {
    return reinterpret_cast<const FloatArray*>(
               &_FloatArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FloatArray& a, FloatArray& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatArray* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloatArray* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FloatArray>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FloatArray& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FloatArray& from) {
    FloatArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FloatArray* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.FloatArray";
  }
  protected:
  explicit FloatArray(::google::protobuf::Arena* arena);
  FloatArray(::google::protobuf::Arena* arena, const FloatArray& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated float data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::google::protobuf::RepeatedField<float>& data() const;
  ::google::protobuf::RepeatedField<float>* mutable_data();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_data() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.FloatArray)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<float> data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class DoubleArray final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.DoubleArray) */ {
 public:
  inline DoubleArray() : DoubleArray(nullptr) {}
  ~DoubleArray() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DoubleArray(::google::protobuf::internal::ConstantInitialized);

  inline DoubleArray(const DoubleArray& from)
      : DoubleArray(nullptr, from) {}
  DoubleArray(DoubleArray&& from) noexcept
    : DoubleArray() {
    *this = ::std::move(from);
  }

  inline DoubleArray& operator=(const DoubleArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleArray& operator=(DoubleArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoubleArray* internal_default_instance() {
    return reinterpret_cast<const DoubleArray*>(
               &_DoubleArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DoubleArray& a, DoubleArray& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleArray* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleArray* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleArray>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DoubleArray& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DoubleArray& from) {
    DoubleArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DoubleArray* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.DoubleArray";
  }
  protected:
  explicit DoubleArray(::google::protobuf::Arena* arena);
  DoubleArray(::google::protobuf::Arena* arena, const DoubleArray& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated double data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::google::protobuf::RepeatedField<double>& data() const;
  ::google::protobuf::RepeatedField<double>* mutable_data();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_data() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.DoubleArray)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<double> data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class BytesArray final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.BytesArray) */ {
 public:
  inline BytesArray() : BytesArray(nullptr) {}
  ~BytesArray() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BytesArray(::google::protobuf::internal::ConstantInitialized);

  inline BytesArray(const BytesArray& from)
      : BytesArray(nullptr, from) {}
  BytesArray(BytesArray&& from) noexcept
    : BytesArray() {
    *this = ::std::move(from);
  }

  inline BytesArray& operator=(const BytesArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline BytesArray& operator=(BytesArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BytesArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const BytesArray* internal_default_instance() {
    return reinterpret_cast<const BytesArray*>(
               &_BytesArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BytesArray& a, BytesArray& b) {
    a.Swap(&b);
  }
  inline void Swap(BytesArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BytesArray* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BytesArray* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BytesArray>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BytesArray& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BytesArray& from) {
    BytesArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BytesArray* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.BytesArray";
  }
  protected:
  explicit BytesArray(::google::protobuf::Arena* arena);
  BytesArray(::google::protobuf::Arena* arena, const BytesArray& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated bytes data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  const std::string& data(int index) const;
  std::string* mutable_data(int index);
  void set_data(int index, const std::string& value);
  void set_data(int index, std::string&& value);
  void set_data(int index, const char* value);
  void set_data(int index, const void* value, std::size_t size);
  void set_data(int index, absl::string_view value);
  std::string* add_data();
  void add_data(const std::string& value);
  void add_data(std::string&& value);
  void add_data(const char* value);
  void add_data(const void* value, std::size_t size);
  void add_data(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& data() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_data();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_data() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.BytesArray)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class BoolArray final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.BoolArray) */ {
 public:
  inline BoolArray() : BoolArray(nullptr) {}
  ~BoolArray() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BoolArray(::google::protobuf::internal::ConstantInitialized);

  inline BoolArray(const BoolArray& from)
      : BoolArray(nullptr, from) {}
  BoolArray(BoolArray&& from) noexcept
    : BoolArray() {
    *this = ::std::move(from);
  }

  inline BoolArray& operator=(const BoolArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolArray& operator=(BoolArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolArray* internal_default_instance() {
    return reinterpret_cast<const BoolArray*>(
               &_BoolArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BoolArray& a, BoolArray& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolArray* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolArray* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolArray>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BoolArray& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BoolArray& from) {
    BoolArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BoolArray* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.BoolArray";
  }
  protected:
  explicit BoolArray(::google::protobuf::Arena* arena);
  BoolArray(::google::protobuf::Arena* arena, const BoolArray& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated bool data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  bool data(int index) const;
  void set_data(int index, bool value);
  void add_data(bool value);
  const ::google::protobuf::RepeatedField<bool>& data() const;
  ::google::protobuf::RepeatedField<bool>* mutable_data();

  private:
  const ::google::protobuf::RepeatedField<bool>& _internal_data() const;
  ::google::protobuf::RepeatedField<bool>* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.BoolArray)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<bool> data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class VectorField final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.VectorField) */ {
 public:
  inline VectorField() : VectorField(nullptr) {}
  ~VectorField() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorField(::google::protobuf::internal::ConstantInitialized);

  inline VectorField(const VectorField& from)
      : VectorField(nullptr, from) {}
  VectorField(VectorField&& from) noexcept
    : VectorField() {
    *this = ::std::move(from);
  }

  inline VectorField& operator=(const VectorField& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorField& operator=(VectorField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorField& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kFloatVector = 2,
    kBinaryVector = 3,
    kFloat16Vector = 4,
    kBfloat16Vector = 5,
    DATA_NOT_SET = 0,
  };

  static inline const VectorField* internal_default_instance() {
    return reinterpret_cast<const VectorField*>(
               &_VectorField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(VectorField& a, VectorField& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorField>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorField& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorField& from) {
    VectorField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorField* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.VectorField";
  }
  protected:
  explicit VectorField(::google::protobuf::Arena* arena);
  VectorField(::google::protobuf::Arena* arena, const VectorField& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimFieldNumber = 1,
    kFloatVectorFieldNumber = 2,
    kBinaryVectorFieldNumber = 3,
    kFloat16VectorFieldNumber = 4,
    kBfloat16VectorFieldNumber = 5,
  };
  // int64 dim = 1;
  void clear_dim() ;
  ::int64_t dim() const;
  void set_dim(::int64_t value);

  private:
  ::int64_t _internal_dim() const;
  void _internal_set_dim(::int64_t value);

  public:
  // .milvus.proto.schema.FloatArray float_vector = 2;
  bool has_float_vector() const;
  private:
  bool _internal_has_float_vector() const;

  public:
  void clear_float_vector() ;
  const ::milvus::proto::schema::FloatArray& float_vector() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::FloatArray* release_float_vector();
  ::milvus::proto::schema::FloatArray* mutable_float_vector();
  void set_allocated_float_vector(::milvus::proto::schema::FloatArray* value);
  void unsafe_arena_set_allocated_float_vector(::milvus::proto::schema::FloatArray* value);
  ::milvus::proto::schema::FloatArray* unsafe_arena_release_float_vector();

  private:
  const ::milvus::proto::schema::FloatArray& _internal_float_vector() const;
  ::milvus::proto::schema::FloatArray* _internal_mutable_float_vector();

  public:
  // bytes binary_vector = 3;
  bool has_binary_vector() const;
  void clear_binary_vector() ;
  const std::string& binary_vector() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_binary_vector(Arg_&& arg, Args_... args);
  std::string* mutable_binary_vector();
  PROTOBUF_NODISCARD std::string* release_binary_vector();
  void set_allocated_binary_vector(std::string* value);

  private:
  const std::string& _internal_binary_vector() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary_vector(
      const std::string& value);
  std::string* _internal_mutable_binary_vector();

  public:
  // bytes float16_vector = 4;
  bool has_float16_vector() const;
  void clear_float16_vector() ;
  const std::string& float16_vector() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_float16_vector(Arg_&& arg, Args_... args);
  std::string* mutable_float16_vector();
  PROTOBUF_NODISCARD std::string* release_float16_vector();
  void set_allocated_float16_vector(std::string* value);

  private:
  const std::string& _internal_float16_vector() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_float16_vector(
      const std::string& value);
  std::string* _internal_mutable_float16_vector();

  public:
  // bytes bfloat16_vector = 5;
  bool has_bfloat16_vector() const;
  void clear_bfloat16_vector() ;
  const std::string& bfloat16_vector() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bfloat16_vector(Arg_&& arg, Args_... args);
  std::string* mutable_bfloat16_vector();
  PROTOBUF_NODISCARD std::string* release_bfloat16_vector();
  void set_allocated_bfloat16_vector(std::string* value);

  private:
  const std::string& _internal_bfloat16_vector() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bfloat16_vector(
      const std::string& value);
  std::string* _internal_mutable_bfloat16_vector();

  public:
  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.VectorField)
 private:
  class _Internal;
  void set_has_float_vector();
  void set_has_binary_vector();
  void set_has_float16_vector();
  void set_has_bfloat16_vector();

  inline bool has_data() const;
  inline void clear_has_data();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t dim_;
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::milvus::proto::schema::FloatArray* float_vector_;
      ::google::protobuf::internal::ArenaStringPtr binary_vector_;
      ::google::protobuf::internal::ArenaStringPtr float16_vector_;
      ::google::protobuf::internal::ArenaStringPtr bfloat16_vector_;
    } data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class IDs final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.IDs) */ {
 public:
  inline IDs() : IDs(nullptr) {}
  ~IDs() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IDs(::google::protobuf::internal::ConstantInitialized);

  inline IDs(const IDs& from)
      : IDs(nullptr, from) {}
  IDs(IDs&& from) noexcept
    : IDs() {
    *this = ::std::move(from);
  }

  inline IDs& operator=(const IDs& from) {
    CopyFrom(from);
    return *this;
  }
  inline IDs& operator=(IDs&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IDs& default_instance() {
    return *internal_default_instance();
  }
  enum IdFieldCase {
    kIntId = 1,
    kStrId = 2,
    ID_FIELD_NOT_SET = 0,
  };

  static inline const IDs* internal_default_instance() {
    return reinterpret_cast<const IDs*>(
               &_IDs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(IDs& a, IDs& b) {
    a.Swap(&b);
  }
  inline void Swap(IDs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IDs* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IDs* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IDs>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IDs& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const IDs& from) {
    IDs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IDs* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.IDs";
  }
  protected:
  explicit IDs(::google::protobuf::Arena* arena);
  IDs(::google::protobuf::Arena* arena, const IDs& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntIdFieldNumber = 1,
    kStrIdFieldNumber = 2,
  };
  // .milvus.proto.schema.LongArray int_id = 1;
  bool has_int_id() const;
  private:
  bool _internal_has_int_id() const;

  public:
  void clear_int_id() ;
  const ::milvus::proto::schema::LongArray& int_id() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::LongArray* release_int_id();
  ::milvus::proto::schema::LongArray* mutable_int_id();
  void set_allocated_int_id(::milvus::proto::schema::LongArray* value);
  void unsafe_arena_set_allocated_int_id(::milvus::proto::schema::LongArray* value);
  ::milvus::proto::schema::LongArray* unsafe_arena_release_int_id();

  private:
  const ::milvus::proto::schema::LongArray& _internal_int_id() const;
  ::milvus::proto::schema::LongArray* _internal_mutable_int_id();

  public:
  // .milvus.proto.schema.StringArray str_id = 2;
  bool has_str_id() const;
  private:
  bool _internal_has_str_id() const;

  public:
  void clear_str_id() ;
  const ::milvus::proto::schema::StringArray& str_id() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::StringArray* release_str_id();
  ::milvus::proto::schema::StringArray* mutable_str_id();
  void set_allocated_str_id(::milvus::proto::schema::StringArray* value);
  void unsafe_arena_set_allocated_str_id(::milvus::proto::schema::StringArray* value);
  ::milvus::proto::schema::StringArray* unsafe_arena_release_str_id();

  private:
  const ::milvus::proto::schema::StringArray& _internal_str_id() const;
  ::milvus::proto::schema::StringArray* _internal_mutable_str_id();

  public:
  void clear_id_field();
  IdFieldCase id_field_case() const;
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.IDs)
 private:
  class _Internal;
  void set_has_int_id();
  void set_has_str_id();

  inline bool has_id_field() const;
  inline void clear_has_id_field();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union IdFieldUnion {
      constexpr IdFieldUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::milvus::proto::schema::LongArray* int_id_;
      ::milvus::proto::schema::StringArray* str_id_;
    } id_field_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class FieldSchema final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.FieldSchema) */ {
 public:
  inline FieldSchema() : FieldSchema(nullptr) {}
  ~FieldSchema() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FieldSchema(::google::protobuf::internal::ConstantInitialized);

  inline FieldSchema(const FieldSchema& from)
      : FieldSchema(nullptr, from) {}
  FieldSchema(FieldSchema&& from) noexcept
    : FieldSchema() {
    *this = ::std::move(from);
  }

  inline FieldSchema& operator=(const FieldSchema& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldSchema& operator=(FieldSchema&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldSchema& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldSchema* internal_default_instance() {
    return reinterpret_cast<const FieldSchema*>(
               &_FieldSchema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FieldSchema& a, FieldSchema& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldSchema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldSchema* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldSchema* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FieldSchema>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FieldSchema& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FieldSchema& from) {
    FieldSchema::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FieldSchema* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.FieldSchema";
  }
  protected:
  explicit FieldSchema(::google::protobuf::Arena* arena);
  FieldSchema(::google::protobuf::Arena* arena, const FieldSchema& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeParamsFieldNumber = 6,
    kIndexParamsFieldNumber = 7,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 4,
    kDefaultValueFieldNumber = 11,
    kFieldIDFieldNumber = 1,
    kDataTypeFieldNumber = 5,
    kStateFieldNumber = 9,
    kIsPrimaryKeyFieldNumber = 3,
    kAutoIDFieldNumber = 8,
    kIsDynamicFieldNumber = 12,
    kIsPartitionKeyFieldNumber = 13,
    kElementTypeFieldNumber = 10,
    kIsClusteringKeyFieldNumber = 14,
  };
  // repeated .milvus.proto.common.KeyValuePair type_params = 6;
  int type_params_size() const;
  private:
  int _internal_type_params_size() const;

  public:
  void clear_type_params() ;
  ::milvus::proto::common::KeyValuePair* mutable_type_params(int index);
  ::google::protobuf::RepeatedPtrField< ::milvus::proto::common::KeyValuePair >*
      mutable_type_params();
  private:
  const ::google::protobuf::RepeatedPtrField<::milvus::proto::common::KeyValuePair>& _internal_type_params() const;
  ::google::protobuf::RepeatedPtrField<::milvus::proto::common::KeyValuePair>* _internal_mutable_type_params();
  public:
  const ::milvus::proto::common::KeyValuePair& type_params(int index) const;
  ::milvus::proto::common::KeyValuePair* add_type_params();
  const ::google::protobuf::RepeatedPtrField< ::milvus::proto::common::KeyValuePair >&
      type_params() const;
  // repeated .milvus.proto.common.KeyValuePair index_params = 7;
  int index_params_size() const;
  private:
  int _internal_index_params_size() const;

  public:
  void clear_index_params() ;
  ::milvus::proto::common::KeyValuePair* mutable_index_params(int index);
  ::google::protobuf::RepeatedPtrField< ::milvus::proto::common::KeyValuePair >*
      mutable_index_params();
  private:
  const ::google::protobuf::RepeatedPtrField<::milvus::proto::common::KeyValuePair>& _internal_index_params() const;
  ::google::protobuf::RepeatedPtrField<::milvus::proto::common::KeyValuePair>* _internal_mutable_index_params();
  public:
  const ::milvus::proto::common::KeyValuePair& index_params(int index) const;
  ::milvus::proto::common::KeyValuePair* add_index_params();
  const ::google::protobuf::RepeatedPtrField< ::milvus::proto::common::KeyValuePair >&
      index_params() const;
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string description = 4;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .milvus.proto.schema.ValueField default_value = 11;
  bool has_default_value() const;
  void clear_default_value() ;
  const ::milvus::proto::schema::ValueField& default_value() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::ValueField* release_default_value();
  ::milvus::proto::schema::ValueField* mutable_default_value();
  void set_allocated_default_value(::milvus::proto::schema::ValueField* value);
  void unsafe_arena_set_allocated_default_value(::milvus::proto::schema::ValueField* value);
  ::milvus::proto::schema::ValueField* unsafe_arena_release_default_value();

  private:
  const ::milvus::proto::schema::ValueField& _internal_default_value() const;
  ::milvus::proto::schema::ValueField* _internal_mutable_default_value();

  public:
  // int64 fieldID = 1;
  void clear_fieldid() ;
  ::int64_t fieldid() const;
  void set_fieldid(::int64_t value);

  private:
  ::int64_t _internal_fieldid() const;
  void _internal_set_fieldid(::int64_t value);

  public:
  // .milvus.proto.schema.DataType data_type = 5;
  void clear_data_type() ;
  ::milvus::proto::schema::DataType data_type() const;
  void set_data_type(::milvus::proto::schema::DataType value);

  private:
  ::milvus::proto::schema::DataType _internal_data_type() const;
  void _internal_set_data_type(::milvus::proto::schema::DataType value);

  public:
  // .milvus.proto.schema.FieldState state = 9;
  void clear_state() ;
  ::milvus::proto::schema::FieldState state() const;
  void set_state(::milvus::proto::schema::FieldState value);

  private:
  ::milvus::proto::schema::FieldState _internal_state() const;
  void _internal_set_state(::milvus::proto::schema::FieldState value);

  public:
  // bool is_primary_key = 3;
  void clear_is_primary_key() ;
  bool is_primary_key() const;
  void set_is_primary_key(bool value);

  private:
  bool _internal_is_primary_key() const;
  void _internal_set_is_primary_key(bool value);

  public:
  // bool autoID = 8;
  void clear_autoid() ;
  bool autoid() const;
  void set_autoid(bool value);

  private:
  bool _internal_autoid() const;
  void _internal_set_autoid(bool value);

  public:
  // bool is_dynamic = 12;
  void clear_is_dynamic() ;
  bool is_dynamic() const;
  void set_is_dynamic(bool value);

  private:
  bool _internal_is_dynamic() const;
  void _internal_set_is_dynamic(bool value);

  public:
  // bool is_partition_key = 13;
  void clear_is_partition_key() ;
  bool is_partition_key() const;
  void set_is_partition_key(bool value);

  private:
  bool _internal_is_partition_key() const;
  void _internal_set_is_partition_key(bool value);

  public:
  // .milvus.proto.schema.DataType element_type = 10;
  void clear_element_type() ;
  ::milvus::proto::schema::DataType element_type() const;
  void set_element_type(::milvus::proto::schema::DataType value);

  private:
  ::milvus::proto::schema::DataType _internal_element_type() const;
  void _internal_set_element_type(::milvus::proto::schema::DataType value);

  public:
  // bool is_clustering_key = 14;
  void clear_is_clustering_key() ;
  bool is_clustering_key() const;
  void set_is_clustering_key(bool value);

  private:
  bool _internal_is_clustering_key() const;
  void _internal_set_is_clustering_key(bool value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.FieldSchema)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 3,
      63, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::milvus::proto::common::KeyValuePair > type_params_;
    ::google::protobuf::RepeatedPtrField< ::milvus::proto::common::KeyValuePair > index_params_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::milvus::proto::schema::ValueField* default_value_;
    ::int64_t fieldid_;
    int data_type_;
    int state_;
    bool is_primary_key_;
    bool autoid_;
    bool is_dynamic_;
    bool is_partition_key_;
    int element_type_;
    bool is_clustering_key_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class ArrayArray final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.ArrayArray) */ {
 public:
  inline ArrayArray() : ArrayArray(nullptr) {}
  ~ArrayArray() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ArrayArray(::google::protobuf::internal::ConstantInitialized);

  inline ArrayArray(const ArrayArray& from)
      : ArrayArray(nullptr, from) {}
  ArrayArray(ArrayArray&& from) noexcept
    : ArrayArray() {
    *this = ::std::move(from);
  }

  inline ArrayArray& operator=(const ArrayArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArrayArray& operator=(ArrayArray&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArrayArray& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArrayArray* internal_default_instance() {
    return reinterpret_cast<const ArrayArray*>(
               &_ArrayArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ArrayArray& a, ArrayArray& b) {
    a.Swap(&b);
  }
  inline void Swap(ArrayArray* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArrayArray* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArrayArray* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArrayArray>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ArrayArray& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ArrayArray& from) {
    ArrayArray::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ArrayArray* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.ArrayArray";
  }
  protected:
  explicit ArrayArray(::google::protobuf::Arena* arena);
  ArrayArray(::google::protobuf::Arena* arena, const ArrayArray& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kElementTypeFieldNumber = 2,
  };
  // repeated .milvus.proto.schema.ScalarField data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::milvus::proto::schema::ScalarField* mutable_data(int index);
  ::google::protobuf::RepeatedPtrField< ::milvus::proto::schema::ScalarField >*
      mutable_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::ScalarField>& _internal_data() const;
  ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::ScalarField>* _internal_mutable_data();
  public:
  const ::milvus::proto::schema::ScalarField& data(int index) const;
  ::milvus::proto::schema::ScalarField* add_data();
  const ::google::protobuf::RepeatedPtrField< ::milvus::proto::schema::ScalarField >&
      data() const;
  // .milvus.proto.schema.DataType element_type = 2;
  void clear_element_type() ;
  ::milvus::proto::schema::DataType element_type() const;
  void set_element_type(::milvus::proto::schema::DataType value);

  private:
  ::milvus::proto::schema::DataType _internal_element_type() const;
  void _internal_set_element_type(::milvus::proto::schema::DataType value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.ArrayArray)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::milvus::proto::schema::ScalarField > data_;
    int element_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class ScalarField final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.ScalarField) */ {
 public:
  inline ScalarField() : ScalarField(nullptr) {}
  ~ScalarField() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ScalarField(::google::protobuf::internal::ConstantInitialized);

  inline ScalarField(const ScalarField& from)
      : ScalarField(nullptr, from) {}
  ScalarField(ScalarField&& from) noexcept
    : ScalarField() {
    *this = ::std::move(from);
  }

  inline ScalarField& operator=(const ScalarField& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScalarField& operator=(ScalarField&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScalarField& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kBoolData = 1,
    kIntData = 2,
    kLongData = 3,
    kFloatData = 4,
    kDoubleData = 5,
    kStringData = 6,
    kBytesData = 7,
    kArrayData = 8,
    kJsonData = 9,
    DATA_NOT_SET = 0,
  };

  static inline const ScalarField* internal_default_instance() {
    return reinterpret_cast<const ScalarField*>(
               &_ScalarField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ScalarField& a, ScalarField& b) {
    a.Swap(&b);
  }
  inline void Swap(ScalarField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScalarField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScalarField* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScalarField>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ScalarField& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ScalarField& from) {
    ScalarField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ScalarField* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.ScalarField";
  }
  protected:
  explicit ScalarField(::google::protobuf::Arena* arena);
  ScalarField(::google::protobuf::Arena* arena, const ScalarField& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoolDataFieldNumber = 1,
    kIntDataFieldNumber = 2,
    kLongDataFieldNumber = 3,
    kFloatDataFieldNumber = 4,
    kDoubleDataFieldNumber = 5,
    kStringDataFieldNumber = 6,
    kBytesDataFieldNumber = 7,
    kArrayDataFieldNumber = 8,
    kJsonDataFieldNumber = 9,
  };
  // .milvus.proto.schema.BoolArray bool_data = 1;
  bool has_bool_data() const;
  private:
  bool _internal_has_bool_data() const;

  public:
  void clear_bool_data() ;
  const ::milvus::proto::schema::BoolArray& bool_data() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::BoolArray* release_bool_data();
  ::milvus::proto::schema::BoolArray* mutable_bool_data();
  void set_allocated_bool_data(::milvus::proto::schema::BoolArray* value);
  void unsafe_arena_set_allocated_bool_data(::milvus::proto::schema::BoolArray* value);
  ::milvus::proto::schema::BoolArray* unsafe_arena_release_bool_data();

  private:
  const ::milvus::proto::schema::BoolArray& _internal_bool_data() const;
  ::milvus::proto::schema::BoolArray* _internal_mutable_bool_data();

  public:
  // .milvus.proto.schema.IntArray int_data = 2;
  bool has_int_data() const;
  private:
  bool _internal_has_int_data() const;

  public:
  void clear_int_data() ;
  const ::milvus::proto::schema::IntArray& int_data() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::IntArray* release_int_data();
  ::milvus::proto::schema::IntArray* mutable_int_data();
  void set_allocated_int_data(::milvus::proto::schema::IntArray* value);
  void unsafe_arena_set_allocated_int_data(::milvus::proto::schema::IntArray* value);
  ::milvus::proto::schema::IntArray* unsafe_arena_release_int_data();

  private:
  const ::milvus::proto::schema::IntArray& _internal_int_data() const;
  ::milvus::proto::schema::IntArray* _internal_mutable_int_data();

  public:
  // .milvus.proto.schema.LongArray long_data = 3;
  bool has_long_data() const;
  private:
  bool _internal_has_long_data() const;

  public:
  void clear_long_data() ;
  const ::milvus::proto::schema::LongArray& long_data() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::LongArray* release_long_data();
  ::milvus::proto::schema::LongArray* mutable_long_data();
  void set_allocated_long_data(::milvus::proto::schema::LongArray* value);
  void unsafe_arena_set_allocated_long_data(::milvus::proto::schema::LongArray* value);
  ::milvus::proto::schema::LongArray* unsafe_arena_release_long_data();

  private:
  const ::milvus::proto::schema::LongArray& _internal_long_data() const;
  ::milvus::proto::schema::LongArray* _internal_mutable_long_data();

  public:
  // .milvus.proto.schema.FloatArray float_data = 4;
  bool has_float_data() const;
  private:
  bool _internal_has_float_data() const;

  public:
  void clear_float_data() ;
  const ::milvus::proto::schema::FloatArray& float_data() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::FloatArray* release_float_data();
  ::milvus::proto::schema::FloatArray* mutable_float_data();
  void set_allocated_float_data(::milvus::proto::schema::FloatArray* value);
  void unsafe_arena_set_allocated_float_data(::milvus::proto::schema::FloatArray* value);
  ::milvus::proto::schema::FloatArray* unsafe_arena_release_float_data();

  private:
  const ::milvus::proto::schema::FloatArray& _internal_float_data() const;
  ::milvus::proto::schema::FloatArray* _internal_mutable_float_data();

  public:
  // .milvus.proto.schema.DoubleArray double_data = 5;
  bool has_double_data() const;
  private:
  bool _internal_has_double_data() const;

  public:
  void clear_double_data() ;
  const ::milvus::proto::schema::DoubleArray& double_data() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::DoubleArray* release_double_data();
  ::milvus::proto::schema::DoubleArray* mutable_double_data();
  void set_allocated_double_data(::milvus::proto::schema::DoubleArray* value);
  void unsafe_arena_set_allocated_double_data(::milvus::proto::schema::DoubleArray* value);
  ::milvus::proto::schema::DoubleArray* unsafe_arena_release_double_data();

  private:
  const ::milvus::proto::schema::DoubleArray& _internal_double_data() const;
  ::milvus::proto::schema::DoubleArray* _internal_mutable_double_data();

  public:
  // .milvus.proto.schema.StringArray string_data = 6;
  bool has_string_data() const;
  private:
  bool _internal_has_string_data() const;

  public:
  void clear_string_data() ;
  const ::milvus::proto::schema::StringArray& string_data() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::StringArray* release_string_data();
  ::milvus::proto::schema::StringArray* mutable_string_data();
  void set_allocated_string_data(::milvus::proto::schema::StringArray* value);
  void unsafe_arena_set_allocated_string_data(::milvus::proto::schema::StringArray* value);
  ::milvus::proto::schema::StringArray* unsafe_arena_release_string_data();

  private:
  const ::milvus::proto::schema::StringArray& _internal_string_data() const;
  ::milvus::proto::schema::StringArray* _internal_mutable_string_data();

  public:
  // .milvus.proto.schema.BytesArray bytes_data = 7;
  bool has_bytes_data() const;
  private:
  bool _internal_has_bytes_data() const;

  public:
  void clear_bytes_data() ;
  const ::milvus::proto::schema::BytesArray& bytes_data() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::BytesArray* release_bytes_data();
  ::milvus::proto::schema::BytesArray* mutable_bytes_data();
  void set_allocated_bytes_data(::milvus::proto::schema::BytesArray* value);
  void unsafe_arena_set_allocated_bytes_data(::milvus::proto::schema::BytesArray* value);
  ::milvus::proto::schema::BytesArray* unsafe_arena_release_bytes_data();

  private:
  const ::milvus::proto::schema::BytesArray& _internal_bytes_data() const;
  ::milvus::proto::schema::BytesArray* _internal_mutable_bytes_data();

  public:
  // .milvus.proto.schema.ArrayArray array_data = 8;
  bool has_array_data() const;
  private:
  bool _internal_has_array_data() const;

  public:
  void clear_array_data() ;
  const ::milvus::proto::schema::ArrayArray& array_data() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::ArrayArray* release_array_data();
  ::milvus::proto::schema::ArrayArray* mutable_array_data();
  void set_allocated_array_data(::milvus::proto::schema::ArrayArray* value);
  void unsafe_arena_set_allocated_array_data(::milvus::proto::schema::ArrayArray* value);
  ::milvus::proto::schema::ArrayArray* unsafe_arena_release_array_data();

  private:
  const ::milvus::proto::schema::ArrayArray& _internal_array_data() const;
  ::milvus::proto::schema::ArrayArray* _internal_mutable_array_data();

  public:
  // .milvus.proto.schema.JSONArray json_data = 9;
  bool has_json_data() const;
  private:
  bool _internal_has_json_data() const;

  public:
  void clear_json_data() ;
  const ::milvus::proto::schema::JSONArray& json_data() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::JSONArray* release_json_data();
  ::milvus::proto::schema::JSONArray* mutable_json_data();
  void set_allocated_json_data(::milvus::proto::schema::JSONArray* value);
  void unsafe_arena_set_allocated_json_data(::milvus::proto::schema::JSONArray* value);
  ::milvus::proto::schema::JSONArray* unsafe_arena_release_json_data();

  private:
  const ::milvus::proto::schema::JSONArray& _internal_json_data() const;
  ::milvus::proto::schema::JSONArray* _internal_mutable_json_data();

  public:
  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.ScalarField)
 private:
  class _Internal;
  void set_has_bool_data();
  void set_has_int_data();
  void set_has_long_data();
  void set_has_float_data();
  void set_has_double_data();
  void set_has_string_data();
  void set_has_bytes_data();
  void set_has_array_data();
  void set_has_json_data();

  inline bool has_data() const;
  inline void clear_has_data();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 9, 9,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::milvus::proto::schema::BoolArray* bool_data_;
      ::milvus::proto::schema::IntArray* int_data_;
      ::milvus::proto::schema::LongArray* long_data_;
      ::milvus::proto::schema::FloatArray* float_data_;
      ::milvus::proto::schema::DoubleArray* double_data_;
      ::milvus::proto::schema::StringArray* string_data_;
      ::milvus::proto::schema::BytesArray* bytes_data_;
      ::milvus::proto::schema::ArrayArray* array_data_;
      ::milvus::proto::schema::JSONArray* json_data_;
    } data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class VectorClusteringInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.VectorClusteringInfo) */ {
 public:
  inline VectorClusteringInfo() : VectorClusteringInfo(nullptr) {}
  ~VectorClusteringInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VectorClusteringInfo(::google::protobuf::internal::ConstantInitialized);

  inline VectorClusteringInfo(const VectorClusteringInfo& from)
      : VectorClusteringInfo(nullptr, from) {}
  VectorClusteringInfo(VectorClusteringInfo&& from) noexcept
    : VectorClusteringInfo() {
    *this = ::std::move(from);
  }

  inline VectorClusteringInfo& operator=(const VectorClusteringInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorClusteringInfo& operator=(VectorClusteringInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorClusteringInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorClusteringInfo* internal_default_instance() {
    return reinterpret_cast<const VectorClusteringInfo*>(
               &_VectorClusteringInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(VectorClusteringInfo& a, VectorClusteringInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorClusteringInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorClusteringInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorClusteringInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorClusteringInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VectorClusteringInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VectorClusteringInfo& from) {
    VectorClusteringInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VectorClusteringInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.VectorClusteringInfo";
  }
  protected:
  explicit VectorClusteringInfo(::google::protobuf::Arena* arena);
  VectorClusteringInfo(::google::protobuf::Arena* arena, const VectorClusteringInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
    kCentroidFieldNumber = 2,
  };
  // string field = 1;
  void clear_field() ;
  const std::string& field() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_field(Arg_&& arg, Args_... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* value);

  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(
      const std::string& value);
  std::string* _internal_mutable_field();

  public:
  // .milvus.proto.schema.VectorField centroid = 2;
  bool has_centroid() const;
  void clear_centroid() ;
  const ::milvus::proto::schema::VectorField& centroid() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::VectorField* release_centroid();
  ::milvus::proto::schema::VectorField* mutable_centroid();
  void set_allocated_centroid(::milvus::proto::schema::VectorField* value);
  void unsafe_arena_set_allocated_centroid(::milvus::proto::schema::VectorField* value);
  ::milvus::proto::schema::VectorField* unsafe_arena_release_centroid();

  private:
  const ::milvus::proto::schema::VectorField& _internal_centroid() const;
  ::milvus::proto::schema::VectorField* _internal_mutable_centroid();

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.VectorClusteringInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr field_;
    ::milvus::proto::schema::VectorField* centroid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class FieldData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.FieldData) */ {
 public:
  inline FieldData() : FieldData(nullptr) {}
  ~FieldData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FieldData(::google::protobuf::internal::ConstantInitialized);

  inline FieldData(const FieldData& from)
      : FieldData(nullptr, from) {}
  FieldData(FieldData&& from) noexcept
    : FieldData() {
    *this = ::std::move(from);
  }

  inline FieldData& operator=(const FieldData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldData& operator=(FieldData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldData& default_instance() {
    return *internal_default_instance();
  }
  enum FieldCase {
    kScalars = 3,
    kVectors = 4,
    FIELD_NOT_SET = 0,
  };

  static inline const FieldData* internal_default_instance() {
    return reinterpret_cast<const FieldData*>(
               &_FieldData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(FieldData& a, FieldData& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FieldData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FieldData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FieldData& from) {
    FieldData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FieldData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.FieldData";
  }
  protected:
  explicit FieldData(::google::protobuf::Arena* arena);
  FieldData(::google::protobuf::Arena* arena, const FieldData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldNameFieldNumber = 2,
    kTypeFieldNumber = 1,
    kIsDynamicFieldNumber = 6,
    kFieldIdFieldNumber = 5,
    kScalarsFieldNumber = 3,
    kVectorsFieldNumber = 4,
  };
  // string field_name = 2;
  void clear_field_name() ;
  const std::string& field_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_field_name(Arg_&& arg, Args_... args);
  std::string* mutable_field_name();
  PROTOBUF_NODISCARD std::string* release_field_name();
  void set_allocated_field_name(std::string* value);

  private:
  const std::string& _internal_field_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field_name(
      const std::string& value);
  std::string* _internal_mutable_field_name();

  public:
  // .milvus.proto.schema.DataType type = 1;
  void clear_type() ;
  ::milvus::proto::schema::DataType type() const;
  void set_type(::milvus::proto::schema::DataType value);

  private:
  ::milvus::proto::schema::DataType _internal_type() const;
  void _internal_set_type(::milvus::proto::schema::DataType value);

  public:
  // bool is_dynamic = 6;
  void clear_is_dynamic() ;
  bool is_dynamic() const;
  void set_is_dynamic(bool value);

  private:
  bool _internal_is_dynamic() const;
  void _internal_set_is_dynamic(bool value);

  public:
  // int64 field_id = 5;
  void clear_field_id() ;
  ::int64_t field_id() const;
  void set_field_id(::int64_t value);

  private:
  ::int64_t _internal_field_id() const;
  void _internal_set_field_id(::int64_t value);

  public:
  // .milvus.proto.schema.ScalarField scalars = 3;
  bool has_scalars() const;
  private:
  bool _internal_has_scalars() const;

  public:
  void clear_scalars() ;
  const ::milvus::proto::schema::ScalarField& scalars() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::ScalarField* release_scalars();
  ::milvus::proto::schema::ScalarField* mutable_scalars();
  void set_allocated_scalars(::milvus::proto::schema::ScalarField* value);
  void unsafe_arena_set_allocated_scalars(::milvus::proto::schema::ScalarField* value);
  ::milvus::proto::schema::ScalarField* unsafe_arena_release_scalars();

  private:
  const ::milvus::proto::schema::ScalarField& _internal_scalars() const;
  ::milvus::proto::schema::ScalarField* _internal_mutable_scalars();

  public:
  // .milvus.proto.schema.VectorField vectors = 4;
  bool has_vectors() const;
  private:
  bool _internal_has_vectors() const;

  public:
  void clear_vectors() ;
  const ::milvus::proto::schema::VectorField& vectors() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::VectorField* release_vectors();
  ::milvus::proto::schema::VectorField* mutable_vectors();
  void set_allocated_vectors(::milvus::proto::schema::VectorField* value);
  void unsafe_arena_set_allocated_vectors(::milvus::proto::schema::VectorField* value);
  ::milvus::proto::schema::VectorField* unsafe_arena_release_vectors();

  private:
  const ::milvus::proto::schema::VectorField& _internal_vectors() const;
  ::milvus::proto::schema::VectorField* _internal_mutable_vectors();

  public:
  void clear_field();
  FieldCase field_case() const;
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.FieldData)
 private:
  class _Internal;
  void set_has_scalars();
  void set_has_vectors();

  inline bool has_field() const;
  inline void clear_has_field();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr field_name_;
    int type_;
    bool is_dynamic_;
    ::int64_t field_id_;
    union FieldUnion {
      constexpr FieldUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::milvus::proto::schema::ScalarField* scalars_;
      ::milvus::proto::schema::VectorField* vectors_;
    } field_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class CollectionSchema final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.CollectionSchema) */ {
 public:
  inline CollectionSchema() : CollectionSchema(nullptr) {}
  ~CollectionSchema() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CollectionSchema(::google::protobuf::internal::ConstantInitialized);

  inline CollectionSchema(const CollectionSchema& from)
      : CollectionSchema(nullptr, from) {}
  CollectionSchema(CollectionSchema&& from) noexcept
    : CollectionSchema() {
    *this = ::std::move(from);
  }

  inline CollectionSchema& operator=(const CollectionSchema& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionSchema& operator=(CollectionSchema&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionSchema& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollectionSchema* internal_default_instance() {
    return reinterpret_cast<const CollectionSchema*>(
               &_CollectionSchema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CollectionSchema& a, CollectionSchema& b) {
    a.Swap(&b);
  }
  inline void Swap(CollectionSchema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionSchema* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollectionSchema* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollectionSchema>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CollectionSchema& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CollectionSchema& from) {
    CollectionSchema::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CollectionSchema* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.CollectionSchema";
  }
  protected:
  explicit CollectionSchema(::google::protobuf::Arena* arena);
  CollectionSchema(::google::protobuf::Arena* arena, const CollectionSchema& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 4,
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kAutoIDFieldNumber = 3,
    kEnableDynamicFieldFieldNumber = 5,
  };
  // repeated .milvus.proto.schema.FieldSchema fields = 4;
  int fields_size() const;
  private:
  int _internal_fields_size() const;

  public:
  void clear_fields() ;
  ::milvus::proto::schema::FieldSchema* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::milvus::proto::schema::FieldSchema >*
      mutable_fields();
  private:
  const ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::FieldSchema>& _internal_fields() const;
  ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::FieldSchema>* _internal_mutable_fields();
  public:
  const ::milvus::proto::schema::FieldSchema& fields(int index) const;
  ::milvus::proto::schema::FieldSchema* add_fields();
  const ::google::protobuf::RepeatedPtrField< ::milvus::proto::schema::FieldSchema >&
      fields() const;
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string description = 2;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // bool autoID = 3 [deprecated = true];
  [[deprecated]]  void clear_autoid() ;
  [[deprecated]] bool autoid() const;
  [[deprecated]] void set_autoid(bool value);

  private:
  bool _internal_autoid() const;
  void _internal_set_autoid(bool value);

  public:
  // bool enable_dynamic_field = 5;
  void clear_enable_dynamic_field() ;
  bool enable_dynamic_field() const;
  void set_enable_dynamic_field(bool value);

  private:
  bool _internal_enable_dynamic_field() const;
  void _internal_set_enable_dynamic_field(bool value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.CollectionSchema)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::milvus::proto::schema::FieldSchema > fields_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    bool autoid_;
    bool enable_dynamic_field_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class SearchResultData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.SearchResultData) */ {
 public:
  inline SearchResultData() : SearchResultData(nullptr) {}
  ~SearchResultData() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SearchResultData(::google::protobuf::internal::ConstantInitialized);

  inline SearchResultData(const SearchResultData& from)
      : SearchResultData(nullptr, from) {}
  SearchResultData(SearchResultData&& from) noexcept
    : SearchResultData() {
    *this = ::std::move(from);
  }

  inline SearchResultData& operator=(const SearchResultData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResultData& operator=(SearchResultData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchResultData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchResultData* internal_default_instance() {
    return reinterpret_cast<const SearchResultData*>(
               &_SearchResultData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SearchResultData& a, SearchResultData& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResultData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchResultData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchResultData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchResultData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchResultData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SearchResultData& from) {
    SearchResultData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SearchResultData* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.SearchResultData";
  }
  protected:
  explicit SearchResultData(::google::protobuf::Arena* arena);
  SearchResultData(::google::protobuf::Arena* arena, const SearchResultData& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsDataFieldNumber = 3,
    kScoresFieldNumber = 4,
    kTopksFieldNumber = 6,
    kOutputFieldsFieldNumber = 7,
    kIdsFieldNumber = 5,
    kGroupByFieldValueFieldNumber = 8,
    kNumQueriesFieldNumber = 1,
    kTopKFieldNumber = 2,
  };
  // repeated .milvus.proto.schema.FieldData fields_data = 3;
  int fields_data_size() const;
  private:
  int _internal_fields_data_size() const;

  public:
  void clear_fields_data() ;
  ::milvus::proto::schema::FieldData* mutable_fields_data(int index);
  ::google::protobuf::RepeatedPtrField< ::milvus::proto::schema::FieldData >*
      mutable_fields_data();
  private:
  const ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::FieldData>& _internal_fields_data() const;
  ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::FieldData>* _internal_mutable_fields_data();
  public:
  const ::milvus::proto::schema::FieldData& fields_data(int index) const;
  ::milvus::proto::schema::FieldData* add_fields_data();
  const ::google::protobuf::RepeatedPtrField< ::milvus::proto::schema::FieldData >&
      fields_data() const;
  // repeated float scores = 4;
  int scores_size() const;
  private:
  int _internal_scores_size() const;

  public:
  void clear_scores() ;
  float scores(int index) const;
  void set_scores(int index, float value);
  void add_scores(float value);
  const ::google::protobuf::RepeatedField<float>& scores() const;
  ::google::protobuf::RepeatedField<float>* mutable_scores();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_scores() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_scores();

  public:
  // repeated int64 topks = 6;
  int topks_size() const;
  private:
  int _internal_topks_size() const;

  public:
  void clear_topks() ;
  ::int64_t topks(int index) const;
  void set_topks(int index, ::int64_t value);
  void add_topks(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& topks() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_topks();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_topks() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_topks();

  public:
  // repeated string output_fields = 7;
  int output_fields_size() const;
  private:
  int _internal_output_fields_size() const;

  public:
  void clear_output_fields() ;
  const std::string& output_fields(int index) const;
  std::string* mutable_output_fields(int index);
  void set_output_fields(int index, const std::string& value);
  void set_output_fields(int index, std::string&& value);
  void set_output_fields(int index, const char* value);
  void set_output_fields(int index, const char* value, std::size_t size);
  void set_output_fields(int index, absl::string_view value);
  std::string* add_output_fields();
  void add_output_fields(const std::string& value);
  void add_output_fields(std::string&& value);
  void add_output_fields(const char* value);
  void add_output_fields(const char* value, std::size_t size);
  void add_output_fields(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& output_fields() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_output_fields();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_output_fields() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_output_fields();

  public:
  // .milvus.proto.schema.IDs ids = 5;
  bool has_ids() const;
  void clear_ids() ;
  const ::milvus::proto::schema::IDs& ids() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::IDs* release_ids();
  ::milvus::proto::schema::IDs* mutable_ids();
  void set_allocated_ids(::milvus::proto::schema::IDs* value);
  void unsafe_arena_set_allocated_ids(::milvus::proto::schema::IDs* value);
  ::milvus::proto::schema::IDs* unsafe_arena_release_ids();

  private:
  const ::milvus::proto::schema::IDs& _internal_ids() const;
  ::milvus::proto::schema::IDs* _internal_mutable_ids();

  public:
  // .milvus.proto.schema.FieldData group_by_field_value = 8;
  bool has_group_by_field_value() const;
  void clear_group_by_field_value() ;
  const ::milvus::proto::schema::FieldData& group_by_field_value() const;
  PROTOBUF_NODISCARD ::milvus::proto::schema::FieldData* release_group_by_field_value();
  ::milvus::proto::schema::FieldData* mutable_group_by_field_value();
  void set_allocated_group_by_field_value(::milvus::proto::schema::FieldData* value);
  void unsafe_arena_set_allocated_group_by_field_value(::milvus::proto::schema::FieldData* value);
  ::milvus::proto::schema::FieldData* unsafe_arena_release_group_by_field_value();

  private:
  const ::milvus::proto::schema::FieldData& _internal_group_by_field_value() const;
  ::milvus::proto::schema::FieldData* _internal_mutable_group_by_field_value();

  public:
  // int64 num_queries = 1;
  void clear_num_queries() ;
  ::int64_t num_queries() const;
  void set_num_queries(::int64_t value);

  private:
  ::int64_t _internal_num_queries() const;
  void _internal_set_num_queries(::int64_t value);

  public:
  // int64 top_k = 2;
  void clear_top_k() ;
  ::int64_t top_k() const;
  void set_top_k(::int64_t value);

  private:
  ::int64_t _internal_top_k() const;
  void _internal_set_top_k(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.SearchResultData)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 3,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::milvus::proto::schema::FieldData > fields_data_;
    ::google::protobuf::RepeatedField<float> scores_;
    ::google::protobuf::RepeatedField<::int64_t> topks_;
    mutable ::google::protobuf::internal::CachedSize _topks_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField<std::string> output_fields_;
    ::milvus::proto::schema::IDs* ids_;
    ::milvus::proto::schema::FieldData* group_by_field_value_;
    ::int64_t num_queries_;
    ::int64_t top_k_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};// -------------------------------------------------------------------

class ClusteringInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:milvus.proto.schema.ClusteringInfo) */ {
 public:
  inline ClusteringInfo() : ClusteringInfo(nullptr) {}
  ~ClusteringInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClusteringInfo(::google::protobuf::internal::ConstantInitialized);

  inline ClusteringInfo(const ClusteringInfo& from)
      : ClusteringInfo(nullptr, from) {}
  ClusteringInfo(ClusteringInfo&& from) noexcept
    : ClusteringInfo() {
    *this = ::std::move(from);
  }

  inline ClusteringInfo& operator=(const ClusteringInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClusteringInfo& operator=(ClusteringInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClusteringInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClusteringInfo* internal_default_instance() {
    return reinterpret_cast<const ClusteringInfo*>(
               &_ClusteringInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ClusteringInfo& a, ClusteringInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ClusteringInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClusteringInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClusteringInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClusteringInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClusteringInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ClusteringInfo& from) {
    ClusteringInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ClusteringInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "milvus.proto.schema.ClusteringInfo";
  }
  protected:
  explicit ClusteringInfo(::google::protobuf::Arena* arena);
  ClusteringInfo(::google::protobuf::Arena* arena, const ClusteringInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorClusteringInfosFieldNumber = 1,
    kScalarClusteringInfosFieldNumber = 2,
  };
  // repeated .milvus.proto.schema.VectorClusteringInfo vector_clustering_infos = 1;
  int vector_clustering_infos_size() const;
  private:
  int _internal_vector_clustering_infos_size() const;

  public:
  void clear_vector_clustering_infos() ;
  ::milvus::proto::schema::VectorClusteringInfo* mutable_vector_clustering_infos(int index);
  ::google::protobuf::RepeatedPtrField< ::milvus::proto::schema::VectorClusteringInfo >*
      mutable_vector_clustering_infos();
  private:
  const ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::VectorClusteringInfo>& _internal_vector_clustering_infos() const;
  ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::VectorClusteringInfo>* _internal_mutable_vector_clustering_infos();
  public:
  const ::milvus::proto::schema::VectorClusteringInfo& vector_clustering_infos(int index) const;
  ::milvus::proto::schema::VectorClusteringInfo* add_vector_clustering_infos();
  const ::google::protobuf::RepeatedPtrField< ::milvus::proto::schema::VectorClusteringInfo >&
      vector_clustering_infos() const;
  // repeated .milvus.proto.schema.ScalarClusteringInfo scalar_clustering_infos = 2;
  int scalar_clustering_infos_size() const;
  private:
  int _internal_scalar_clustering_infos_size() const;

  public:
  void clear_scalar_clustering_infos() ;
  ::milvus::proto::schema::ScalarClusteringInfo* mutable_scalar_clustering_infos(int index);
  ::google::protobuf::RepeatedPtrField< ::milvus::proto::schema::ScalarClusteringInfo >*
      mutable_scalar_clustering_infos();
  private:
  const ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::ScalarClusteringInfo>& _internal_scalar_clustering_infos() const;
  ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::ScalarClusteringInfo>* _internal_mutable_scalar_clustering_infos();
  public:
  const ::milvus::proto::schema::ScalarClusteringInfo& scalar_clustering_infos(int index) const;
  ::milvus::proto::schema::ScalarClusteringInfo* add_scalar_clustering_infos();
  const ::google::protobuf::RepeatedPtrField< ::milvus::proto::schema::ScalarClusteringInfo >&
      scalar_clustering_infos() const;
  // @@protoc_insertion_point(class_scope:milvus.proto.schema.ClusteringInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::milvus::proto::schema::VectorClusteringInfo > vector_clustering_infos_;
    ::google::protobuf::RepeatedPtrField< ::milvus::proto::schema::ScalarClusteringInfo > scalar_clustering_infos_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_schema_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// FieldSchema

// int64 fieldID = 1;
inline void FieldSchema::clear_fieldid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fieldid_ = ::int64_t{0};
}
inline ::int64_t FieldSchema::fieldid() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldSchema.fieldID)
  return _internal_fieldid();
}
inline void FieldSchema::set_fieldid(::int64_t value) {
  _internal_set_fieldid(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.FieldSchema.fieldID)
}
inline ::int64_t FieldSchema::_internal_fieldid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fieldid_;
}
inline void FieldSchema::_internal_set_fieldid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fieldid_ = value;
}

// string name = 2;
inline void FieldSchema::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& FieldSchema::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldSchema.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FieldSchema::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:milvus.proto.schema.FieldSchema.name)
}
inline std::string* FieldSchema::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.FieldSchema.name)
  return _s;
}
inline const std::string& FieldSchema::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void FieldSchema::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* FieldSchema::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* FieldSchema::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.schema.FieldSchema.name)
  return _impl_.name_.Release();
}
inline void FieldSchema::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.schema.FieldSchema.name)
}

// bool is_primary_key = 3;
inline void FieldSchema::clear_is_primary_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_primary_key_ = false;
}
inline bool FieldSchema::is_primary_key() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldSchema.is_primary_key)
  return _internal_is_primary_key();
}
inline void FieldSchema::set_is_primary_key(bool value) {
  _internal_set_is_primary_key(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.FieldSchema.is_primary_key)
}
inline bool FieldSchema::_internal_is_primary_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_primary_key_;
}
inline void FieldSchema::_internal_set_is_primary_key(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_primary_key_ = value;
}

// string description = 4;
inline void FieldSchema::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& FieldSchema::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldSchema.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FieldSchema::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:milvus.proto.schema.FieldSchema.description)
}
inline std::string* FieldSchema::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.FieldSchema.description)
  return _s;
}
inline const std::string& FieldSchema::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void FieldSchema::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* FieldSchema::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* FieldSchema::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.schema.FieldSchema.description)
  return _impl_.description_.Release();
}
inline void FieldSchema::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.schema.FieldSchema.description)
}

// .milvus.proto.schema.DataType data_type = 5;
inline void FieldSchema::clear_data_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_type_ = 0;
}
inline ::milvus::proto::schema::DataType FieldSchema::data_type() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldSchema.data_type)
  return _internal_data_type();
}
inline void FieldSchema::set_data_type(::milvus::proto::schema::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.FieldSchema.data_type)
}
inline ::milvus::proto::schema::DataType FieldSchema::_internal_data_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::schema::DataType>(_impl_.data_type_);
}
inline void FieldSchema::_internal_set_data_type(::milvus::proto::schema::DataType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.data_type_ = value;
}

// repeated .milvus.proto.common.KeyValuePair type_params = 6;
inline int FieldSchema::_internal_type_params_size() const {
  return _internal_type_params().size();
}
inline int FieldSchema::type_params_size() const {
  return _internal_type_params_size();
}
inline ::milvus::proto::common::KeyValuePair* FieldSchema::mutable_type_params(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.FieldSchema.type_params)
  return _internal_mutable_type_params()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::common::KeyValuePair>* FieldSchema::mutable_type_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.FieldSchema.type_params)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_type_params();
}
inline const ::milvus::proto::common::KeyValuePair& FieldSchema::type_params(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldSchema.type_params)
  return _internal_type_params().Get(index);
}
inline ::milvus::proto::common::KeyValuePair* FieldSchema::add_type_params() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::milvus::proto::common::KeyValuePair* _add = _internal_mutable_type_params()->Add();
  // @@protoc_insertion_point(field_add:milvus.proto.schema.FieldSchema.type_params)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::common::KeyValuePair>& FieldSchema::type_params() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.FieldSchema.type_params)
  return _internal_type_params();
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::common::KeyValuePair>&
FieldSchema::_internal_type_params() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_params_;
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::common::KeyValuePair>*
FieldSchema::_internal_mutable_type_params() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.type_params_;
}

// repeated .milvus.proto.common.KeyValuePair index_params = 7;
inline int FieldSchema::_internal_index_params_size() const {
  return _internal_index_params().size();
}
inline int FieldSchema::index_params_size() const {
  return _internal_index_params_size();
}
inline ::milvus::proto::common::KeyValuePair* FieldSchema::mutable_index_params(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.FieldSchema.index_params)
  return _internal_mutable_index_params()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::common::KeyValuePair>* FieldSchema::mutable_index_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.FieldSchema.index_params)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_index_params();
}
inline const ::milvus::proto::common::KeyValuePair& FieldSchema::index_params(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldSchema.index_params)
  return _internal_index_params().Get(index);
}
inline ::milvus::proto::common::KeyValuePair* FieldSchema::add_index_params() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::milvus::proto::common::KeyValuePair* _add = _internal_mutable_index_params()->Add();
  // @@protoc_insertion_point(field_add:milvus.proto.schema.FieldSchema.index_params)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::common::KeyValuePair>& FieldSchema::index_params() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.FieldSchema.index_params)
  return _internal_index_params();
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::common::KeyValuePair>&
FieldSchema::_internal_index_params() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.index_params_;
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::common::KeyValuePair>*
FieldSchema::_internal_mutable_index_params() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.index_params_;
}

// bool autoID = 8;
inline void FieldSchema::clear_autoid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.autoid_ = false;
}
inline bool FieldSchema::autoid() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldSchema.autoID)
  return _internal_autoid();
}
inline void FieldSchema::set_autoid(bool value) {
  _internal_set_autoid(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.FieldSchema.autoID)
}
inline bool FieldSchema::_internal_autoid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.autoid_;
}
inline void FieldSchema::_internal_set_autoid(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.autoid_ = value;
}

// .milvus.proto.schema.FieldState state = 9;
inline void FieldSchema::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
}
inline ::milvus::proto::schema::FieldState FieldSchema::state() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldSchema.state)
  return _internal_state();
}
inline void FieldSchema::set_state(::milvus::proto::schema::FieldState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.FieldSchema.state)
}
inline ::milvus::proto::schema::FieldState FieldSchema::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::schema::FieldState>(_impl_.state_);
}
inline void FieldSchema::_internal_set_state(::milvus::proto::schema::FieldState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_ = value;
}

// .milvus.proto.schema.DataType element_type = 10;
inline void FieldSchema::clear_element_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.element_type_ = 0;
}
inline ::milvus::proto::schema::DataType FieldSchema::element_type() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldSchema.element_type)
  return _internal_element_type();
}
inline void FieldSchema::set_element_type(::milvus::proto::schema::DataType value) {
  _internal_set_element_type(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.FieldSchema.element_type)
}
inline ::milvus::proto::schema::DataType FieldSchema::_internal_element_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::schema::DataType>(_impl_.element_type_);
}
inline void FieldSchema::_internal_set_element_type(::milvus::proto::schema::DataType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.element_type_ = value;
}

// .milvus.proto.schema.ValueField default_value = 11;
inline bool FieldSchema::has_default_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.default_value_ != nullptr);
  return value;
}
inline void FieldSchema::clear_default_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.default_value_ != nullptr) _impl_.default_value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::schema::ValueField& FieldSchema::_internal_default_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::schema::ValueField* p = _impl_.default_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::schema::ValueField&>(::milvus::proto::schema::_ValueField_default_instance_);
}
inline const ::milvus::proto::schema::ValueField& FieldSchema::default_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldSchema.default_value)
  return _internal_default_value();
}
inline void FieldSchema::unsafe_arena_set_allocated_default_value(::milvus::proto::schema::ValueField* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.default_value_);
  }
  _impl_.default_value_ = reinterpret_cast<::milvus::proto::schema::ValueField*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.FieldSchema.default_value)
}
inline ::milvus::proto::schema::ValueField* FieldSchema::release_default_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::schema::ValueField* released = _impl_.default_value_;
  _impl_.default_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::schema::ValueField* FieldSchema::unsafe_arena_release_default_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.schema.FieldSchema.default_value)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::schema::ValueField* temp = _impl_.default_value_;
  _impl_.default_value_ = nullptr;
  return temp;
}
inline ::milvus::proto::schema::ValueField* FieldSchema::_internal_mutable_default_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.default_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::schema::ValueField>(GetArena());
    _impl_.default_value_ = reinterpret_cast<::milvus::proto::schema::ValueField*>(p);
  }
  return _impl_.default_value_;
}
inline ::milvus::proto::schema::ValueField* FieldSchema::mutable_default_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::ValueField* _msg = _internal_mutable_default_value();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.FieldSchema.default_value)
  return _msg;
}
inline void FieldSchema::set_allocated_default_value(::milvus::proto::schema::ValueField* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::schema::ValueField*>(_impl_.default_value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::schema::ValueField*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.default_value_ = reinterpret_cast<::milvus::proto::schema::ValueField*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.schema.FieldSchema.default_value)
}

// bool is_dynamic = 12;
inline void FieldSchema::clear_is_dynamic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_dynamic_ = false;
}
inline bool FieldSchema::is_dynamic() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldSchema.is_dynamic)
  return _internal_is_dynamic();
}
inline void FieldSchema::set_is_dynamic(bool value) {
  _internal_set_is_dynamic(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.FieldSchema.is_dynamic)
}
inline bool FieldSchema::_internal_is_dynamic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_dynamic_;
}
inline void FieldSchema::_internal_set_is_dynamic(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_dynamic_ = value;
}

// bool is_partition_key = 13;
inline void FieldSchema::clear_is_partition_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_partition_key_ = false;
}
inline bool FieldSchema::is_partition_key() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldSchema.is_partition_key)
  return _internal_is_partition_key();
}
inline void FieldSchema::set_is_partition_key(bool value) {
  _internal_set_is_partition_key(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.FieldSchema.is_partition_key)
}
inline bool FieldSchema::_internal_is_partition_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_partition_key_;
}
inline void FieldSchema::_internal_set_is_partition_key(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_partition_key_ = value;
}

// bool is_clustering_key = 14;
inline void FieldSchema::clear_is_clustering_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_clustering_key_ = false;
}
inline bool FieldSchema::is_clustering_key() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldSchema.is_clustering_key)
  return _internal_is_clustering_key();
}
inline void FieldSchema::set_is_clustering_key(bool value) {
  _internal_set_is_clustering_key(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.FieldSchema.is_clustering_key)
}
inline bool FieldSchema::_internal_is_clustering_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_clustering_key_;
}
inline void FieldSchema::_internal_set_is_clustering_key(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_clustering_key_ = value;
}

// -------------------------------------------------------------------

// CollectionSchema

// string name = 1;
inline void CollectionSchema::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CollectionSchema::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.CollectionSchema.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollectionSchema::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:milvus.proto.schema.CollectionSchema.name)
}
inline std::string* CollectionSchema::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.CollectionSchema.name)
  return _s;
}
inline const std::string& CollectionSchema::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CollectionSchema::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CollectionSchema::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CollectionSchema::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.schema.CollectionSchema.name)
  return _impl_.name_.Release();
}
inline void CollectionSchema::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.schema.CollectionSchema.name)
}

// string description = 2;
inline void CollectionSchema::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& CollectionSchema::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.CollectionSchema.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CollectionSchema::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:milvus.proto.schema.CollectionSchema.description)
}
inline std::string* CollectionSchema::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.CollectionSchema.description)
  return _s;
}
inline const std::string& CollectionSchema::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void CollectionSchema::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* CollectionSchema::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* CollectionSchema::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.schema.CollectionSchema.description)
  return _impl_.description_.Release();
}
inline void CollectionSchema::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.schema.CollectionSchema.description)
}

// bool autoID = 3 [deprecated = true];
inline void CollectionSchema::clear_autoid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.autoid_ = false;
}
inline bool CollectionSchema::autoid() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.CollectionSchema.autoID)
  return _internal_autoid();
}
inline void CollectionSchema::set_autoid(bool value) {
  _internal_set_autoid(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.CollectionSchema.autoID)
}
inline bool CollectionSchema::_internal_autoid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.autoid_;
}
inline void CollectionSchema::_internal_set_autoid(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.autoid_ = value;
}

// repeated .milvus.proto.schema.FieldSchema fields = 4;
inline int CollectionSchema::_internal_fields_size() const {
  return _internal_fields().size();
}
inline int CollectionSchema::fields_size() const {
  return _internal_fields_size();
}
inline void CollectionSchema::clear_fields() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fields_.Clear();
}
inline ::milvus::proto::schema::FieldSchema* CollectionSchema::mutable_fields(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.CollectionSchema.fields)
  return _internal_mutable_fields()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::FieldSchema>* CollectionSchema::mutable_fields()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.CollectionSchema.fields)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_fields();
}
inline const ::milvus::proto::schema::FieldSchema& CollectionSchema::fields(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.CollectionSchema.fields)
  return _internal_fields().Get(index);
}
inline ::milvus::proto::schema::FieldSchema* CollectionSchema::add_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::milvus::proto::schema::FieldSchema* _add = _internal_mutable_fields()->Add();
  // @@protoc_insertion_point(field_add:milvus.proto.schema.CollectionSchema.fields)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::FieldSchema>& CollectionSchema::fields() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.CollectionSchema.fields)
  return _internal_fields();
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::FieldSchema>&
CollectionSchema::_internal_fields() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fields_;
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::FieldSchema>*
CollectionSchema::_internal_mutable_fields() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.fields_;
}

// bool enable_dynamic_field = 5;
inline void CollectionSchema::clear_enable_dynamic_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_dynamic_field_ = false;
}
inline bool CollectionSchema::enable_dynamic_field() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.CollectionSchema.enable_dynamic_field)
  return _internal_enable_dynamic_field();
}
inline void CollectionSchema::set_enable_dynamic_field(bool value) {
  _internal_set_enable_dynamic_field(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.CollectionSchema.enable_dynamic_field)
}
inline bool CollectionSchema::_internal_enable_dynamic_field() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_dynamic_field_;
}
inline void CollectionSchema::_internal_set_enable_dynamic_field(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enable_dynamic_field_ = value;
}

// -------------------------------------------------------------------

// BoolArray

// repeated bool data = 1;
inline int BoolArray::_internal_data_size() const {
  return _internal_data().size();
}
inline int BoolArray::data_size() const {
  return _internal_data_size();
}
inline void BoolArray::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.Clear();
}
inline bool BoolArray::data(int index) const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.BoolArray.data)
  return _internal_data().Get(index);
}
inline void BoolArray::set_data(int index, bool value) {
  _internal_mutable_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.BoolArray.data)
}
inline void BoolArray::add_data(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add(value);
  // @@protoc_insertion_point(field_add:milvus.proto.schema.BoolArray.data)
}
inline const ::google::protobuf::RepeatedField<bool>& BoolArray::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.BoolArray.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedField<bool>* BoolArray::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.BoolArray.data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedField<bool>& BoolArray::_internal_data()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedField<bool>* BoolArray::_internal_mutable_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// IntArray

// repeated int32 data = 1;
inline int IntArray::_internal_data_size() const {
  return _internal_data().size();
}
inline int IntArray::data_size() const {
  return _internal_data_size();
}
inline void IntArray::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.Clear();
}
inline ::int32_t IntArray::data(int index) const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.IntArray.data)
  return _internal_data().Get(index);
}
inline void IntArray::set_data(int index, ::int32_t value) {
  _internal_mutable_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.IntArray.data)
}
inline void IntArray::add_data(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add(value);
  // @@protoc_insertion_point(field_add:milvus.proto.schema.IntArray.data)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& IntArray::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.IntArray.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedField<::int32_t>* IntArray::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.IntArray.data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& IntArray::_internal_data()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* IntArray::_internal_mutable_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// LongArray

// repeated int64 data = 1;
inline int LongArray::_internal_data_size() const {
  return _internal_data().size();
}
inline int LongArray::data_size() const {
  return _internal_data_size();
}
inline void LongArray::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.Clear();
}
inline ::int64_t LongArray::data(int index) const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.LongArray.data)
  return _internal_data().Get(index);
}
inline void LongArray::set_data(int index, ::int64_t value) {
  _internal_mutable_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.LongArray.data)
}
inline void LongArray::add_data(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add(value);
  // @@protoc_insertion_point(field_add:milvus.proto.schema.LongArray.data)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& LongArray::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.LongArray.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedField<::int64_t>* LongArray::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.LongArray.data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& LongArray::_internal_data()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* LongArray::_internal_mutable_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// FloatArray

// repeated float data = 1;
inline int FloatArray::_internal_data_size() const {
  return _internal_data().size();
}
inline int FloatArray::data_size() const {
  return _internal_data_size();
}
inline void FloatArray::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.Clear();
}
inline float FloatArray::data(int index) const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FloatArray.data)
  return _internal_data().Get(index);
}
inline void FloatArray::set_data(int index, float value) {
  _internal_mutable_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.FloatArray.data)
}
inline void FloatArray::add_data(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add(value);
  // @@protoc_insertion_point(field_add:milvus.proto.schema.FloatArray.data)
}
inline const ::google::protobuf::RepeatedField<float>& FloatArray::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.FloatArray.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedField<float>* FloatArray::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.FloatArray.data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedField<float>& FloatArray::_internal_data()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedField<float>* FloatArray::_internal_mutable_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// DoubleArray

// repeated double data = 1;
inline int DoubleArray::_internal_data_size() const {
  return _internal_data().size();
}
inline int DoubleArray::data_size() const {
  return _internal_data_size();
}
inline void DoubleArray::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.Clear();
}
inline double DoubleArray::data(int index) const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.DoubleArray.data)
  return _internal_data().Get(index);
}
inline void DoubleArray::set_data(int index, double value) {
  _internal_mutable_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.DoubleArray.data)
}
inline void DoubleArray::add_data(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add(value);
  // @@protoc_insertion_point(field_add:milvus.proto.schema.DoubleArray.data)
}
inline const ::google::protobuf::RepeatedField<double>& DoubleArray::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.DoubleArray.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedField<double>* DoubleArray::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.DoubleArray.data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedField<double>& DoubleArray::_internal_data()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedField<double>* DoubleArray::_internal_mutable_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// BytesArray

// repeated bytes data = 1;
inline int BytesArray::_internal_data_size() const {
  return _internal_data().size();
}
inline int BytesArray::data_size() const {
  return _internal_data_size();
}
inline void BytesArray::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.Clear();
}
inline std::string* BytesArray::add_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_data()->Add();
  // @@protoc_insertion_point(field_add_mutable:milvus.proto.schema.BytesArray.data)
  return _s;
}
inline const std::string& BytesArray::data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.BytesArray.data)
  return _internal_data().Get(index);
}
inline std::string* BytesArray::mutable_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.BytesArray.data)
  return _internal_mutable_data()->Mutable(index);
}
inline void BytesArray::set_data(int index, const std::string& value) {
  _internal_mutable_data()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.BytesArray.data)
}
inline void BytesArray::set_data(int index, std::string&& value) {
  _internal_mutable_data()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:milvus.proto.schema.BytesArray.data)
}
inline void BytesArray::set_data(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_data()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:milvus.proto.schema.BytesArray.data)
}
inline void BytesArray::set_data(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_data()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:milvus.proto.schema.BytesArray.data)
}
inline void BytesArray::set_data(int index, absl::string_view value) {
  _internal_mutable_data()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:milvus.proto.schema.BytesArray.data)
}
inline void BytesArray::add_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:milvus.proto.schema.BytesArray.data)
}
inline void BytesArray::add_data(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:milvus.proto.schema.BytesArray.data)
}
inline void BytesArray::add_data(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:milvus.proto.schema.BytesArray.data)
}
inline void BytesArray::add_data(const void* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:milvus.proto.schema.BytesArray.data)
}
inline void BytesArray::add_data(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:milvus.proto.schema.BytesArray.data)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BytesArray::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.BytesArray.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BytesArray::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.BytesArray.data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BytesArray::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BytesArray::_internal_mutable_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// StringArray

// repeated string data = 1;
inline int StringArray::_internal_data_size() const {
  return _internal_data().size();
}
inline int StringArray::data_size() const {
  return _internal_data_size();
}
inline void StringArray::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.Clear();
}
inline std::string* StringArray::add_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_data()->Add();
  // @@protoc_insertion_point(field_add_mutable:milvus.proto.schema.StringArray.data)
  return _s;
}
inline const std::string& StringArray::data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.StringArray.data)
  return _internal_data().Get(index);
}
inline std::string* StringArray::mutable_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.StringArray.data)
  return _internal_mutable_data()->Mutable(index);
}
inline void StringArray::set_data(int index, const std::string& value) {
  _internal_mutable_data()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.StringArray.data)
}
inline void StringArray::set_data(int index, std::string&& value) {
  _internal_mutable_data()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:milvus.proto.schema.StringArray.data)
}
inline void StringArray::set_data(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_data()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:milvus.proto.schema.StringArray.data)
}
inline void StringArray::set_data(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_data()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:milvus.proto.schema.StringArray.data)
}
inline void StringArray::set_data(int index, absl::string_view value) {
  _internal_mutable_data()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:milvus.proto.schema.StringArray.data)
}
inline void StringArray::add_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:milvus.proto.schema.StringArray.data)
}
inline void StringArray::add_data(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:milvus.proto.schema.StringArray.data)
}
inline void StringArray::add_data(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:milvus.proto.schema.StringArray.data)
}
inline void StringArray::add_data(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:milvus.proto.schema.StringArray.data)
}
inline void StringArray::add_data(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:milvus.proto.schema.StringArray.data)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringArray::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.StringArray.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StringArray::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.StringArray.data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringArray::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StringArray::_internal_mutable_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// ArrayArray

// repeated .milvus.proto.schema.ScalarField data = 1;
inline int ArrayArray::_internal_data_size() const {
  return _internal_data().size();
}
inline int ArrayArray::data_size() const {
  return _internal_data_size();
}
inline void ArrayArray::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.Clear();
}
inline ::milvus::proto::schema::ScalarField* ArrayArray::mutable_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.ArrayArray.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::ScalarField>* ArrayArray::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.ArrayArray.data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data();
}
inline const ::milvus::proto::schema::ScalarField& ArrayArray::data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ArrayArray.data)
  return _internal_data().Get(index);
}
inline ::milvus::proto::schema::ScalarField* ArrayArray::add_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::milvus::proto::schema::ScalarField* _add = _internal_mutable_data()->Add();
  // @@protoc_insertion_point(field_add:milvus.proto.schema.ArrayArray.data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::ScalarField>& ArrayArray::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.ArrayArray.data)
  return _internal_data();
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::ScalarField>&
ArrayArray::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::ScalarField>*
ArrayArray::_internal_mutable_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_;
}

// .milvus.proto.schema.DataType element_type = 2;
inline void ArrayArray::clear_element_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.element_type_ = 0;
}
inline ::milvus::proto::schema::DataType ArrayArray::element_type() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ArrayArray.element_type)
  return _internal_element_type();
}
inline void ArrayArray::set_element_type(::milvus::proto::schema::DataType value) {
  _internal_set_element_type(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.ArrayArray.element_type)
}
inline ::milvus::proto::schema::DataType ArrayArray::_internal_element_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::schema::DataType>(_impl_.element_type_);
}
inline void ArrayArray::_internal_set_element_type(::milvus::proto::schema::DataType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.element_type_ = value;
}

// -------------------------------------------------------------------

// JSONArray

// repeated bytes data = 1;
inline int JSONArray::_internal_data_size() const {
  return _internal_data().size();
}
inline int JSONArray::data_size() const {
  return _internal_data_size();
}
inline void JSONArray::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.Clear();
}
inline std::string* JSONArray::add_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_data()->Add();
  // @@protoc_insertion_point(field_add_mutable:milvus.proto.schema.JSONArray.data)
  return _s;
}
inline const std::string& JSONArray::data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.JSONArray.data)
  return _internal_data().Get(index);
}
inline std::string* JSONArray::mutable_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.JSONArray.data)
  return _internal_mutable_data()->Mutable(index);
}
inline void JSONArray::set_data(int index, const std::string& value) {
  _internal_mutable_data()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.JSONArray.data)
}
inline void JSONArray::set_data(int index, std::string&& value) {
  _internal_mutable_data()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:milvus.proto.schema.JSONArray.data)
}
inline void JSONArray::set_data(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_data()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:milvus.proto.schema.JSONArray.data)
}
inline void JSONArray::set_data(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_data()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:milvus.proto.schema.JSONArray.data)
}
inline void JSONArray::set_data(int index, absl::string_view value) {
  _internal_mutable_data()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:milvus.proto.schema.JSONArray.data)
}
inline void JSONArray::add_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:milvus.proto.schema.JSONArray.data)
}
inline void JSONArray::add_data(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:milvus.proto.schema.JSONArray.data)
}
inline void JSONArray::add_data(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:milvus.proto.schema.JSONArray.data)
}
inline void JSONArray::add_data(const void* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:milvus.proto.schema.JSONArray.data)
}
inline void JSONArray::add_data(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:milvus.proto.schema.JSONArray.data)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
JSONArray::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.JSONArray.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
JSONArray::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.JSONArray.data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
JSONArray::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
JSONArray::_internal_mutable_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// ValueField

// bool bool_data = 1;
inline bool ValueField::has_bool_data() const {
  return data_case() == kBoolData;
}
inline void ValueField::set_has_bool_data() {
  _impl_._oneof_case_[0] = kBoolData;
}
inline void ValueField::clear_bool_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kBoolData) {
    _impl_.data_.bool_data_ = false;
    clear_has_data();
  }
}
inline bool ValueField::bool_data() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ValueField.bool_data)
  return _internal_bool_data();
}
inline void ValueField::set_bool_data(bool value) {
  _internal_set_bool_data(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.ValueField.bool_data)
}
inline bool ValueField::_internal_bool_data() const {
  if (data_case() == kBoolData) {
    return _impl_.data_.bool_data_;
  }
  return false;
}
inline void ValueField::_internal_set_bool_data(bool value) {
  if (data_case() != kBoolData) {
    clear_data();
    set_has_bool_data();
  }
  _impl_.data_.bool_data_ = value;
}

// int32 int_data = 2;
inline bool ValueField::has_int_data() const {
  return data_case() == kIntData;
}
inline void ValueField::set_has_int_data() {
  _impl_._oneof_case_[0] = kIntData;
}
inline void ValueField::clear_int_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kIntData) {
    _impl_.data_.int_data_ = 0;
    clear_has_data();
  }
}
inline ::int32_t ValueField::int_data() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ValueField.int_data)
  return _internal_int_data();
}
inline void ValueField::set_int_data(::int32_t value) {
  _internal_set_int_data(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.ValueField.int_data)
}
inline ::int32_t ValueField::_internal_int_data() const {
  if (data_case() == kIntData) {
    return _impl_.data_.int_data_;
  }
  return 0;
}
inline void ValueField::_internal_set_int_data(::int32_t value) {
  if (data_case() != kIntData) {
    clear_data();
    set_has_int_data();
  }
  _impl_.data_.int_data_ = value;
}

// int64 long_data = 3;
inline bool ValueField::has_long_data() const {
  return data_case() == kLongData;
}
inline void ValueField::set_has_long_data() {
  _impl_._oneof_case_[0] = kLongData;
}
inline void ValueField::clear_long_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kLongData) {
    _impl_.data_.long_data_ = ::int64_t{0};
    clear_has_data();
  }
}
inline ::int64_t ValueField::long_data() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ValueField.long_data)
  return _internal_long_data();
}
inline void ValueField::set_long_data(::int64_t value) {
  _internal_set_long_data(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.ValueField.long_data)
}
inline ::int64_t ValueField::_internal_long_data() const {
  if (data_case() == kLongData) {
    return _impl_.data_.long_data_;
  }
  return ::int64_t{0};
}
inline void ValueField::_internal_set_long_data(::int64_t value) {
  if (data_case() != kLongData) {
    clear_data();
    set_has_long_data();
  }
  _impl_.data_.long_data_ = value;
}

// float float_data = 4;
inline bool ValueField::has_float_data() const {
  return data_case() == kFloatData;
}
inline void ValueField::set_has_float_data() {
  _impl_._oneof_case_[0] = kFloatData;
}
inline void ValueField::clear_float_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kFloatData) {
    _impl_.data_.float_data_ = 0;
    clear_has_data();
  }
}
inline float ValueField::float_data() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ValueField.float_data)
  return _internal_float_data();
}
inline void ValueField::set_float_data(float value) {
  _internal_set_float_data(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.ValueField.float_data)
}
inline float ValueField::_internal_float_data() const {
  if (data_case() == kFloatData) {
    return _impl_.data_.float_data_;
  }
  return 0;
}
inline void ValueField::_internal_set_float_data(float value) {
  if (data_case() != kFloatData) {
    clear_data();
    set_has_float_data();
  }
  _impl_.data_.float_data_ = value;
}

// double double_data = 5;
inline bool ValueField::has_double_data() const {
  return data_case() == kDoubleData;
}
inline void ValueField::set_has_double_data() {
  _impl_._oneof_case_[0] = kDoubleData;
}
inline void ValueField::clear_double_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kDoubleData) {
    _impl_.data_.double_data_ = 0;
    clear_has_data();
  }
}
inline double ValueField::double_data() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ValueField.double_data)
  return _internal_double_data();
}
inline void ValueField::set_double_data(double value) {
  _internal_set_double_data(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.ValueField.double_data)
}
inline double ValueField::_internal_double_data() const {
  if (data_case() == kDoubleData) {
    return _impl_.data_.double_data_;
  }
  return 0;
}
inline void ValueField::_internal_set_double_data(double value) {
  if (data_case() != kDoubleData) {
    clear_data();
    set_has_double_data();
  }
  _impl_.data_.double_data_ = value;
}

// string string_data = 6;
inline bool ValueField::has_string_data() const {
  return data_case() == kStringData;
}
inline void ValueField::set_has_string_data() {
  _impl_._oneof_case_[0] = kStringData;
}
inline void ValueField::clear_string_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kStringData) {
    _impl_.data_.string_data_.Destroy();
    clear_has_data();
  }
}
inline const std::string& ValueField::string_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ValueField.string_data)
  return _internal_string_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValueField::set_string_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kStringData) {
    clear_data();

    set_has_string_data();
    _impl_.data_.string_data_.InitDefault();
  }
  _impl_.data_.string_data_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:milvus.proto.schema.ValueField.string_data)
}
inline std::string* ValueField::mutable_string_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_string_data();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.ValueField.string_data)
  return _s;
}
inline const std::string& ValueField::_internal_string_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (data_case() != kStringData) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.data_.string_data_.Get();
}
inline void ValueField::_internal_set_string_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kStringData) {
    clear_data();

    set_has_string_data();
    _impl_.data_.string_data_.InitDefault();
  }
  _impl_.data_.string_data_.Set(value, GetArena());
}
inline std::string* ValueField::_internal_mutable_string_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kStringData) {
    clear_data();

    set_has_string_data();
    _impl_.data_.string_data_.InitDefault();
  }
  return _impl_.data_.string_data_.Mutable( GetArena());
}
inline std::string* ValueField::release_string_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.schema.ValueField.string_data)
  if (data_case() != kStringData) {
    return nullptr;
  }
  clear_has_data();
  return _impl_.data_.string_data_.Release();
}
inline void ValueField::set_allocated_string_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_data()) {
    clear_data();
  }
  if (value != nullptr) {
    set_has_string_data();
    _impl_.data_.string_data_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.schema.ValueField.string_data)
}

// bytes bytes_data = 7;
inline bool ValueField::has_bytes_data() const {
  return data_case() == kBytesData;
}
inline void ValueField::set_has_bytes_data() {
  _impl_._oneof_case_[0] = kBytesData;
}
inline void ValueField::clear_bytes_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kBytesData) {
    _impl_.data_.bytes_data_.Destroy();
    clear_has_data();
  }
}
inline const std::string& ValueField::bytes_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ValueField.bytes_data)
  return _internal_bytes_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValueField::set_bytes_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kBytesData) {
    clear_data();

    set_has_bytes_data();
    _impl_.data_.bytes_data_.InitDefault();
  }
  _impl_.data_.bytes_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:milvus.proto.schema.ValueField.bytes_data)
}
inline std::string* ValueField::mutable_bytes_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bytes_data();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.ValueField.bytes_data)
  return _s;
}
inline const std::string& ValueField::_internal_bytes_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (data_case() != kBytesData) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.data_.bytes_data_.Get();
}
inline void ValueField::_internal_set_bytes_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kBytesData) {
    clear_data();

    set_has_bytes_data();
    _impl_.data_.bytes_data_.InitDefault();
  }
  _impl_.data_.bytes_data_.Set(value, GetArena());
}
inline std::string* ValueField::_internal_mutable_bytes_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kBytesData) {
    clear_data();

    set_has_bytes_data();
    _impl_.data_.bytes_data_.InitDefault();
  }
  return _impl_.data_.bytes_data_.Mutable( GetArena());
}
inline std::string* ValueField::release_bytes_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.schema.ValueField.bytes_data)
  if (data_case() != kBytesData) {
    return nullptr;
  }
  clear_has_data();
  return _impl_.data_.bytes_data_.Release();
}
inline void ValueField::set_allocated_bytes_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_data()) {
    clear_data();
  }
  if (value != nullptr) {
    set_has_bytes_data();
    _impl_.data_.bytes_data_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.schema.ValueField.bytes_data)
}

inline bool ValueField::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void ValueField::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline ValueField::DataCase ValueField::data_case() const {
  return ValueField::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ScalarField

// .milvus.proto.schema.BoolArray bool_data = 1;
inline bool ScalarField::has_bool_data() const {
  return data_case() == kBoolData;
}
inline bool ScalarField::_internal_has_bool_data() const {
  return data_case() == kBoolData;
}
inline void ScalarField::set_has_bool_data() {
  _impl_._oneof_case_[0] = kBoolData;
}
inline void ScalarField::clear_bool_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kBoolData) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.bool_data_;
    }
    clear_has_data();
  }
}
inline ::milvus::proto::schema::BoolArray* ScalarField::release_bool_data() {
  // @@protoc_insertion_point(field_release:milvus.proto.schema.ScalarField.bool_data)
  if (data_case() == kBoolData) {
    clear_has_data();
    auto* temp = _impl_.data_.bool_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.bool_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::schema::BoolArray& ScalarField::_internal_bool_data() const {
  return data_case() == kBoolData ? *_impl_.data_.bool_data_ : reinterpret_cast<::milvus::proto::schema::BoolArray&>(::milvus::proto::schema::_BoolArray_default_instance_);
}
inline const ::milvus::proto::schema::BoolArray& ScalarField::bool_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ScalarField.bool_data)
  return _internal_bool_data();
}
inline ::milvus::proto::schema::BoolArray* ScalarField::unsafe_arena_release_bool_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.schema.ScalarField.bool_data)
  if (data_case() == kBoolData) {
    clear_has_data();
    auto* temp = _impl_.data_.bool_data_;
    _impl_.data_.bool_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ScalarField::unsafe_arena_set_allocated_bool_data(::milvus::proto::schema::BoolArray* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_bool_data();
    _impl_.data_.bool_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.ScalarField.bool_data)
}
inline ::milvus::proto::schema::BoolArray* ScalarField::_internal_mutable_bool_data() {
  if (data_case() != kBoolData) {
    clear_data();
    set_has_bool_data();
    _impl_.data_.bool_data_ = CreateMaybeMessage<::milvus::proto::schema::BoolArray>(GetArena());
  }
  return _impl_.data_.bool_data_;
}
inline ::milvus::proto::schema::BoolArray* ScalarField::mutable_bool_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::BoolArray* _msg = _internal_mutable_bool_data();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.ScalarField.bool_data)
  return _msg;
}

// .milvus.proto.schema.IntArray int_data = 2;
inline bool ScalarField::has_int_data() const {
  return data_case() == kIntData;
}
inline bool ScalarField::_internal_has_int_data() const {
  return data_case() == kIntData;
}
inline void ScalarField::set_has_int_data() {
  _impl_._oneof_case_[0] = kIntData;
}
inline void ScalarField::clear_int_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kIntData) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.int_data_;
    }
    clear_has_data();
  }
}
inline ::milvus::proto::schema::IntArray* ScalarField::release_int_data() {
  // @@protoc_insertion_point(field_release:milvus.proto.schema.ScalarField.int_data)
  if (data_case() == kIntData) {
    clear_has_data();
    auto* temp = _impl_.data_.int_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.int_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::schema::IntArray& ScalarField::_internal_int_data() const {
  return data_case() == kIntData ? *_impl_.data_.int_data_ : reinterpret_cast<::milvus::proto::schema::IntArray&>(::milvus::proto::schema::_IntArray_default_instance_);
}
inline const ::milvus::proto::schema::IntArray& ScalarField::int_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ScalarField.int_data)
  return _internal_int_data();
}
inline ::milvus::proto::schema::IntArray* ScalarField::unsafe_arena_release_int_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.schema.ScalarField.int_data)
  if (data_case() == kIntData) {
    clear_has_data();
    auto* temp = _impl_.data_.int_data_;
    _impl_.data_.int_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ScalarField::unsafe_arena_set_allocated_int_data(::milvus::proto::schema::IntArray* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_int_data();
    _impl_.data_.int_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.ScalarField.int_data)
}
inline ::milvus::proto::schema::IntArray* ScalarField::_internal_mutable_int_data() {
  if (data_case() != kIntData) {
    clear_data();
    set_has_int_data();
    _impl_.data_.int_data_ = CreateMaybeMessage<::milvus::proto::schema::IntArray>(GetArena());
  }
  return _impl_.data_.int_data_;
}
inline ::milvus::proto::schema::IntArray* ScalarField::mutable_int_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::IntArray* _msg = _internal_mutable_int_data();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.ScalarField.int_data)
  return _msg;
}

// .milvus.proto.schema.LongArray long_data = 3;
inline bool ScalarField::has_long_data() const {
  return data_case() == kLongData;
}
inline bool ScalarField::_internal_has_long_data() const {
  return data_case() == kLongData;
}
inline void ScalarField::set_has_long_data() {
  _impl_._oneof_case_[0] = kLongData;
}
inline void ScalarField::clear_long_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kLongData) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.long_data_;
    }
    clear_has_data();
  }
}
inline ::milvus::proto::schema::LongArray* ScalarField::release_long_data() {
  // @@protoc_insertion_point(field_release:milvus.proto.schema.ScalarField.long_data)
  if (data_case() == kLongData) {
    clear_has_data();
    auto* temp = _impl_.data_.long_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.long_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::schema::LongArray& ScalarField::_internal_long_data() const {
  return data_case() == kLongData ? *_impl_.data_.long_data_ : reinterpret_cast<::milvus::proto::schema::LongArray&>(::milvus::proto::schema::_LongArray_default_instance_);
}
inline const ::milvus::proto::schema::LongArray& ScalarField::long_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ScalarField.long_data)
  return _internal_long_data();
}
inline ::milvus::proto::schema::LongArray* ScalarField::unsafe_arena_release_long_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.schema.ScalarField.long_data)
  if (data_case() == kLongData) {
    clear_has_data();
    auto* temp = _impl_.data_.long_data_;
    _impl_.data_.long_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ScalarField::unsafe_arena_set_allocated_long_data(::milvus::proto::schema::LongArray* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_long_data();
    _impl_.data_.long_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.ScalarField.long_data)
}
inline ::milvus::proto::schema::LongArray* ScalarField::_internal_mutable_long_data() {
  if (data_case() != kLongData) {
    clear_data();
    set_has_long_data();
    _impl_.data_.long_data_ = CreateMaybeMessage<::milvus::proto::schema::LongArray>(GetArena());
  }
  return _impl_.data_.long_data_;
}
inline ::milvus::proto::schema::LongArray* ScalarField::mutable_long_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::LongArray* _msg = _internal_mutable_long_data();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.ScalarField.long_data)
  return _msg;
}

// .milvus.proto.schema.FloatArray float_data = 4;
inline bool ScalarField::has_float_data() const {
  return data_case() == kFloatData;
}
inline bool ScalarField::_internal_has_float_data() const {
  return data_case() == kFloatData;
}
inline void ScalarField::set_has_float_data() {
  _impl_._oneof_case_[0] = kFloatData;
}
inline void ScalarField::clear_float_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kFloatData) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.float_data_;
    }
    clear_has_data();
  }
}
inline ::milvus::proto::schema::FloatArray* ScalarField::release_float_data() {
  // @@protoc_insertion_point(field_release:milvus.proto.schema.ScalarField.float_data)
  if (data_case() == kFloatData) {
    clear_has_data();
    auto* temp = _impl_.data_.float_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.float_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::schema::FloatArray& ScalarField::_internal_float_data() const {
  return data_case() == kFloatData ? *_impl_.data_.float_data_ : reinterpret_cast<::milvus::proto::schema::FloatArray&>(::milvus::proto::schema::_FloatArray_default_instance_);
}
inline const ::milvus::proto::schema::FloatArray& ScalarField::float_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ScalarField.float_data)
  return _internal_float_data();
}
inline ::milvus::proto::schema::FloatArray* ScalarField::unsafe_arena_release_float_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.schema.ScalarField.float_data)
  if (data_case() == kFloatData) {
    clear_has_data();
    auto* temp = _impl_.data_.float_data_;
    _impl_.data_.float_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ScalarField::unsafe_arena_set_allocated_float_data(::milvus::proto::schema::FloatArray* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_float_data();
    _impl_.data_.float_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.ScalarField.float_data)
}
inline ::milvus::proto::schema::FloatArray* ScalarField::_internal_mutable_float_data() {
  if (data_case() != kFloatData) {
    clear_data();
    set_has_float_data();
    _impl_.data_.float_data_ = CreateMaybeMessage<::milvus::proto::schema::FloatArray>(GetArena());
  }
  return _impl_.data_.float_data_;
}
inline ::milvus::proto::schema::FloatArray* ScalarField::mutable_float_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::FloatArray* _msg = _internal_mutable_float_data();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.ScalarField.float_data)
  return _msg;
}

// .milvus.proto.schema.DoubleArray double_data = 5;
inline bool ScalarField::has_double_data() const {
  return data_case() == kDoubleData;
}
inline bool ScalarField::_internal_has_double_data() const {
  return data_case() == kDoubleData;
}
inline void ScalarField::set_has_double_data() {
  _impl_._oneof_case_[0] = kDoubleData;
}
inline void ScalarField::clear_double_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kDoubleData) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.double_data_;
    }
    clear_has_data();
  }
}
inline ::milvus::proto::schema::DoubleArray* ScalarField::release_double_data() {
  // @@protoc_insertion_point(field_release:milvus.proto.schema.ScalarField.double_data)
  if (data_case() == kDoubleData) {
    clear_has_data();
    auto* temp = _impl_.data_.double_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.double_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::schema::DoubleArray& ScalarField::_internal_double_data() const {
  return data_case() == kDoubleData ? *_impl_.data_.double_data_ : reinterpret_cast<::milvus::proto::schema::DoubleArray&>(::milvus::proto::schema::_DoubleArray_default_instance_);
}
inline const ::milvus::proto::schema::DoubleArray& ScalarField::double_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ScalarField.double_data)
  return _internal_double_data();
}
inline ::milvus::proto::schema::DoubleArray* ScalarField::unsafe_arena_release_double_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.schema.ScalarField.double_data)
  if (data_case() == kDoubleData) {
    clear_has_data();
    auto* temp = _impl_.data_.double_data_;
    _impl_.data_.double_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ScalarField::unsafe_arena_set_allocated_double_data(::milvus::proto::schema::DoubleArray* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_double_data();
    _impl_.data_.double_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.ScalarField.double_data)
}
inline ::milvus::proto::schema::DoubleArray* ScalarField::_internal_mutable_double_data() {
  if (data_case() != kDoubleData) {
    clear_data();
    set_has_double_data();
    _impl_.data_.double_data_ = CreateMaybeMessage<::milvus::proto::schema::DoubleArray>(GetArena());
  }
  return _impl_.data_.double_data_;
}
inline ::milvus::proto::schema::DoubleArray* ScalarField::mutable_double_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::DoubleArray* _msg = _internal_mutable_double_data();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.ScalarField.double_data)
  return _msg;
}

// .milvus.proto.schema.StringArray string_data = 6;
inline bool ScalarField::has_string_data() const {
  return data_case() == kStringData;
}
inline bool ScalarField::_internal_has_string_data() const {
  return data_case() == kStringData;
}
inline void ScalarField::set_has_string_data() {
  _impl_._oneof_case_[0] = kStringData;
}
inline void ScalarField::clear_string_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kStringData) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.string_data_;
    }
    clear_has_data();
  }
}
inline ::milvus::proto::schema::StringArray* ScalarField::release_string_data() {
  // @@protoc_insertion_point(field_release:milvus.proto.schema.ScalarField.string_data)
  if (data_case() == kStringData) {
    clear_has_data();
    auto* temp = _impl_.data_.string_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.string_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::schema::StringArray& ScalarField::_internal_string_data() const {
  return data_case() == kStringData ? *_impl_.data_.string_data_ : reinterpret_cast<::milvus::proto::schema::StringArray&>(::milvus::proto::schema::_StringArray_default_instance_);
}
inline const ::milvus::proto::schema::StringArray& ScalarField::string_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ScalarField.string_data)
  return _internal_string_data();
}
inline ::milvus::proto::schema::StringArray* ScalarField::unsafe_arena_release_string_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.schema.ScalarField.string_data)
  if (data_case() == kStringData) {
    clear_has_data();
    auto* temp = _impl_.data_.string_data_;
    _impl_.data_.string_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ScalarField::unsafe_arena_set_allocated_string_data(::milvus::proto::schema::StringArray* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_string_data();
    _impl_.data_.string_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.ScalarField.string_data)
}
inline ::milvus::proto::schema::StringArray* ScalarField::_internal_mutable_string_data() {
  if (data_case() != kStringData) {
    clear_data();
    set_has_string_data();
    _impl_.data_.string_data_ = CreateMaybeMessage<::milvus::proto::schema::StringArray>(GetArena());
  }
  return _impl_.data_.string_data_;
}
inline ::milvus::proto::schema::StringArray* ScalarField::mutable_string_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::StringArray* _msg = _internal_mutable_string_data();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.ScalarField.string_data)
  return _msg;
}

// .milvus.proto.schema.BytesArray bytes_data = 7;
inline bool ScalarField::has_bytes_data() const {
  return data_case() == kBytesData;
}
inline bool ScalarField::_internal_has_bytes_data() const {
  return data_case() == kBytesData;
}
inline void ScalarField::set_has_bytes_data() {
  _impl_._oneof_case_[0] = kBytesData;
}
inline void ScalarField::clear_bytes_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kBytesData) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.bytes_data_;
    }
    clear_has_data();
  }
}
inline ::milvus::proto::schema::BytesArray* ScalarField::release_bytes_data() {
  // @@protoc_insertion_point(field_release:milvus.proto.schema.ScalarField.bytes_data)
  if (data_case() == kBytesData) {
    clear_has_data();
    auto* temp = _impl_.data_.bytes_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.bytes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::schema::BytesArray& ScalarField::_internal_bytes_data() const {
  return data_case() == kBytesData ? *_impl_.data_.bytes_data_ : reinterpret_cast<::milvus::proto::schema::BytesArray&>(::milvus::proto::schema::_BytesArray_default_instance_);
}
inline const ::milvus::proto::schema::BytesArray& ScalarField::bytes_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ScalarField.bytes_data)
  return _internal_bytes_data();
}
inline ::milvus::proto::schema::BytesArray* ScalarField::unsafe_arena_release_bytes_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.schema.ScalarField.bytes_data)
  if (data_case() == kBytesData) {
    clear_has_data();
    auto* temp = _impl_.data_.bytes_data_;
    _impl_.data_.bytes_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ScalarField::unsafe_arena_set_allocated_bytes_data(::milvus::proto::schema::BytesArray* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_bytes_data();
    _impl_.data_.bytes_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.ScalarField.bytes_data)
}
inline ::milvus::proto::schema::BytesArray* ScalarField::_internal_mutable_bytes_data() {
  if (data_case() != kBytesData) {
    clear_data();
    set_has_bytes_data();
    _impl_.data_.bytes_data_ = CreateMaybeMessage<::milvus::proto::schema::BytesArray>(GetArena());
  }
  return _impl_.data_.bytes_data_;
}
inline ::milvus::proto::schema::BytesArray* ScalarField::mutable_bytes_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::BytesArray* _msg = _internal_mutable_bytes_data();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.ScalarField.bytes_data)
  return _msg;
}

// .milvus.proto.schema.ArrayArray array_data = 8;
inline bool ScalarField::has_array_data() const {
  return data_case() == kArrayData;
}
inline bool ScalarField::_internal_has_array_data() const {
  return data_case() == kArrayData;
}
inline void ScalarField::set_has_array_data() {
  _impl_._oneof_case_[0] = kArrayData;
}
inline void ScalarField::clear_array_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kArrayData) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.array_data_;
    }
    clear_has_data();
  }
}
inline ::milvus::proto::schema::ArrayArray* ScalarField::release_array_data() {
  // @@protoc_insertion_point(field_release:milvus.proto.schema.ScalarField.array_data)
  if (data_case() == kArrayData) {
    clear_has_data();
    auto* temp = _impl_.data_.array_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.array_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::schema::ArrayArray& ScalarField::_internal_array_data() const {
  return data_case() == kArrayData ? *_impl_.data_.array_data_ : reinterpret_cast<::milvus::proto::schema::ArrayArray&>(::milvus::proto::schema::_ArrayArray_default_instance_);
}
inline const ::milvus::proto::schema::ArrayArray& ScalarField::array_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ScalarField.array_data)
  return _internal_array_data();
}
inline ::milvus::proto::schema::ArrayArray* ScalarField::unsafe_arena_release_array_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.schema.ScalarField.array_data)
  if (data_case() == kArrayData) {
    clear_has_data();
    auto* temp = _impl_.data_.array_data_;
    _impl_.data_.array_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ScalarField::unsafe_arena_set_allocated_array_data(::milvus::proto::schema::ArrayArray* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_array_data();
    _impl_.data_.array_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.ScalarField.array_data)
}
inline ::milvus::proto::schema::ArrayArray* ScalarField::_internal_mutable_array_data() {
  if (data_case() != kArrayData) {
    clear_data();
    set_has_array_data();
    _impl_.data_.array_data_ = CreateMaybeMessage<::milvus::proto::schema::ArrayArray>(GetArena());
  }
  return _impl_.data_.array_data_;
}
inline ::milvus::proto::schema::ArrayArray* ScalarField::mutable_array_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::ArrayArray* _msg = _internal_mutable_array_data();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.ScalarField.array_data)
  return _msg;
}

// .milvus.proto.schema.JSONArray json_data = 9;
inline bool ScalarField::has_json_data() const {
  return data_case() == kJsonData;
}
inline bool ScalarField::_internal_has_json_data() const {
  return data_case() == kJsonData;
}
inline void ScalarField::set_has_json_data() {
  _impl_._oneof_case_[0] = kJsonData;
}
inline void ScalarField::clear_json_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kJsonData) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.json_data_;
    }
    clear_has_data();
  }
}
inline ::milvus::proto::schema::JSONArray* ScalarField::release_json_data() {
  // @@protoc_insertion_point(field_release:milvus.proto.schema.ScalarField.json_data)
  if (data_case() == kJsonData) {
    clear_has_data();
    auto* temp = _impl_.data_.json_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.json_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::schema::JSONArray& ScalarField::_internal_json_data() const {
  return data_case() == kJsonData ? *_impl_.data_.json_data_ : reinterpret_cast<::milvus::proto::schema::JSONArray&>(::milvus::proto::schema::_JSONArray_default_instance_);
}
inline const ::milvus::proto::schema::JSONArray& ScalarField::json_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ScalarField.json_data)
  return _internal_json_data();
}
inline ::milvus::proto::schema::JSONArray* ScalarField::unsafe_arena_release_json_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.schema.ScalarField.json_data)
  if (data_case() == kJsonData) {
    clear_has_data();
    auto* temp = _impl_.data_.json_data_;
    _impl_.data_.json_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ScalarField::unsafe_arena_set_allocated_json_data(::milvus::proto::schema::JSONArray* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_json_data();
    _impl_.data_.json_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.ScalarField.json_data)
}
inline ::milvus::proto::schema::JSONArray* ScalarField::_internal_mutable_json_data() {
  if (data_case() != kJsonData) {
    clear_data();
    set_has_json_data();
    _impl_.data_.json_data_ = CreateMaybeMessage<::milvus::proto::schema::JSONArray>(GetArena());
  }
  return _impl_.data_.json_data_;
}
inline ::milvus::proto::schema::JSONArray* ScalarField::mutable_json_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::JSONArray* _msg = _internal_mutable_json_data();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.ScalarField.json_data)
  return _msg;
}

inline bool ScalarField::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void ScalarField::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline ScalarField::DataCase ScalarField::data_case() const {
  return ScalarField::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VectorField

// int64 dim = 1;
inline void VectorField::clear_dim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dim_ = ::int64_t{0};
}
inline ::int64_t VectorField::dim() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.VectorField.dim)
  return _internal_dim();
}
inline void VectorField::set_dim(::int64_t value) {
  _internal_set_dim(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.VectorField.dim)
}
inline ::int64_t VectorField::_internal_dim() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dim_;
}
inline void VectorField::_internal_set_dim(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dim_ = value;
}

// .milvus.proto.schema.FloatArray float_vector = 2;
inline bool VectorField::has_float_vector() const {
  return data_case() == kFloatVector;
}
inline bool VectorField::_internal_has_float_vector() const {
  return data_case() == kFloatVector;
}
inline void VectorField::set_has_float_vector() {
  _impl_._oneof_case_[0] = kFloatVector;
}
inline void VectorField::clear_float_vector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kFloatVector) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.float_vector_;
    }
    clear_has_data();
  }
}
inline ::milvus::proto::schema::FloatArray* VectorField::release_float_vector() {
  // @@protoc_insertion_point(field_release:milvus.proto.schema.VectorField.float_vector)
  if (data_case() == kFloatVector) {
    clear_has_data();
    auto* temp = _impl_.data_.float_vector_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.float_vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::schema::FloatArray& VectorField::_internal_float_vector() const {
  return data_case() == kFloatVector ? *_impl_.data_.float_vector_ : reinterpret_cast<::milvus::proto::schema::FloatArray&>(::milvus::proto::schema::_FloatArray_default_instance_);
}
inline const ::milvus::proto::schema::FloatArray& VectorField::float_vector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.VectorField.float_vector)
  return _internal_float_vector();
}
inline ::milvus::proto::schema::FloatArray* VectorField::unsafe_arena_release_float_vector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.schema.VectorField.float_vector)
  if (data_case() == kFloatVector) {
    clear_has_data();
    auto* temp = _impl_.data_.float_vector_;
    _impl_.data_.float_vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VectorField::unsafe_arena_set_allocated_float_vector(::milvus::proto::schema::FloatArray* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_float_vector();
    _impl_.data_.float_vector_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.VectorField.float_vector)
}
inline ::milvus::proto::schema::FloatArray* VectorField::_internal_mutable_float_vector() {
  if (data_case() != kFloatVector) {
    clear_data();
    set_has_float_vector();
    _impl_.data_.float_vector_ = CreateMaybeMessage<::milvus::proto::schema::FloatArray>(GetArena());
  }
  return _impl_.data_.float_vector_;
}
inline ::milvus::proto::schema::FloatArray* VectorField::mutable_float_vector() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::FloatArray* _msg = _internal_mutable_float_vector();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.VectorField.float_vector)
  return _msg;
}

// bytes binary_vector = 3;
inline bool VectorField::has_binary_vector() const {
  return data_case() == kBinaryVector;
}
inline void VectorField::set_has_binary_vector() {
  _impl_._oneof_case_[0] = kBinaryVector;
}
inline void VectorField::clear_binary_vector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kBinaryVector) {
    _impl_.data_.binary_vector_.Destroy();
    clear_has_data();
  }
}
inline const std::string& VectorField::binary_vector() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.VectorField.binary_vector)
  return _internal_binary_vector();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VectorField::set_binary_vector(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kBinaryVector) {
    clear_data();

    set_has_binary_vector();
    _impl_.data_.binary_vector_.InitDefault();
  }
  _impl_.data_.binary_vector_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:milvus.proto.schema.VectorField.binary_vector)
}
inline std::string* VectorField::mutable_binary_vector() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_binary_vector();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.VectorField.binary_vector)
  return _s;
}
inline const std::string& VectorField::_internal_binary_vector() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (data_case() != kBinaryVector) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.data_.binary_vector_.Get();
}
inline void VectorField::_internal_set_binary_vector(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kBinaryVector) {
    clear_data();

    set_has_binary_vector();
    _impl_.data_.binary_vector_.InitDefault();
  }
  _impl_.data_.binary_vector_.Set(value, GetArena());
}
inline std::string* VectorField::_internal_mutable_binary_vector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kBinaryVector) {
    clear_data();

    set_has_binary_vector();
    _impl_.data_.binary_vector_.InitDefault();
  }
  return _impl_.data_.binary_vector_.Mutable( GetArena());
}
inline std::string* VectorField::release_binary_vector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.schema.VectorField.binary_vector)
  if (data_case() != kBinaryVector) {
    return nullptr;
  }
  clear_has_data();
  return _impl_.data_.binary_vector_.Release();
}
inline void VectorField::set_allocated_binary_vector(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_data()) {
    clear_data();
  }
  if (value != nullptr) {
    set_has_binary_vector();
    _impl_.data_.binary_vector_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.schema.VectorField.binary_vector)
}

// bytes float16_vector = 4;
inline bool VectorField::has_float16_vector() const {
  return data_case() == kFloat16Vector;
}
inline void VectorField::set_has_float16_vector() {
  _impl_._oneof_case_[0] = kFloat16Vector;
}
inline void VectorField::clear_float16_vector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kFloat16Vector) {
    _impl_.data_.float16_vector_.Destroy();
    clear_has_data();
  }
}
inline const std::string& VectorField::float16_vector() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.VectorField.float16_vector)
  return _internal_float16_vector();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VectorField::set_float16_vector(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kFloat16Vector) {
    clear_data();

    set_has_float16_vector();
    _impl_.data_.float16_vector_.InitDefault();
  }
  _impl_.data_.float16_vector_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:milvus.proto.schema.VectorField.float16_vector)
}
inline std::string* VectorField::mutable_float16_vector() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_float16_vector();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.VectorField.float16_vector)
  return _s;
}
inline const std::string& VectorField::_internal_float16_vector() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (data_case() != kFloat16Vector) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.data_.float16_vector_.Get();
}
inline void VectorField::_internal_set_float16_vector(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kFloat16Vector) {
    clear_data();

    set_has_float16_vector();
    _impl_.data_.float16_vector_.InitDefault();
  }
  _impl_.data_.float16_vector_.Set(value, GetArena());
}
inline std::string* VectorField::_internal_mutable_float16_vector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kFloat16Vector) {
    clear_data();

    set_has_float16_vector();
    _impl_.data_.float16_vector_.InitDefault();
  }
  return _impl_.data_.float16_vector_.Mutable( GetArena());
}
inline std::string* VectorField::release_float16_vector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.schema.VectorField.float16_vector)
  if (data_case() != kFloat16Vector) {
    return nullptr;
  }
  clear_has_data();
  return _impl_.data_.float16_vector_.Release();
}
inline void VectorField::set_allocated_float16_vector(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_data()) {
    clear_data();
  }
  if (value != nullptr) {
    set_has_float16_vector();
    _impl_.data_.float16_vector_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.schema.VectorField.float16_vector)
}

// bytes bfloat16_vector = 5;
inline bool VectorField::has_bfloat16_vector() const {
  return data_case() == kBfloat16Vector;
}
inline void VectorField::set_has_bfloat16_vector() {
  _impl_._oneof_case_[0] = kBfloat16Vector;
}
inline void VectorField::clear_bfloat16_vector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kBfloat16Vector) {
    _impl_.data_.bfloat16_vector_.Destroy();
    clear_has_data();
  }
}
inline const std::string& VectorField::bfloat16_vector() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.VectorField.bfloat16_vector)
  return _internal_bfloat16_vector();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VectorField::set_bfloat16_vector(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kBfloat16Vector) {
    clear_data();

    set_has_bfloat16_vector();
    _impl_.data_.bfloat16_vector_.InitDefault();
  }
  _impl_.data_.bfloat16_vector_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:milvus.proto.schema.VectorField.bfloat16_vector)
}
inline std::string* VectorField::mutable_bfloat16_vector() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bfloat16_vector();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.VectorField.bfloat16_vector)
  return _s;
}
inline const std::string& VectorField::_internal_bfloat16_vector() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (data_case() != kBfloat16Vector) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.data_.bfloat16_vector_.Get();
}
inline void VectorField::_internal_set_bfloat16_vector(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kBfloat16Vector) {
    clear_data();

    set_has_bfloat16_vector();
    _impl_.data_.bfloat16_vector_.InitDefault();
  }
  _impl_.data_.bfloat16_vector_.Set(value, GetArena());
}
inline std::string* VectorField::_internal_mutable_bfloat16_vector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() != kBfloat16Vector) {
    clear_data();

    set_has_bfloat16_vector();
    _impl_.data_.bfloat16_vector_.InitDefault();
  }
  return _impl_.data_.bfloat16_vector_.Mutable( GetArena());
}
inline std::string* VectorField::release_bfloat16_vector() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.schema.VectorField.bfloat16_vector)
  if (data_case() != kBfloat16Vector) {
    return nullptr;
  }
  clear_has_data();
  return _impl_.data_.bfloat16_vector_.Release();
}
inline void VectorField::set_allocated_bfloat16_vector(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_data()) {
    clear_data();
  }
  if (value != nullptr) {
    set_has_bfloat16_vector();
    _impl_.data_.bfloat16_vector_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.schema.VectorField.bfloat16_vector)
}

inline bool VectorField::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void VectorField::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline VectorField::DataCase VectorField::data_case() const {
  return VectorField::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FieldData

// .milvus.proto.schema.DataType type = 1;
inline void FieldData::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::milvus::proto::schema::DataType FieldData::type() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldData.type)
  return _internal_type();
}
inline void FieldData::set_type(::milvus::proto::schema::DataType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.FieldData.type)
}
inline ::milvus::proto::schema::DataType FieldData::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::milvus::proto::schema::DataType>(_impl_.type_);
}
inline void FieldData::_internal_set_type(::milvus::proto::schema::DataType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// string field_name = 2;
inline void FieldData::clear_field_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.field_name_.ClearToEmpty();
}
inline const std::string& FieldData::field_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldData.field_name)
  return _internal_field_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FieldData::set_field_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.field_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:milvus.proto.schema.FieldData.field_name)
}
inline std::string* FieldData::mutable_field_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_field_name();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.FieldData.field_name)
  return _s;
}
inline const std::string& FieldData::_internal_field_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.field_name_.Get();
}
inline void FieldData::_internal_set_field_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.field_name_.Set(value, GetArena());
}
inline std::string* FieldData::_internal_mutable_field_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.field_name_.Mutable( GetArena());
}
inline std::string* FieldData::release_field_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.schema.FieldData.field_name)
  return _impl_.field_name_.Release();
}
inline void FieldData::set_allocated_field_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.field_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.field_name_.IsDefault()) {
          _impl_.field_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.schema.FieldData.field_name)
}

// .milvus.proto.schema.ScalarField scalars = 3;
inline bool FieldData::has_scalars() const {
  return field_case() == kScalars;
}
inline bool FieldData::_internal_has_scalars() const {
  return field_case() == kScalars;
}
inline void FieldData::set_has_scalars() {
  _impl_._oneof_case_[0] = kScalars;
}
inline void FieldData::clear_scalars() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (field_case() == kScalars) {
    if (GetArena() == nullptr) {
      delete _impl_.field_.scalars_;
    }
    clear_has_field();
  }
}
inline ::milvus::proto::schema::ScalarField* FieldData::release_scalars() {
  // @@protoc_insertion_point(field_release:milvus.proto.schema.FieldData.scalars)
  if (field_case() == kScalars) {
    clear_has_field();
    auto* temp = _impl_.field_.scalars_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.field_.scalars_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::schema::ScalarField& FieldData::_internal_scalars() const {
  return field_case() == kScalars ? *_impl_.field_.scalars_ : reinterpret_cast<::milvus::proto::schema::ScalarField&>(::milvus::proto::schema::_ScalarField_default_instance_);
}
inline const ::milvus::proto::schema::ScalarField& FieldData::scalars() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldData.scalars)
  return _internal_scalars();
}
inline ::milvus::proto::schema::ScalarField* FieldData::unsafe_arena_release_scalars() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.schema.FieldData.scalars)
  if (field_case() == kScalars) {
    clear_has_field();
    auto* temp = _impl_.field_.scalars_;
    _impl_.field_.scalars_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldData::unsafe_arena_set_allocated_scalars(::milvus::proto::schema::ScalarField* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_field();
  if (value) {
    set_has_scalars();
    _impl_.field_.scalars_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.FieldData.scalars)
}
inline ::milvus::proto::schema::ScalarField* FieldData::_internal_mutable_scalars() {
  if (field_case() != kScalars) {
    clear_field();
    set_has_scalars();
    _impl_.field_.scalars_ = CreateMaybeMessage<::milvus::proto::schema::ScalarField>(GetArena());
  }
  return _impl_.field_.scalars_;
}
inline ::milvus::proto::schema::ScalarField* FieldData::mutable_scalars() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::ScalarField* _msg = _internal_mutable_scalars();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.FieldData.scalars)
  return _msg;
}

// .milvus.proto.schema.VectorField vectors = 4;
inline bool FieldData::has_vectors() const {
  return field_case() == kVectors;
}
inline bool FieldData::_internal_has_vectors() const {
  return field_case() == kVectors;
}
inline void FieldData::set_has_vectors() {
  _impl_._oneof_case_[0] = kVectors;
}
inline void FieldData::clear_vectors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (field_case() == kVectors) {
    if (GetArena() == nullptr) {
      delete _impl_.field_.vectors_;
    }
    clear_has_field();
  }
}
inline ::milvus::proto::schema::VectorField* FieldData::release_vectors() {
  // @@protoc_insertion_point(field_release:milvus.proto.schema.FieldData.vectors)
  if (field_case() == kVectors) {
    clear_has_field();
    auto* temp = _impl_.field_.vectors_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.field_.vectors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::schema::VectorField& FieldData::_internal_vectors() const {
  return field_case() == kVectors ? *_impl_.field_.vectors_ : reinterpret_cast<::milvus::proto::schema::VectorField&>(::milvus::proto::schema::_VectorField_default_instance_);
}
inline const ::milvus::proto::schema::VectorField& FieldData::vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldData.vectors)
  return _internal_vectors();
}
inline ::milvus::proto::schema::VectorField* FieldData::unsafe_arena_release_vectors() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.schema.FieldData.vectors)
  if (field_case() == kVectors) {
    clear_has_field();
    auto* temp = _impl_.field_.vectors_;
    _impl_.field_.vectors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldData::unsafe_arena_set_allocated_vectors(::milvus::proto::schema::VectorField* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_field();
  if (value) {
    set_has_vectors();
    _impl_.field_.vectors_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.FieldData.vectors)
}
inline ::milvus::proto::schema::VectorField* FieldData::_internal_mutable_vectors() {
  if (field_case() != kVectors) {
    clear_field();
    set_has_vectors();
    _impl_.field_.vectors_ = CreateMaybeMessage<::milvus::proto::schema::VectorField>(GetArena());
  }
  return _impl_.field_.vectors_;
}
inline ::milvus::proto::schema::VectorField* FieldData::mutable_vectors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::VectorField* _msg = _internal_mutable_vectors();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.FieldData.vectors)
  return _msg;
}

// int64 field_id = 5;
inline void FieldData::clear_field_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.field_id_ = ::int64_t{0};
}
inline ::int64_t FieldData::field_id() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldData.field_id)
  return _internal_field_id();
}
inline void FieldData::set_field_id(::int64_t value) {
  _internal_set_field_id(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.FieldData.field_id)
}
inline ::int64_t FieldData::_internal_field_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.field_id_;
}
inline void FieldData::_internal_set_field_id(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.field_id_ = value;
}

// bool is_dynamic = 6;
inline void FieldData::clear_is_dynamic() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_dynamic_ = false;
}
inline bool FieldData::is_dynamic() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.FieldData.is_dynamic)
  return _internal_is_dynamic();
}
inline void FieldData::set_is_dynamic(bool value) {
  _internal_set_is_dynamic(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.FieldData.is_dynamic)
}
inline bool FieldData::_internal_is_dynamic() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_dynamic_;
}
inline void FieldData::_internal_set_is_dynamic(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_dynamic_ = value;
}

inline bool FieldData::has_field() const {
  return field_case() != FIELD_NOT_SET;
}
inline void FieldData::clear_has_field() {
  _impl_._oneof_case_[0] = FIELD_NOT_SET;
}
inline FieldData::FieldCase FieldData::field_case() const {
  return FieldData::FieldCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// IDs

// .milvus.proto.schema.LongArray int_id = 1;
inline bool IDs::has_int_id() const {
  return id_field_case() == kIntId;
}
inline bool IDs::_internal_has_int_id() const {
  return id_field_case() == kIntId;
}
inline void IDs::set_has_int_id() {
  _impl_._oneof_case_[0] = kIntId;
}
inline void IDs::clear_int_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (id_field_case() == kIntId) {
    if (GetArena() == nullptr) {
      delete _impl_.id_field_.int_id_;
    }
    clear_has_id_field();
  }
}
inline ::milvus::proto::schema::LongArray* IDs::release_int_id() {
  // @@protoc_insertion_point(field_release:milvus.proto.schema.IDs.int_id)
  if (id_field_case() == kIntId) {
    clear_has_id_field();
    auto* temp = _impl_.id_field_.int_id_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.id_field_.int_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::schema::LongArray& IDs::_internal_int_id() const {
  return id_field_case() == kIntId ? *_impl_.id_field_.int_id_ : reinterpret_cast<::milvus::proto::schema::LongArray&>(::milvus::proto::schema::_LongArray_default_instance_);
}
inline const ::milvus::proto::schema::LongArray& IDs::int_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.IDs.int_id)
  return _internal_int_id();
}
inline ::milvus::proto::schema::LongArray* IDs::unsafe_arena_release_int_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.schema.IDs.int_id)
  if (id_field_case() == kIntId) {
    clear_has_id_field();
    auto* temp = _impl_.id_field_.int_id_;
    _impl_.id_field_.int_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IDs::unsafe_arena_set_allocated_int_id(::milvus::proto::schema::LongArray* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_id_field();
  if (value) {
    set_has_int_id();
    _impl_.id_field_.int_id_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.IDs.int_id)
}
inline ::milvus::proto::schema::LongArray* IDs::_internal_mutable_int_id() {
  if (id_field_case() != kIntId) {
    clear_id_field();
    set_has_int_id();
    _impl_.id_field_.int_id_ = CreateMaybeMessage<::milvus::proto::schema::LongArray>(GetArena());
  }
  return _impl_.id_field_.int_id_;
}
inline ::milvus::proto::schema::LongArray* IDs::mutable_int_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::LongArray* _msg = _internal_mutable_int_id();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.IDs.int_id)
  return _msg;
}

// .milvus.proto.schema.StringArray str_id = 2;
inline bool IDs::has_str_id() const {
  return id_field_case() == kStrId;
}
inline bool IDs::_internal_has_str_id() const {
  return id_field_case() == kStrId;
}
inline void IDs::set_has_str_id() {
  _impl_._oneof_case_[0] = kStrId;
}
inline void IDs::clear_str_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (id_field_case() == kStrId) {
    if (GetArena() == nullptr) {
      delete _impl_.id_field_.str_id_;
    }
    clear_has_id_field();
  }
}
inline ::milvus::proto::schema::StringArray* IDs::release_str_id() {
  // @@protoc_insertion_point(field_release:milvus.proto.schema.IDs.str_id)
  if (id_field_case() == kStrId) {
    clear_has_id_field();
    auto* temp = _impl_.id_field_.str_id_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.id_field_.str_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::schema::StringArray& IDs::_internal_str_id() const {
  return id_field_case() == kStrId ? *_impl_.id_field_.str_id_ : reinterpret_cast<::milvus::proto::schema::StringArray&>(::milvus::proto::schema::_StringArray_default_instance_);
}
inline const ::milvus::proto::schema::StringArray& IDs::str_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.IDs.str_id)
  return _internal_str_id();
}
inline ::milvus::proto::schema::StringArray* IDs::unsafe_arena_release_str_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:milvus.proto.schema.IDs.str_id)
  if (id_field_case() == kStrId) {
    clear_has_id_field();
    auto* temp = _impl_.id_field_.str_id_;
    _impl_.id_field_.str_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void IDs::unsafe_arena_set_allocated_str_id(::milvus::proto::schema::StringArray* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_id_field();
  if (value) {
    set_has_str_id();
    _impl_.id_field_.str_id_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.IDs.str_id)
}
inline ::milvus::proto::schema::StringArray* IDs::_internal_mutable_str_id() {
  if (id_field_case() != kStrId) {
    clear_id_field();
    set_has_str_id();
    _impl_.id_field_.str_id_ = CreateMaybeMessage<::milvus::proto::schema::StringArray>(GetArena());
  }
  return _impl_.id_field_.str_id_;
}
inline ::milvus::proto::schema::StringArray* IDs::mutable_str_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::StringArray* _msg = _internal_mutable_str_id();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.IDs.str_id)
  return _msg;
}

inline bool IDs::has_id_field() const {
  return id_field_case() != ID_FIELD_NOT_SET;
}
inline void IDs::clear_has_id_field() {
  _impl_._oneof_case_[0] = ID_FIELD_NOT_SET;
}
inline IDs::IdFieldCase IDs::id_field_case() const {
  return IDs::IdFieldCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SearchResultData

// int64 num_queries = 1;
inline void SearchResultData::clear_num_queries() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_queries_ = ::int64_t{0};
}
inline ::int64_t SearchResultData::num_queries() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.SearchResultData.num_queries)
  return _internal_num_queries();
}
inline void SearchResultData::set_num_queries(::int64_t value) {
  _internal_set_num_queries(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.SearchResultData.num_queries)
}
inline ::int64_t SearchResultData::_internal_num_queries() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_queries_;
}
inline void SearchResultData::_internal_set_num_queries(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_queries_ = value;
}

// int64 top_k = 2;
inline void SearchResultData::clear_top_k() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.top_k_ = ::int64_t{0};
}
inline ::int64_t SearchResultData::top_k() const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.SearchResultData.top_k)
  return _internal_top_k();
}
inline void SearchResultData::set_top_k(::int64_t value) {
  _internal_set_top_k(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.SearchResultData.top_k)
}
inline ::int64_t SearchResultData::_internal_top_k() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.top_k_;
}
inline void SearchResultData::_internal_set_top_k(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.top_k_ = value;
}

// repeated .milvus.proto.schema.FieldData fields_data = 3;
inline int SearchResultData::_internal_fields_data_size() const {
  return _internal_fields_data().size();
}
inline int SearchResultData::fields_data_size() const {
  return _internal_fields_data_size();
}
inline void SearchResultData::clear_fields_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fields_data_.Clear();
}
inline ::milvus::proto::schema::FieldData* SearchResultData::mutable_fields_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.SearchResultData.fields_data)
  return _internal_mutable_fields_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::FieldData>* SearchResultData::mutable_fields_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.SearchResultData.fields_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_fields_data();
}
inline const ::milvus::proto::schema::FieldData& SearchResultData::fields_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.SearchResultData.fields_data)
  return _internal_fields_data().Get(index);
}
inline ::milvus::proto::schema::FieldData* SearchResultData::add_fields_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::milvus::proto::schema::FieldData* _add = _internal_mutable_fields_data()->Add();
  // @@protoc_insertion_point(field_add:milvus.proto.schema.SearchResultData.fields_data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::FieldData>& SearchResultData::fields_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.SearchResultData.fields_data)
  return _internal_fields_data();
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::FieldData>&
SearchResultData::_internal_fields_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fields_data_;
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::FieldData>*
SearchResultData::_internal_mutable_fields_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.fields_data_;
}

// repeated float scores = 4;
inline int SearchResultData::_internal_scores_size() const {
  return _internal_scores().size();
}
inline int SearchResultData::scores_size() const {
  return _internal_scores_size();
}
inline void SearchResultData::clear_scores() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scores_.Clear();
}
inline float SearchResultData::scores(int index) const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.SearchResultData.scores)
  return _internal_scores().Get(index);
}
inline void SearchResultData::set_scores(int index, float value) {
  _internal_mutable_scores()->Set(index, value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.SearchResultData.scores)
}
inline void SearchResultData::add_scores(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_scores()->Add(value);
  // @@protoc_insertion_point(field_add:milvus.proto.schema.SearchResultData.scores)
}
inline const ::google::protobuf::RepeatedField<float>& SearchResultData::scores() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.SearchResultData.scores)
  return _internal_scores();
}
inline ::google::protobuf::RepeatedField<float>* SearchResultData::mutable_scores()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.SearchResultData.scores)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_scores();
}
inline const ::google::protobuf::RepeatedField<float>& SearchResultData::_internal_scores()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scores_;
}
inline ::google::protobuf::RepeatedField<float>* SearchResultData::_internal_mutable_scores() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.scores_;
}

// .milvus.proto.schema.IDs ids = 5;
inline bool SearchResultData::has_ids() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ids_ != nullptr);
  return value;
}
inline void SearchResultData::clear_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.ids_ != nullptr) _impl_.ids_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::schema::IDs& SearchResultData::_internal_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::schema::IDs* p = _impl_.ids_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::schema::IDs&>(::milvus::proto::schema::_IDs_default_instance_);
}
inline const ::milvus::proto::schema::IDs& SearchResultData::ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.SearchResultData.ids)
  return _internal_ids();
}
inline void SearchResultData::unsafe_arena_set_allocated_ids(::milvus::proto::schema::IDs* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ids_);
  }
  _impl_.ids_ = reinterpret_cast<::milvus::proto::schema::IDs*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.SearchResultData.ids)
}
inline ::milvus::proto::schema::IDs* SearchResultData::release_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::schema::IDs* released = _impl_.ids_;
  _impl_.ids_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::schema::IDs* SearchResultData::unsafe_arena_release_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.schema.SearchResultData.ids)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::schema::IDs* temp = _impl_.ids_;
  _impl_.ids_ = nullptr;
  return temp;
}
inline ::milvus::proto::schema::IDs* SearchResultData::_internal_mutable_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ids_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::schema::IDs>(GetArena());
    _impl_.ids_ = reinterpret_cast<::milvus::proto::schema::IDs*>(p);
  }
  return _impl_.ids_;
}
inline ::milvus::proto::schema::IDs* SearchResultData::mutable_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::IDs* _msg = _internal_mutable_ids();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.SearchResultData.ids)
  return _msg;
}
inline void SearchResultData::set_allocated_ids(::milvus::proto::schema::IDs* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::schema::IDs*>(_impl_.ids_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::schema::IDs*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ids_ = reinterpret_cast<::milvus::proto::schema::IDs*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.schema.SearchResultData.ids)
}

// repeated int64 topks = 6;
inline int SearchResultData::_internal_topks_size() const {
  return _internal_topks().size();
}
inline int SearchResultData::topks_size() const {
  return _internal_topks_size();
}
inline void SearchResultData::clear_topks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topks_.Clear();
}
inline ::int64_t SearchResultData::topks(int index) const {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.SearchResultData.topks)
  return _internal_topks().Get(index);
}
inline void SearchResultData::set_topks(int index, ::int64_t value) {
  _internal_mutable_topks()->Set(index, value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.SearchResultData.topks)
}
inline void SearchResultData::add_topks(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_topks()->Add(value);
  // @@protoc_insertion_point(field_add:milvus.proto.schema.SearchResultData.topks)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& SearchResultData::topks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.SearchResultData.topks)
  return _internal_topks();
}
inline ::google::protobuf::RepeatedField<::int64_t>* SearchResultData::mutable_topks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.SearchResultData.topks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_topks();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& SearchResultData::_internal_topks()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topks_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* SearchResultData::_internal_mutable_topks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.topks_;
}

// repeated string output_fields = 7;
inline int SearchResultData::_internal_output_fields_size() const {
  return _internal_output_fields().size();
}
inline int SearchResultData::output_fields_size() const {
  return _internal_output_fields_size();
}
inline void SearchResultData::clear_output_fields() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.output_fields_.Clear();
}
inline std::string* SearchResultData::add_output_fields()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_output_fields()->Add();
  // @@protoc_insertion_point(field_add_mutable:milvus.proto.schema.SearchResultData.output_fields)
  return _s;
}
inline const std::string& SearchResultData::output_fields(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.SearchResultData.output_fields)
  return _internal_output_fields().Get(index);
}
inline std::string* SearchResultData::mutable_output_fields(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.SearchResultData.output_fields)
  return _internal_mutable_output_fields()->Mutable(index);
}
inline void SearchResultData::set_output_fields(int index, const std::string& value) {
  _internal_mutable_output_fields()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:milvus.proto.schema.SearchResultData.output_fields)
}
inline void SearchResultData::set_output_fields(int index, std::string&& value) {
  _internal_mutable_output_fields()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:milvus.proto.schema.SearchResultData.output_fields)
}
inline void SearchResultData::set_output_fields(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_output_fields()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:milvus.proto.schema.SearchResultData.output_fields)
}
inline void SearchResultData::set_output_fields(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_output_fields()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:milvus.proto.schema.SearchResultData.output_fields)
}
inline void SearchResultData::set_output_fields(int index, absl::string_view value) {
  _internal_mutable_output_fields()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:milvus.proto.schema.SearchResultData.output_fields)
}
inline void SearchResultData::add_output_fields(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_output_fields()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:milvus.proto.schema.SearchResultData.output_fields)
}
inline void SearchResultData::add_output_fields(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_output_fields()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:milvus.proto.schema.SearchResultData.output_fields)
}
inline void SearchResultData::add_output_fields(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_output_fields()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:milvus.proto.schema.SearchResultData.output_fields)
}
inline void SearchResultData::add_output_fields(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_output_fields()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:milvus.proto.schema.SearchResultData.output_fields)
}
inline void SearchResultData::add_output_fields(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_output_fields()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:milvus.proto.schema.SearchResultData.output_fields)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SearchResultData::output_fields() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.SearchResultData.output_fields)
  return _internal_output_fields();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SearchResultData::mutable_output_fields() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.SearchResultData.output_fields)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_output_fields();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SearchResultData::_internal_output_fields() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.output_fields_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SearchResultData::_internal_mutable_output_fields() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.output_fields_;
}

// .milvus.proto.schema.FieldData group_by_field_value = 8;
inline bool SearchResultData::has_group_by_field_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.group_by_field_value_ != nullptr);
  return value;
}
inline void SearchResultData::clear_group_by_field_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.group_by_field_value_ != nullptr) _impl_.group_by_field_value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::milvus::proto::schema::FieldData& SearchResultData::_internal_group_by_field_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::schema::FieldData* p = _impl_.group_by_field_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::schema::FieldData&>(::milvus::proto::schema::_FieldData_default_instance_);
}
inline const ::milvus::proto::schema::FieldData& SearchResultData::group_by_field_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.SearchResultData.group_by_field_value)
  return _internal_group_by_field_value();
}
inline void SearchResultData::unsafe_arena_set_allocated_group_by_field_value(::milvus::proto::schema::FieldData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.group_by_field_value_);
  }
  _impl_.group_by_field_value_ = reinterpret_cast<::milvus::proto::schema::FieldData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.SearchResultData.group_by_field_value)
}
inline ::milvus::proto::schema::FieldData* SearchResultData::release_group_by_field_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::schema::FieldData* released = _impl_.group_by_field_value_;
  _impl_.group_by_field_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::schema::FieldData* SearchResultData::unsafe_arena_release_group_by_field_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.schema.SearchResultData.group_by_field_value)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::milvus::proto::schema::FieldData* temp = _impl_.group_by_field_value_;
  _impl_.group_by_field_value_ = nullptr;
  return temp;
}
inline ::milvus::proto::schema::FieldData* SearchResultData::_internal_mutable_group_by_field_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.group_by_field_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::schema::FieldData>(GetArena());
    _impl_.group_by_field_value_ = reinterpret_cast<::milvus::proto::schema::FieldData*>(p);
  }
  return _impl_.group_by_field_value_;
}
inline ::milvus::proto::schema::FieldData* SearchResultData::mutable_group_by_field_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::FieldData* _msg = _internal_mutable_group_by_field_value();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.SearchResultData.group_by_field_value)
  return _msg;
}
inline void SearchResultData::set_allocated_group_by_field_value(::milvus::proto::schema::FieldData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::schema::FieldData*>(_impl_.group_by_field_value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::schema::FieldData*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.group_by_field_value_ = reinterpret_cast<::milvus::proto::schema::FieldData*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.schema.SearchResultData.group_by_field_value)
}

// -------------------------------------------------------------------

// VectorClusteringInfo

// string field = 1;
inline void VectorClusteringInfo::clear_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.field_.ClearToEmpty();
}
inline const std::string& VectorClusteringInfo::field() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.VectorClusteringInfo.field)
  return _internal_field();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VectorClusteringInfo::set_field(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.field_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:milvus.proto.schema.VectorClusteringInfo.field)
}
inline std::string* VectorClusteringInfo::mutable_field() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.VectorClusteringInfo.field)
  return _s;
}
inline const std::string& VectorClusteringInfo::_internal_field() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.field_.Get();
}
inline void VectorClusteringInfo::_internal_set_field(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.field_.Set(value, GetArena());
}
inline std::string* VectorClusteringInfo::_internal_mutable_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.field_.Mutable( GetArena());
}
inline std::string* VectorClusteringInfo::release_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.schema.VectorClusteringInfo.field)
  return _impl_.field_.Release();
}
inline void VectorClusteringInfo::set_allocated_field(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.field_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.field_.IsDefault()) {
          _impl_.field_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.schema.VectorClusteringInfo.field)
}

// .milvus.proto.schema.VectorField centroid = 2;
inline bool VectorClusteringInfo::has_centroid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.centroid_ != nullptr);
  return value;
}
inline void VectorClusteringInfo::clear_centroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.centroid_ != nullptr) _impl_.centroid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::milvus::proto::schema::VectorField& VectorClusteringInfo::_internal_centroid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::milvus::proto::schema::VectorField* p = _impl_.centroid_;
  return p != nullptr ? *p : reinterpret_cast<const ::milvus::proto::schema::VectorField&>(::milvus::proto::schema::_VectorField_default_instance_);
}
inline const ::milvus::proto::schema::VectorField& VectorClusteringInfo::centroid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.VectorClusteringInfo.centroid)
  return _internal_centroid();
}
inline void VectorClusteringInfo::unsafe_arena_set_allocated_centroid(::milvus::proto::schema::VectorField* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.centroid_);
  }
  _impl_.centroid_ = reinterpret_cast<::milvus::proto::schema::VectorField*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:milvus.proto.schema.VectorClusteringInfo.centroid)
}
inline ::milvus::proto::schema::VectorField* VectorClusteringInfo::release_centroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::schema::VectorField* released = _impl_.centroid_;
  _impl_.centroid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::milvus::proto::schema::VectorField* VectorClusteringInfo::unsafe_arena_release_centroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.schema.VectorClusteringInfo.centroid)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::milvus::proto::schema::VectorField* temp = _impl_.centroid_;
  _impl_.centroid_ = nullptr;
  return temp;
}
inline ::milvus::proto::schema::VectorField* VectorClusteringInfo::_internal_mutable_centroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.centroid_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::schema::VectorField>(GetArena());
    _impl_.centroid_ = reinterpret_cast<::milvus::proto::schema::VectorField*>(p);
  }
  return _impl_.centroid_;
}
inline ::milvus::proto::schema::VectorField* VectorClusteringInfo::mutable_centroid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::milvus::proto::schema::VectorField* _msg = _internal_mutable_centroid();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.VectorClusteringInfo.centroid)
  return _msg;
}
inline void VectorClusteringInfo::set_allocated_centroid(::milvus::proto::schema::VectorField* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::milvus::proto::schema::VectorField*>(_impl_.centroid_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::milvus::proto::schema::VectorField*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.centroid_ = reinterpret_cast<::milvus::proto::schema::VectorField*>(value);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.schema.VectorClusteringInfo.centroid)
}

// -------------------------------------------------------------------

// ScalarClusteringInfo

// string field = 1;
inline void ScalarClusteringInfo::clear_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.field_.ClearToEmpty();
}
inline const std::string& ScalarClusteringInfo::field() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ScalarClusteringInfo.field)
  return _internal_field();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ScalarClusteringInfo::set_field(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.field_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:milvus.proto.schema.ScalarClusteringInfo.field)
}
inline std::string* ScalarClusteringInfo::mutable_field() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.ScalarClusteringInfo.field)
  return _s;
}
inline const std::string& ScalarClusteringInfo::_internal_field() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.field_.Get();
}
inline void ScalarClusteringInfo::_internal_set_field(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.field_.Set(value, GetArena());
}
inline std::string* ScalarClusteringInfo::_internal_mutable_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.field_.Mutable( GetArena());
}
inline std::string* ScalarClusteringInfo::release_field() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:milvus.proto.schema.ScalarClusteringInfo.field)
  return _impl_.field_.Release();
}
inline void ScalarClusteringInfo::set_allocated_field(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.field_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.field_.IsDefault()) {
          _impl_.field_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.schema.ScalarClusteringInfo.field)
}

// -------------------------------------------------------------------

// ClusteringInfo

// repeated .milvus.proto.schema.VectorClusteringInfo vector_clustering_infos = 1;
inline int ClusteringInfo::_internal_vector_clustering_infos_size() const {
  return _internal_vector_clustering_infos().size();
}
inline int ClusteringInfo::vector_clustering_infos_size() const {
  return _internal_vector_clustering_infos_size();
}
inline void ClusteringInfo::clear_vector_clustering_infos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vector_clustering_infos_.Clear();
}
inline ::milvus::proto::schema::VectorClusteringInfo* ClusteringInfo::mutable_vector_clustering_infos(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.ClusteringInfo.vector_clustering_infos)
  return _internal_mutable_vector_clustering_infos()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::VectorClusteringInfo>* ClusteringInfo::mutable_vector_clustering_infos()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.ClusteringInfo.vector_clustering_infos)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vector_clustering_infos();
}
inline const ::milvus::proto::schema::VectorClusteringInfo& ClusteringInfo::vector_clustering_infos(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ClusteringInfo.vector_clustering_infos)
  return _internal_vector_clustering_infos().Get(index);
}
inline ::milvus::proto::schema::VectorClusteringInfo* ClusteringInfo::add_vector_clustering_infos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::milvus::proto::schema::VectorClusteringInfo* _add = _internal_mutable_vector_clustering_infos()->Add();
  // @@protoc_insertion_point(field_add:milvus.proto.schema.ClusteringInfo.vector_clustering_infos)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::VectorClusteringInfo>& ClusteringInfo::vector_clustering_infos() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.ClusteringInfo.vector_clustering_infos)
  return _internal_vector_clustering_infos();
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::VectorClusteringInfo>&
ClusteringInfo::_internal_vector_clustering_infos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vector_clustering_infos_;
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::VectorClusteringInfo>*
ClusteringInfo::_internal_mutable_vector_clustering_infos() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vector_clustering_infos_;
}

// repeated .milvus.proto.schema.ScalarClusteringInfo scalar_clustering_infos = 2;
inline int ClusteringInfo::_internal_scalar_clustering_infos_size() const {
  return _internal_scalar_clustering_infos().size();
}
inline int ClusteringInfo::scalar_clustering_infos_size() const {
  return _internal_scalar_clustering_infos_size();
}
inline void ClusteringInfo::clear_scalar_clustering_infos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scalar_clustering_infos_.Clear();
}
inline ::milvus::proto::schema::ScalarClusteringInfo* ClusteringInfo::mutable_scalar_clustering_infos(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:milvus.proto.schema.ClusteringInfo.scalar_clustering_infos)
  return _internal_mutable_scalar_clustering_infos()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::ScalarClusteringInfo>* ClusteringInfo::mutable_scalar_clustering_infos()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.schema.ClusteringInfo.scalar_clustering_infos)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_scalar_clustering_infos();
}
inline const ::milvus::proto::schema::ScalarClusteringInfo& ClusteringInfo::scalar_clustering_infos(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:milvus.proto.schema.ClusteringInfo.scalar_clustering_infos)
  return _internal_scalar_clustering_infos().Get(index);
}
inline ::milvus::proto::schema::ScalarClusteringInfo* ClusteringInfo::add_scalar_clustering_infos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::milvus::proto::schema::ScalarClusteringInfo* _add = _internal_mutable_scalar_clustering_infos()->Add();
  // @@protoc_insertion_point(field_add:milvus.proto.schema.ClusteringInfo.scalar_clustering_infos)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::ScalarClusteringInfo>& ClusteringInfo::scalar_clustering_infos() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:milvus.proto.schema.ClusteringInfo.scalar_clustering_infos)
  return _internal_scalar_clustering_infos();
}
inline const ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::ScalarClusteringInfo>&
ClusteringInfo::_internal_scalar_clustering_infos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scalar_clustering_infos_;
}
inline ::google::protobuf::RepeatedPtrField<::milvus::proto::schema::ScalarClusteringInfo>*
ClusteringInfo::_internal_mutable_scalar_clustering_infos() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.scalar_clustering_infos_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace schema
}  // namespace proto
}  // namespace milvus


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::milvus::proto::schema::DataType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::milvus::proto::schema::DataType>() {
  return ::milvus::proto::schema::DataType_descriptor();
}
template <>
struct is_proto_enum<::milvus::proto::schema::FieldState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::milvus::proto::schema::FieldState>() {
  return ::milvus::proto::schema::FieldState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_schema_2eproto_2epb_2eh
